{"ast":null,"code":"/*\n@license\nCopyright (c) 2016, Twilio, Inc.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\nSPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION\nOF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\nCONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n*/\n'use strict';\n\nrequire(\"core-js/modules/es.promise\");\n\nvar _classCallCheck = require(\"/Users/shouryagupta/Desktop/MS Engage 21/MSEngage21_VC/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/shouryagupta/Desktop/MS Engage 21/MSEngage21_VC/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/shouryagupta/Desktop/MS Engage 21/MSEngage21_VC/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/shouryagupta/Desktop/MS Engage 21/MSEngage21_VC/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/shouryagupta/Desktop/MS Engage 21/MSEngage21_VC/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _defineProperty = require('@babel/runtime/helpers/defineProperty');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);\n\nvar domain; // This constructor is used to store event handlers. Instantiating this is\n// faster than explicitly calling `Object.create(null)` to get a \"clean\" empty\n// object (tested with v8 v4.9).\n\nfunction EventHandlers() {}\n\nEventHandlers.prototype = Object.create(null);\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n} // nodejs oddity\n// require('events') === require('events').EventEmitter\n\n\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.usingDomains = false;\nEventEmitter.prototype.domain = undefined;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\n\nEventEmitter.defaultMaxListeners = 10;\n\nEventEmitter.init = function () {\n  this.domain = null;\n\n  if (EventEmitter.usingDomains) {\n    // if there is an active domain, then attach to it.\n    if (domain.active) ;\n  }\n\n  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = new EventHandlers();\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n}; // Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\n\n\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n)) throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n}; // These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\n\n\nfunction emitNone(handler, isFn, self) {\n  if (isFn) handler.call(self);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n\n    for (var i = 0; i < len; ++i) {\n      listeners[i].call(self);\n    }\n  }\n}\n\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn) handler.call(self, arg1);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n\n    for (var i = 0; i < len; ++i) {\n      listeners[i].call(self, arg1);\n    }\n  }\n}\n\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn) handler.call(self, arg1, arg2);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n\n    for (var i = 0; i < len; ++i) {\n      listeners[i].call(self, arg1, arg2);\n    }\n  }\n}\n\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn) handler.call(self, arg1, arg2, arg3);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n\n    for (var i = 0; i < len; ++i) {\n      listeners[i].call(self, arg1, arg2, arg3);\n    }\n  }\n}\n\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn) handler.apply(self, args);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n\n    for (var i = 0; i < len; ++i) {\n      listeners[i].apply(self, args);\n    }\n  }\n}\n\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events, domain;\n  var doError = type === 'error';\n  events = this._events;\n  if (events) doError = doError && events.error == null;else if (!doError) return false;\n  domain = this.domain; // If there is no 'error' event listener then throw.\n\n  if (doError) {\n    er = arguments[1];\n\n    if (domain) {\n      if (!er) er = new Error('Uncaught, unspecified \"error\" event');\n      er.domainEmitter = this;\n      er.domain = domain;\n      er.domainThrown = false;\n      domain.emit('error', er);\n    } else if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n\n    return false;\n  }\n\n  handler = events[type];\n  if (!handler) return false;\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n\n  switch (len) {\n    // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n    // slower\n\n    default:\n      args = new Array(len - 1);\n\n      for (i = 1; i < len; i++) {\n        args[i - 1] = arguments[i];\n      }\n\n      emitMany(handler, isFn, this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n  if (typeof listener !== 'function') throw new TypeError('\"listener\" argument must be a function');\n  events = target._events;\n\n  if (!events) {\n    events = target._events = new EventHandlers();\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n\n      events = target._events;\n    }\n\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] : [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    } // Check for listener leak\n\n\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + type + ' listeners added. ' + 'Use emitter.setMaxListeners() to increase limit');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        emitWarning(w);\n      }\n    }\n  }\n\n  return target;\n}\n\nfunction emitWarning(e) {\n  typeof console.warn === 'function' ? console.warn(e) : console.log(e);\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\n\nfunction _onceWrap(target, type, listener) {\n  var fired = false;\n\n  function g() {\n    target.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(target, arguments);\n    }\n  }\n\n  g.listener = listener;\n  return g;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  if (typeof listener !== 'function') throw new TypeError('\"listener\" argument must be a function');\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n}; // emits a 'removeListener' event iff the listener was removed\n\n\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  var list, events, position, i, originalListener;\n  if (typeof listener !== 'function') throw new TypeError('\"listener\" argument must be a function');\n  events = this._events;\n  if (!events) return this;\n  list = events[type];\n  if (!list) return this;\n\n  if (list === listener || list.listener && list.listener === listener) {\n    if (--this._eventsCount === 0) this._events = new EventHandlers();else {\n      delete events[type];\n      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n    }\n  } else if (typeof list !== 'function') {\n    position = -1;\n\n    for (i = list.length; i-- > 0;) {\n      if (list[i] === listener || list[i].listener && list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0) return this;\n\n    if (list.length === 1) {\n      list[0] = undefined;\n\n      if (--this._eventsCount === 0) {\n        this._events = new EventHandlers();\n        return this;\n      } else {\n        delete events[type];\n      }\n    } else {\n      spliceOne(list, position);\n    }\n\n    if (events.removeListener) this.emit('removeListener', type, originalListener || listener);\n  }\n\n  return this;\n}; // Alias for removeListener added in NodeJS 10.0\n// https://nodejs.org/api/events.html#events_emitter_off_eventname_listener\n\n\nEventEmitter.prototype.off = function (type, listener) {\n  return this.removeListener(type, listener);\n};\n\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  var listeners, events;\n  events = this._events;\n  if (!events) return this; // not listening for removeListener, no need to emit\n\n  if (!events.removeListener) {\n    if (arguments.length === 0) {\n      this._events = new EventHandlers();\n      this._eventsCount = 0;\n    } else if (events[type]) {\n      if (--this._eventsCount === 0) this._events = new EventHandlers();else delete events[type];\n    }\n\n    return this;\n  } // emit removeListener for all listeners on all events\n\n\n  if (arguments.length === 0) {\n    var keys = Object.keys(events);\n\n    for (var i = 0, key; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n\n    this.removeAllListeners('removeListener');\n    this._events = new EventHandlers();\n    this._eventsCount = 0;\n    return this;\n  }\n\n  listeners = events[type];\n\n  if (typeof listeners === 'function') {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    do {\n      this.removeListener(type, listeners[listeners.length - 1]);\n    } while (listeners[0]);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  var evlistener;\n  var ret;\n  var events = this._events;\n  if (!events) ret = [];else {\n    evlistener = events[type];\n    if (!evlistener) ret = [];else if (typeof evlistener === 'function') ret = [evlistener.listener || evlistener];else ret = unwrapListeners(evlistener);\n  }\n  return ret;\n};\n\nEventEmitter.listenerCount = function (emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\n\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n}; // About 1.5x faster than the two-arg version of Array#splice().\n\n\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {\n    list[i] = list[k];\n  }\n\n  list.pop();\n}\n\nfunction arrayClone(arr, i) {\n  var copy = new Array(i);\n\n  while (i--) {\n    copy[i] = arr[i];\n  }\n\n  return copy;\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n\n  return ret;\n}\n/**\n * Provides retrier service\n */\n\n\nvar Retrier = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Retrier, _EventEmitter);\n\n  var _super = _createSuper(Retrier);\n\n  // fibonacci strategy\n\n  /**\n   * Creates a new Retrier instance\n   */\n  function Retrier(options) {\n    var _this;\n\n    _classCallCheck(this, Retrier);\n\n    _this = _super.call(this);\n\n    _defineProperty__default['default'](_assertThisInitialized(_this), \"timeout\", null);\n\n    _defineProperty__default['default'](_assertThisInitialized(_this), \"startTimestamp\", -1);\n\n    _this.minDelay = options.min;\n    _this.maxDelay = options.max;\n    _this.initialDelay = options.initial || 0;\n    _this.maxAttemptsCount = options.maxAttemptsCount || 0;\n    _this.maxAttemptsTime = options.maxAttemptsTime || 0;\n    _this.randomness = options.randomness || 0;\n    _this.inProgress = false;\n    _this.attemptNum = 0;\n    _this.prevDelay = 0;\n    _this.currDelay = 0;\n    return _this;\n  }\n\n  _createClass(Retrier, [{\n    key: \"attempt\",\n    value: function attempt() {\n      if (this.timeout) {\n        clearTimeout(this.timeout);\n        this.timeout = null;\n      }\n\n      this.attemptNum++;\n      this.emit(\"attempt\", this);\n    }\n  }, {\n    key: \"nextDelay\",\n    value: function nextDelay(delayOverride) {\n      if (typeof delayOverride === \"number\") {\n        this.prevDelay = 0;\n        this.currDelay = delayOverride;\n        return delayOverride;\n      }\n\n      if (this.attemptNum == 0) {\n        return this.initialDelay;\n      }\n\n      if (this.attemptNum == 1) {\n        this.currDelay = this.minDelay;\n        return this.currDelay;\n      }\n\n      this.prevDelay = this.currDelay;\n      var delay = this.currDelay + this.prevDelay;\n\n      if (this.maxDelay && delay > this.maxDelay) {\n        this.currDelay = this.maxDelay;\n        delay = this.maxDelay;\n      }\n\n      this.currDelay = delay;\n      return delay;\n    }\n  }, {\n    key: \"randomize\",\n    value: function randomize(delay) {\n      var area = delay * this.randomness;\n      var corr = Math.round(Math.random() * area * 2 - area);\n      return Math.max(0, delay + corr);\n    }\n  }, {\n    key: \"scheduleAttempt\",\n    value: function scheduleAttempt(delayOverride) {\n      var _this2 = this;\n\n      if (this.maxAttemptsCount && this.attemptNum >= this.maxAttemptsCount) {\n        this.cleanup();\n        this.emit(\"failed\", new Error(\"Maximum attempt count limit reached\"));\n        return;\n      }\n\n      var delay = this.nextDelay(delayOverride);\n      delay = this.randomize(delay);\n\n      if (this.maxAttemptsTime && this.startTimestamp + this.maxAttemptsTime < Date.now() + delay) {\n        this.cleanup();\n        this.emit(\"failed\", new Error(\"Maximum attempt time limit reached\"));\n        return;\n      }\n\n      this.timeout = setTimeout(function () {\n        return _this2.attempt();\n      }, delay);\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      if (this.timeout) {\n        clearTimeout(this.timeout);\n        this.timeout = null;\n      }\n\n      this.inProgress = false;\n      this.attemptNum = 0;\n      this.prevDelay = 0;\n      this.currDelay = 0;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (this.inProgress) {\n        throw new Error(\"Retrier is already in progress\");\n      }\n\n      this.inProgress = true;\n      this.startTimestamp = Date.now();\n      this.scheduleAttempt(this.initialDelay);\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      if (this.timeout) {\n        clearTimeout(this.timeout);\n        this.timeout = null;\n        this.inProgress = false;\n        this.emit(\"cancelled\");\n      }\n    } // @todo Must be a T here, so the entire Retrier must be typed on this value type.\n    // eslint-disable-next-line\n\n  }, {\n    key: \"succeeded\",\n    value: function succeeded(arg) {\n      this.emit(\"succeeded\", arg);\n    }\n  }, {\n    key: \"failed\",\n    value: function failed(err, nextAttemptDelayOverride) {\n      if (this.timeout) {\n        throw new Error(\"Retrier attempt is already in progress\");\n      }\n\n      this.scheduleAttempt(nextAttemptDelayOverride);\n    }\n  }]);\n\n  return Retrier;\n}(EventEmitter);\n/**\n * Run retrier as an async function with possibility to await for it.\n * Example:\n * ```\n * const result = AsyncRetrier.run(async () => somePromise);\n * ```\n */\n\n\nvar AsyncRetrier = /*#__PURE__*/function (_EventEmitter2) {\n  _inherits(AsyncRetrier, _EventEmitter2);\n\n  var _super2 = _createSuper(AsyncRetrier);\n\n  // This any must be T typed directly on the AsyncRetrier\n  // eslint-disable-next-line\n  function AsyncRetrier(options) {\n    var _this3;\n\n    _classCallCheck(this, AsyncRetrier);\n\n    _this3 = _super2.call(this);\n\n    _defineProperty__default['default'](_assertThisInitialized(_this3), \"resolve\", function () {\n      return void 0;\n    });\n\n    _defineProperty__default['default'](_assertThisInitialized(_this3), \"reject\", function () {\n      return void 0;\n    });\n\n    _this3.retrier = new Retrier(options);\n    return _this3;\n  }\n\n  _createClass(AsyncRetrier, [{\n    key: \"run\",\n    value: function run(handler) {\n      var _this4 = this;\n\n      this.retrier.on(\"attempt\", function () {\n        handler().then(function (v) {\n          return _this4.retrier.succeeded(v);\n        }).catch(function (e) {\n          return _this4.retrier.failed(e);\n        });\n      });\n      this.retrier.on(\"succeeded\", function (arg) {\n        return _this4.resolve(arg);\n      });\n      this.retrier.on(\"cancelled\", function () {\n        return _this4.reject(new Error(\"Cancelled\"));\n      });\n      this.retrier.on(\"failed\", function (err) {\n        return _this4.reject(err);\n      });\n      return new Promise(function (resolve, reject) {\n        _this4.resolve = resolve;\n        _this4.reject = reject;\n\n        _this4.retrier.start();\n      });\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      this.retrier.cancel();\n    }\n  }]);\n\n  return AsyncRetrier;\n}(EventEmitter);\n\nfunction isDef(value) {\n  return value !== undefined && value !== null;\n}\n\nvar Backoff = /*#__PURE__*/function (_EventEmitter3) {\n  _inherits(Backoff, _EventEmitter3);\n\n  var _super3 = _createSuper(Backoff);\n\n  function Backoff(options) {\n    var _this5;\n\n    _classCallCheck(this, Backoff);\n\n    _this5 = _super3.call(this);\n\n    _defineProperty__default['default'](_assertThisInitialized(_this5), \"backoffDelay\", 0);\n\n    _defineProperty__default['default'](_assertThisInitialized(_this5), \"nextBackoffDelay\", 0);\n\n    _defineProperty__default['default'](_assertThisInitialized(_this5), \"backoffNumber\", 0);\n\n    _defineProperty__default['default'](_assertThisInitialized(_this5), \"timeoutID\", null);\n\n    _defineProperty__default['default'](_assertThisInitialized(_this5), \"maxNumberOfRetry\", -1);\n\n    options = options || {};\n    var _options = options,\n        initialDelay = _options.initialDelay,\n        maxDelay = _options.maxDelay,\n        randomisationFactor = _options.randomisationFactor,\n        factor = _options.factor;\n\n    if (isDef(initialDelay) && initialDelay < 1) {\n      throw new Error(\"The initial timeout must be equal to or greater than 1.\");\n    }\n\n    if (isDef(maxDelay) && maxDelay <= 1) {\n      throw new Error(\"The maximal timeout must be greater than 1.\");\n    }\n\n    if (isDef(randomisationFactor) && (randomisationFactor < 0 || randomisationFactor > 1)) {\n      throw new Error(\"The randomisation factor must be between 0 and 1.\");\n    }\n\n    if (isDef(factor) && factor <= 1) {\n      throw new Error(\"Exponential factor should be greater than 1.\");\n    }\n\n    _this5.initialDelay = initialDelay || 100;\n    _this5.maxDelay = maxDelay || 10000;\n\n    if (_this5.maxDelay <= _this5.initialDelay) {\n      throw new Error(\"The maximal backoff delay must be greater than the initial backoff delay.\");\n    }\n\n    _this5.randomisationFactor = randomisationFactor || 0;\n    _this5.factor = factor || 2;\n\n    _this5.reset();\n\n    return _this5;\n  }\n\n  _createClass(Backoff, [{\n    key: \"backoff\",\n    value: function backoff(err) {\n      if (this.timeoutID == null) {\n        if (this.backoffNumber === this.maxNumberOfRetry) {\n          this.emit(\"fail\", err);\n          this.reset();\n        } else {\n          this.backoffDelay = this.next();\n          this.timeoutID = setTimeout(this.onBackoff.bind(this), this.backoffDelay);\n          this.emit(\"backoff\", this.backoffNumber, this.backoffDelay, err);\n        }\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.backoffDelay = 0;\n      this.nextBackoffDelay = this.initialDelay;\n      this.backoffNumber = 0;\n\n      if (this.timeoutID) {\n        clearTimeout(this.timeoutID);\n      }\n\n      this.timeoutID = null;\n    }\n  }, {\n    key: \"failAfter\",\n    value: function failAfter(maxNumberOfRetry) {\n      if (maxNumberOfRetry <= 0) {\n        throw new Error(\"Expected a maximum number of retry greater than 0 but got \".concat(maxNumberOfRetry));\n      }\n\n      this.maxNumberOfRetry = maxNumberOfRetry;\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      this.backoffDelay = Math.min(this.nextBackoffDelay, this.maxDelay);\n      this.nextBackoffDelay = this.backoffDelay * this.factor;\n      var randomisationMultiple = 1 + Math.random() * this.randomisationFactor;\n      return Math.min(this.maxDelay, Math.round(this.backoffDelay * randomisationMultiple));\n    }\n  }, {\n    key: \"onBackoff\",\n    value: function onBackoff() {\n      this.timeoutID = null;\n      this.emit(\"ready\", this.backoffNumber, this.backoffDelay);\n      this.backoffNumber++;\n    }\n  }], [{\n    key: \"exponential\",\n    value: function exponential(options) {\n      return new Backoff(options);\n    }\n  }]);\n\n  return Backoff;\n}(EventEmitter);\n\nexports.AsyncRetrier = AsyncRetrier;\nexports.Backoff = Backoff;\nexports.Retrier = Retrier;","map":{"version":3,"sources":["../src/retrier.ts","../src/backoff.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from \"events\";\n\n/**\n * Provides retrier service\n */\nclass Retrier extends EventEmitter {\n  private readonly minDelay: number;\n  private maxDelay: number;\n  private readonly initialDelay: number;\n  private readonly maxAttemptsCount: number;\n  private readonly maxAttemptsTime: number;\n  private readonly randomness: number;\n\n  // fibonacci strategy\n  private prevDelay: number;\n  private currDelay: number;\n\n  private timeout: ReturnType<typeof setTimeout> | null = null;\n  private inProgress: boolean;\n  private attemptNum: number;\n  private startTimestamp = -1;\n\n  /**\n   * Creates a new Retrier instance\n   */\n  constructor(options: {\n    min: number;\n    max: number;\n    initial?: number;\n    maxAttemptsCount?: number;\n    maxAttemptsTime?: number;\n    randomness?: number;\n  }) {\n    super();\n\n    this.minDelay = options.min;\n    this.maxDelay = options.max;\n    this.initialDelay = options.initial || 0;\n    this.maxAttemptsCount = options.maxAttemptsCount || 0;\n    this.maxAttemptsTime = options.maxAttemptsTime || 0;\n    this.randomness = options.randomness || 0;\n\n    this.inProgress = false;\n    this.attemptNum = 0;\n\n    this.prevDelay = 0;\n    this.currDelay = 0;\n  }\n\n  private attempt() {\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n      this.timeout = null;\n    }\n\n    this.attemptNum++;\n    this.emit(\"attempt\", this);\n  }\n\n  private nextDelay(delayOverride?: number): number {\n    if (typeof delayOverride === \"number\") {\n      this.prevDelay = 0;\n      this.currDelay = delayOverride;\n      return delayOverride;\n    }\n\n    if (this.attemptNum == 0) {\n      return this.initialDelay;\n    }\n\n    if (this.attemptNum == 1) {\n      this.currDelay = this.minDelay;\n      return this.currDelay;\n    }\n\n    this.prevDelay = this.currDelay;\n\n    let delay = this.currDelay + this.prevDelay;\n\n    if (this.maxDelay && delay > this.maxDelay) {\n      this.currDelay = this.maxDelay;\n      delay = this.maxDelay;\n    }\n\n    this.currDelay = delay;\n    return delay;\n  }\n\n  private randomize(delay: number) {\n    const area = delay * this.randomness;\n    const corr = Math.round(Math.random() * area * 2 - area);\n    return Math.max(0, delay + corr);\n  }\n\n  private scheduleAttempt(delayOverride?: number) {\n    if (this.maxAttemptsCount && this.attemptNum >= this.maxAttemptsCount) {\n      this.cleanup();\n      this.emit(\"failed\", new Error(\"Maximum attempt count limit reached\"));\n      return;\n    }\n\n    let delay = this.nextDelay(delayOverride);\n    delay = this.randomize(delay);\n    if (\n      this.maxAttemptsTime &&\n      this.startTimestamp + this.maxAttemptsTime < Date.now() + delay\n    ) {\n      this.cleanup();\n      this.emit(\"failed\", new Error(\"Maximum attempt time limit reached\"));\n      return;\n    }\n\n    this.timeout = setTimeout(() => this.attempt(), delay);\n  }\n\n  private cleanup() {\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n      this.timeout = null;\n    }\n    this.inProgress = false;\n\n    this.attemptNum = 0;\n    this.prevDelay = 0;\n    this.currDelay = 0;\n  }\n\n  public start(): void {\n    if (this.inProgress) {\n      throw new Error(\"Retrier is already in progress\");\n    }\n\n    this.inProgress = true;\n    this.startTimestamp = Date.now();\n    this.scheduleAttempt(this.initialDelay);\n  }\n\n  public cancel(): void {\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n      this.timeout = null;\n      this.inProgress = false;\n\n      this.emit(\"cancelled\");\n    }\n  }\n\n  // @todo Must be a T here, so the entire Retrier must be typed on this value type.\n  // eslint-disable-next-line\n  public succeeded(arg?: any): void {\n    this.emit(\"succeeded\", arg);\n  }\n\n  public failed(err: Error, nextAttemptDelayOverride?: number): void {\n    if (this.timeout) {\n      throw new Error(\"Retrier attempt is already in progress\");\n    }\n\n    this.scheduleAttempt(nextAttemptDelayOverride);\n  }\n}\n\n/**\n * Run retrier as an async function with possibility to await for it.\n * Example:\n * ```\n * const result = AsyncRetrier.run(async () => somePromise);\n * ```\n */\nclass AsyncRetrier extends EventEmitter {\n  private retrier: Retrier;\n  // This any must be T typed directly on the AsyncRetrier\n  // eslint-disable-next-line\n  private resolve: (value: any) => void = () => void 0;\n  private reject: (err?: Error) => void = () => void 0;\n\n  constructor(options: {\n    min: number;\n    max: number;\n    initial?: number;\n    maxAttemptsCount?: number;\n    maxAttemptsTime?: number;\n    randomness?: number;\n  }) {\n    super();\n    this.retrier = new Retrier(options);\n  }\n\n  public run<T>(handler: () => Promise<T>): Promise<T> {\n    this.retrier.on(\"attempt\", () => {\n      handler()\n        .then((v) => this.retrier.succeeded(v))\n        .catch((e) => this.retrier.failed(e));\n    });\n\n    this.retrier.on(\"succeeded\", (arg) => this.resolve(arg));\n    this.retrier.on(\"cancelled\", () => this.reject(new Error(\"Cancelled\")));\n    this.retrier.on(\"failed\", (err) => this.reject(err));\n\n    return new Promise<T>((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n\n      this.retrier.start();\n    });\n  }\n\n  public cancel(): void {\n    this.retrier.cancel();\n  }\n}\n\nexport { Retrier, AsyncRetrier };\n","import { EventEmitter } from \"events\";\n\nfunction isDef(value: number | undefined | null): value is number {\n  return value !== undefined && value !== null;\n}\n\nexport interface BackoffOptions {\n  initialDelay?: number;\n  maxDelay?: number;\n  randomisationFactor?: number;\n  factor?: number;\n}\n\nclass Backoff extends EventEmitter {\n  private readonly maxDelay: number;\n  private readonly initialDelay: number;\n  private readonly factor: number;\n  private readonly randomisationFactor: number;\n  private backoffDelay = 0;\n  private nextBackoffDelay = 0;\n  private backoffNumber = 0;\n  private timeoutID: ReturnType<typeof setTimeout> | null = null;\n  private maxNumberOfRetry = -1;\n\n  constructor(options: BackoffOptions) {\n    super();\n    options = options || {};\n    const { initialDelay, maxDelay, randomisationFactor, factor } = options;\n\n    if (isDef(initialDelay) && initialDelay < 1) {\n      throw new Error(\n        \"The initial timeout must be equal to or greater than 1.\"\n      );\n    }\n    if (isDef(maxDelay) && maxDelay <= 1) {\n      throw new Error(\"The maximal timeout must be greater than 1.\");\n    }\n    if (\n      isDef(randomisationFactor) &&\n      (randomisationFactor < 0 || randomisationFactor > 1)\n    ) {\n      throw new Error(\"The randomisation factor must be between 0 and 1.\");\n    }\n    if (isDef(factor) && factor <= 1) {\n      throw new Error(`Exponential factor should be greater than 1.`);\n    }\n\n    this.initialDelay = initialDelay || 100;\n    this.maxDelay = maxDelay || 10000;\n    if (this.maxDelay <= this.initialDelay) {\n      throw new Error(\n        \"The maximal backoff delay must be greater than the initial backoff delay.\"\n      );\n    }\n    this.randomisationFactor = randomisationFactor || 0;\n    this.factor = factor || 2;\n    this.reset();\n  }\n\n  public static exponential(options: BackoffOptions): Backoff {\n    return new Backoff(options);\n  }\n\n  public backoff(err?: Error): void {\n    if (this.timeoutID == null) {\n      if (this.backoffNumber === this.maxNumberOfRetry) {\n        this.emit(\"fail\", err);\n        this.reset();\n      } else {\n        this.backoffDelay = this.next();\n        this.timeoutID = setTimeout(\n          this.onBackoff.bind(this),\n          this.backoffDelay\n        );\n        this.emit(\"backoff\", this.backoffNumber, this.backoffDelay, err);\n      }\n    }\n  }\n\n  public reset(): void {\n    this.backoffDelay = 0;\n    this.nextBackoffDelay = this.initialDelay;\n    this.backoffNumber = 0;\n    if (this.timeoutID) {\n      clearTimeout(this.timeoutID);\n    }\n    this.timeoutID = null;\n  }\n\n  public failAfter(maxNumberOfRetry: number): void {\n    if (maxNumberOfRetry <= 0) {\n      throw new Error(\n        `Expected a maximum number of retry greater than 0 but got ${maxNumberOfRetry}`\n      );\n    }\n\n    this.maxNumberOfRetry = maxNumberOfRetry;\n  }\n\n  next(): number {\n    this.backoffDelay = Math.min(this.nextBackoffDelay, this.maxDelay);\n    this.nextBackoffDelay = this.backoffDelay * this.factor;\n    const randomisationMultiple = 1 + Math.random() * this.randomisationFactor;\n    return Math.min(\n      this.maxDelay,\n      Math.round(this.backoffDelay * randomisationMultiple)\n    );\n  }\n\n  onBackoff(): void {\n    this.timeoutID = null;\n    this.emit(\"ready\", this.backoffNumber, this.backoffDelay);\n    this.backoffNumber++;\n  }\n}\n\nexport { Backoff };\nexport default Backoff;\n"]},"metadata":{},"sourceType":"script"}