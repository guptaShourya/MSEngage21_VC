{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/shouryagupta/Desktop/MS Engage 21/MSEngage21_VC/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _assertThisInitialized = require(\"/Users/shouryagupta/Desktop/MS Engage 21/MSEngage21_VC/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _get = require(\"/Users/shouryagupta/Desktop/MS Engage 21/MSEngage21_VC/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/shouryagupta/Desktop/MS Engage 21/MSEngage21_VC/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _asyncToGenerator = require(\"/Users/shouryagupta/Desktop/MS Engage 21/MSEngage21_VC/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _createClass = require(\"/Users/shouryagupta/Desktop/MS Engage 21/MSEngage21_VC/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/shouryagupta/Desktop/MS Engage 21/MSEngage21_VC/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/shouryagupta/Desktop/MS Engage 21/MSEngage21_VC/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _classCallCheck = require(\"/Users/shouryagupta/Desktop/MS Engage 21/MSEngage21_VC/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar uri_1 = require(\"./utils/uri\");\n\nvar syncerror_1 = require(\"./utils/syncerror\");\n\nvar logger_1 = require(\"./utils/logger\");\n\nvar events_1 = require(\"events\");\n\nvar entity_1 = require(\"./entity\");\n\nvar closeable_1 = require(\"./closeable\");\n\nvar cache_1 = require(\"./cache\");\n\nvar InsightsItem = function InsightsItem() {\n  _classCallCheck(this, InsightsItem);\n};\n\nexports.InsightsItem = InsightsItem;\n\nvar LiveQueryImpl = /*#__PURE__*/function (_entity_1$SyncEntity) {\n  _inherits(LiveQueryImpl, _entity_1$SyncEntity);\n\n  var _super = _createSuper(LiveQueryImpl);\n\n  function LiveQueryImpl(descriptor, services, removalHandler, items) {\n    var _this;\n\n    _classCallCheck(this, LiveQueryImpl);\n\n    _this = _super.call(this, services, removalHandler);\n    _this.descriptor = descriptor;\n    _this.cache = new cache_1.Cache();\n\n    if (items) {\n      items.forEach(function (item) {\n        _this.cache.store(item.key, {\n          key: item.key,\n          value: item.data\n        }, item.revision);\n      });\n    }\n\n    return _this;\n  } // public\n\n\n  _createClass(LiveQueryImpl, [{\n    key: \"onRemoved\",\n    // dummy stub from iface\n    value: function onRemoved() {}\n  }, {\n    key: \"getItems\",\n    value: function getItems() {\n      var dataByKey = {};\n      this.cache.forEach(function (key, item) {\n        dataByKey[key] = item.value;\n      });\n      return dataByKey;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_update\",\n    value: function _update(message, isStrictlyOrdered) {\n      switch (message.type) {\n        case 'live_query_item_updated':\n          this.handleItemMutated(message.item_key, message.item_data, message.item_revision);\n          break;\n\n        case 'live_query_item_removed':\n          this.handleItemRemoved(message.item_key, message.item_revision);\n          break;\n\n        case 'live_query_updated':\n          this.handleBatchUpdate(message.items);\n          break;\n      }\n\n      if (isStrictlyOrdered) {\n        this._advanceLastEventId(message.last_event_id);\n      }\n    }\n  }, {\n    key: \"handleItemMutated\",\n    value: function handleItemMutated(key, value, revision) {\n      if (this.shouldIgnoreEvent(key, revision)) {\n        logger_1.default.trace(\"Item \".concat(key, \" update skipped, revision: \").concat(revision));\n      } else {\n        var newItem = {\n          key: key,\n          value: value\n        };\n        this.cache.store(key, newItem, revision);\n        this.broadcastEventToListeners('itemUpdated', newItem);\n      }\n    }\n  }, {\n    key: \"handleItemRemoved\",\n    value: function handleItemRemoved(key, revision) {\n      var force = revision === null;\n\n      if (this.shouldIgnoreEvent(key, revision)) {\n        logger_1.default.trace(\"Item \".concat(key, \" delete skipped, revision: \").concat(revision));\n      } else {\n        this.cache.delete(key, revision, force);\n        this.broadcastEventToListeners('itemRemoved', {\n          key: key\n        });\n      }\n    }\n  }, {\n    key: \"handleBatchUpdate\",\n    value: function handleBatchUpdate(items) {\n      var _this2 = this;\n\n      // preprocess item set for easy key-based access (it's a one-time constant time operation)\n      var newItems = {};\n\n      if (items != null) {\n        items.forEach(function (item) {\n          newItems[item.key] = {\n            data: item.data,\n            revision: item.revision\n          };\n        });\n      } // go through existing items and generate update/remove events for them\n\n\n      this.cache.forEach(function (key, item) {\n        var newItem = newItems[key];\n\n        if (newItem != null) {\n          _this2.handleItemMutated(key, newItem.data, newItem.revision);\n        } else {\n          _this2.handleItemRemoved(key, null); // force deletion w/o revision\n\n        } // once item is handled, remove it from incoming array\n\n\n        delete newItems[key];\n      }); // once we handled all the known items, handle remaining pack\n\n      for (var key in newItems) {\n        this.handleItemMutated(key, newItems[key].data, newItems[key].revision);\n      }\n    }\n  }, {\n    key: \"shouldIgnoreEvent\",\n    value: function shouldIgnoreEvent(key, eventId) {\n      return key != null && eventId != null && this.cache.isKnown(key, eventId);\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_advanceLastEventId\",\n    value: function _advanceLastEventId(eventId, revision) {\n      // LiveQuery is not revisioned in any way, so simply ignore second param and act upon lastEventId only\n      if (this.lastEventId < eventId) {\n        this.descriptor.last_event_id = eventId;\n      }\n    }\n  }, {\n    key: \"sid\",\n    get: function get() {\n      return this.descriptor.sid;\n    } // private extension of SyncEntity\n\n  }, {\n    key: \"uniqueName\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return LiveQueryImpl.type;\n    }\n  }, {\n    key: \"lastEventId\",\n    get: function get() {\n      return this.descriptor.last_event_id;\n    }\n  }, {\n    key: \"indexName\",\n    get: function get() {\n      return this.descriptor.indexName;\n    }\n  }, {\n    key: \"queryString\",\n    get: function get() {\n      return this.descriptor.queryExpression;\n    } // custom private props\n\n  }, {\n    key: \"queryUri\",\n    get: function get() {\n      return this.descriptor.queryUri;\n    }\n  }, {\n    key: \"liveQueryDescriptor\",\n    get: function get() {\n      return this.descriptor;\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'live_query';\n    }\n  }]);\n\n  return LiveQueryImpl;\n}(entity_1.SyncEntity);\n\nexports.LiveQueryImpl = LiveQueryImpl;\n\nfunction queryItems(_x) {\n  return _queryItems.apply(this, arguments);\n}\n\nfunction _queryItems() {\n  _queryItems = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(params) {\n    var network, queryString, uri, type, liveQueryRequestBody, response;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            network = params.network, queryString = params.queryString, uri = params.uri, type = params.type;\n\n            if (!(queryString == null)) {\n              _context3.next = 3;\n              break;\n            }\n\n            throw new syncerror_1.SyncError(\"Invalid query\", 400, 54507);\n\n          case 3:\n            liveQueryRequestBody = {\n              query_string: queryString // raw query string (like `key == \"value\" AND key2 != \"value2\"`)\n\n            };\n\n            if (type === LiveQuery.type) {\n              liveQueryRequestBody.type = type;\n            }\n\n            _context3.next = 7;\n            return network.post(uri, liveQueryRequestBody, undefined, true);\n\n          case 7:\n            response = _context3.sent;\n            return _context3.abrupt(\"return\", response.body);\n\n          case 9:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _queryItems.apply(this, arguments);\n}\n\nexports.queryItems = queryItems;\n/**\n * @class\n * @alias LiveQuery\n * @classdesc Represents a long-running query against Flex data wherein the returned result set\n *     subsequently receives pushed updates whenever new (or updated) records would match the\n *     given expression. Updated results are presented row-by-row until this query is explicitly\n *     closed.\n *\n *     Use the {@link Client#liveQuery} method to create a live query.\n *\n * @property {String} sid The immutable identifier of this query object, assigned by the system.\n *\n * @fires LiveQuery#itemUpdated\n * @fires LiveQuery#itemRemoved\n */\n\nvar LiveQuery = /*#__PURE__*/function (_closeable_1$Closeabl) {\n  _inherits(LiveQuery, _closeable_1$Closeabl);\n\n  var _super2 = _createSuper(LiveQuery);\n\n  /**\n   * @private\n   */\n  function LiveQuery(liveQueryImpl) {\n    var _this3;\n\n    _classCallCheck(this, LiveQuery);\n\n    _this3 = _super2.call(this);\n    _this3.liveQueryImpl = liveQueryImpl;\n\n    _this3.liveQueryImpl.attach(_assertThisInitialized(_this3));\n\n    return _this3;\n  } // private props\n\n\n  _createClass(LiveQuery, [{\n    key: \"close\",\n\n    /**\n     * Closes this query instance and unsubscribes from further service events.\n     * This will eventually stop the physical inflow of updates over the network, when all other instances of this query are closed as well.\n     * @public\n     */\n    value: function close() {\n      _get(_getPrototypeOf(LiveQuery.prototype), \"close\", this).call(this);\n\n      this.liveQueryImpl.detach(this.listenerUuid);\n    }\n    /**\n     * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching the current query expression.\n     * @public\n     */\n\n  }, {\n    key: \"getItems\",\n    value: function getItems() {\n      this.ensureNotClosed();\n      return this.liveQueryImpl.getItems();\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return LiveQueryImpl.type;\n    }\n  }, {\n    key: \"lastEventId\",\n    get: function get() {\n      return this.liveQueryImpl.lastEventId;\n    } // public\n\n  }, {\n    key: \"sid\",\n    get: function get() {\n      return this.liveQueryImpl.sid;\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return LiveQueryImpl.type;\n    }\n  }]);\n\n  return LiveQuery;\n}(closeable_1.Closeable);\n\nexports.LiveQuery = LiveQuery;\n/**\n * @class\n * @alias InstantQuery\n * @classdesc Allows repetitive quick searches against a specific Flex data. Unlike a\n * LiveQuery, this result set does not subscribe to any updates and therefore receives no events\n * beyond the initial result set.\n *\n * Use the {@link Client#instantQuery} method to create an Instant Query.\n *\n * @fires InstantQuery#searchResult\n */\n\nvar InstantQuery = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(InstantQuery, _events_1$EventEmitte);\n\n  var _super3 = _createSuper(InstantQuery);\n\n  /**\n   * @private\n   */\n  function InstantQuery(params) {\n    var _this4;\n\n    _classCallCheck(this, InstantQuery);\n\n    _this4 = _super3.call(this);\n    _this4.queryExpression = null;\n    _this4.items = {};\n    Object.assign(_assertThisInitialized(_this4), params);\n\n    _this4.updateIndexName(params.indexName);\n\n    return _this4;\n  } // private props\n\n\n  _createClass(InstantQuery, [{\n    key: \"search\",\n\n    /**\n     * Spawns a new search request. The result will be provided asynchronously via the {@link InstantQuery#event:searchResult}\n     * event.\n     * @param {String} queryExpression A query expression to be executed against the given data index. For more information\n     * on the syntax read {@link Client#liveQuery}.\n     * @returns {Promise<void>} A promise that resolves when query result has been received.\n     * @public\n     */\n    value: function () {\n      var _search = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(queryExpression) {\n        var _this5 = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.items = {};\n                return _context.abrupt(\"return\", queryItems({\n                  network: this.network,\n                  uri: this.queryUri,\n                  queryString: queryExpression\n                }).then(function (response) {\n                  _this5.queryExpression = queryExpression;\n\n                  if (response.items) {\n                    response.items.forEach(function (item) {\n                      _this5.items[item.key] = item.data;\n                    });\n                  }\n\n                  _this5.emit('searchResult', _this5.getItems());\n                }).catch(function (err) {\n                  logger_1.default.error(\"Error '\".concat(err.message, \"' while executing query '\").concat(queryExpression, \"'\"));\n                  _this5.queryExpression = null;\n                  throw err;\n                }));\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function search(_x2) {\n        return _search.apply(this, arguments);\n      }\n\n      return search;\n    }()\n    /**\n     * Instantiates a LiveQuery object based on the last known query expression that was passed to the\n     * {@link InstantQuery#search} method. This LiveQuery will start receiving updates with new results,\n     * while current object can be still used to execute repetitive searches.\n     * @returns {Promise<LiveQuery>} A promise which resolves when the LiveQuery object is ready.\n     * @public\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function () {\n      var _subscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this.queryExpression == null)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", Promise.reject(new syncerror_1.SyncError(\"Invalid query\", 400, 54507)));\n\n              case 2:\n                return _context2.abrupt(\"return\", this.liveQueryCreator(this.indexName, this.queryExpression));\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function subscribe() {\n        return _subscribe.apply(this, arguments);\n      }\n\n      return subscribe;\n    }()\n    /**\n     * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching current query expression.\n     * @public\n     */\n\n  }, {\n    key: \"getItems\",\n    value: function getItems() {\n      return this.items;\n    }\n    /**\n     * Set new index name\n     * @param {String} indexName New index name to set\n     * @returns void\n     * @public\n     */\n\n  }, {\n    key: \"updateIndexName\",\n    value: function updateIndexName(indexName) {\n      if (!indexName || typeof indexName !== 'string') {\n        throw new Error('Index name must contain a non-empty string value');\n      }\n\n      this.indexName = indexName;\n      this.queryUri = this.generateQueryUri(this.indexName);\n    }\n  }, {\n    key: \"generateQueryUri\",\n    value: function generateQueryUri(indexName) {\n      return new uri_1.UriBuilder(this.insightsUri).pathSegment(indexName).pathSegment('Items').build();\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return InstantQuery.type;\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'instant_query';\n    }\n  }]);\n\n  return InstantQuery;\n}(events_1.EventEmitter);\n\nexports.InstantQuery = InstantQuery;\nexports.default = LiveQuery;\n/**\n * @class InsightsItem\n * @classdesc An individual result from a LiveQuery or InstantQuery result set.\n * @property {String} key The identifier that maps to this item within the search result.\n * @property {Object} value The contents of the item.\n */\n\n/**\n * A result set, i.e. a collection of items that matched a LiveQuery or InstantQuery expression. Each result is a\n * key-value pair, where each key identifies its object uniquely. These results are equivalent to a set of\n * {@link InsightsItem}-s.\n * @typedef {Object.<string, Object>} LiveQuery#ItemsSnapshot\n */\n\n/**\n * Fired when an item has been added or updated.\n * @event LiveQuery#itemUpdated\n * @param {InsightsItem} item Updated item.\n * @example\n * liveQuery.on('itemUpdated', function(item) {\n *   console.log('Item ' + item.key + ' was updated');\n *   console.log('Item value: ', item.value);\n * });\n */\n\n/**\n * Fired when an existing item has been removed.\n * @event LiveQuery#itemRemoved\n * @param {Object} args Arguments provided with the event.\n * @param {String} args.key The key of the removed item.\n * @example\n * liveQuery.on('itemRemoved', function(args) {\n *   console.log('Item ' + args.key + ' was removed');\n * });\n */\n\n/**\n * Fired when a search result is ready.\n * @event InstantQuery#searchResult\n * @param {LiveQuery#ItemsSnapshot} items A snapshot of items matching current query expression.\n * @example\n * instantQuery.on('searchResult', function(items) {\n *    Object.entries(items).forEach(([key, value]) => {\n *      console.log('Search result item key: ' + key);\n *      console.log('Search result item value: ' + value);\n *    });\n * });\n */","map":{"version":3,"sources":["/Users/shouryagupta/Desktop/MS Engage 21/MSEngage21_VC/node_modules/twilio-sync/lib/livequery.js"],"names":["Object","defineProperty","exports","value","uri_1","require","syncerror_1","logger_1","events_1","entity_1","closeable_1","cache_1","InsightsItem","LiveQueryImpl","descriptor","services","removalHandler","items","cache","Cache","forEach","item","store","key","data","revision","dataByKey","message","isStrictlyOrdered","type","handleItemMutated","item_key","item_data","item_revision","handleItemRemoved","handleBatchUpdate","_advanceLastEventId","last_event_id","shouldIgnoreEvent","default","trace","newItem","broadcastEventToListeners","force","delete","newItems","eventId","isKnown","lastEventId","sid","indexName","queryExpression","queryUri","SyncEntity","queryItems","params","network","queryString","uri","SyncError","liveQueryRequestBody","query_string","LiveQuery","post","undefined","response","body","liveQueryImpl","attach","detach","listenerUuid","ensureNotClosed","getItems","Closeable","InstantQuery","assign","updateIndexName","then","emit","catch","err","error","Promise","reject","liveQueryCreator","Error","generateQueryUri","UriBuilder","insightsUri","pathSegment","build","EventEmitter"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst uri_1 = require(\"./utils/uri\");\nconst syncerror_1 = require(\"./utils/syncerror\");\nconst logger_1 = require(\"./utils/logger\");\nconst events_1 = require(\"events\");\nconst entity_1 = require(\"./entity\");\nconst closeable_1 = require(\"./closeable\");\nconst cache_1 = require(\"./cache\");\nclass InsightsItem {\n}\nexports.InsightsItem = InsightsItem;\nclass LiveQueryImpl extends entity_1.SyncEntity {\n    constructor(descriptor, services, removalHandler, items) {\n        super(services, removalHandler);\n        this.descriptor = descriptor;\n        this.cache = new cache_1.Cache();\n        if (items) {\n            items.forEach(item => {\n                this.cache.store(item.key, { key: item.key, value: item.data }, item.revision);\n            });\n        }\n    }\n    // public\n    get sid() {\n        return this.descriptor.sid;\n    }\n    // private extension of SyncEntity\n    get uniqueName() {\n        return null;\n    }\n    get type() {\n        return LiveQueryImpl.type;\n    }\n    static get type() {\n        return 'live_query';\n    }\n    get lastEventId() {\n        return this.descriptor.last_event_id;\n    }\n    get indexName() {\n        return this.descriptor.indexName;\n    }\n    get queryString() {\n        return this.descriptor.queryExpression;\n    }\n    // custom private props\n    get queryUri() {\n        return this.descriptor.queryUri;\n    }\n    get liveQueryDescriptor() {\n        return this.descriptor;\n    }\n    // dummy stub from iface\n    onRemoved() {\n    }\n    getItems() {\n        const dataByKey = {};\n        this.cache.forEach((key, item) => {\n            dataByKey[key] = item.value;\n        });\n        return dataByKey;\n    }\n    /**\n     * @private\n     */\n    _update(message, isStrictlyOrdered) {\n        switch (message.type) {\n            case 'live_query_item_updated':\n                this.handleItemMutated(message.item_key, message.item_data, message.item_revision);\n                break;\n            case 'live_query_item_removed':\n                this.handleItemRemoved(message.item_key, message.item_revision);\n                break;\n            case 'live_query_updated':\n                this.handleBatchUpdate(message.items);\n                break;\n        }\n        if (isStrictlyOrdered) {\n            this._advanceLastEventId(message.last_event_id);\n        }\n    }\n    handleItemMutated(key, value, revision) {\n        if (this.shouldIgnoreEvent(key, revision)) {\n            logger_1.default.trace(`Item ${key} update skipped, revision: ${revision}`);\n        }\n        else {\n            const newItem = { key, value };\n            this.cache.store(key, newItem, revision);\n            this.broadcastEventToListeners('itemUpdated', newItem);\n        }\n    }\n    handleItemRemoved(key, revision) {\n        const force = (revision === null);\n        if (this.shouldIgnoreEvent(key, revision)) {\n            logger_1.default.trace(`Item ${key} delete skipped, revision: ${revision}`);\n        }\n        else {\n            this.cache.delete(key, revision, force);\n            this.broadcastEventToListeners('itemRemoved', { key });\n        }\n    }\n    handleBatchUpdate(items) {\n        // preprocess item set for easy key-based access (it's a one-time constant time operation)\n        let newItems = {};\n        if (items != null) {\n            items.forEach(item => {\n                newItems[item.key] = {\n                    data: item.data,\n                    revision: item.revision\n                };\n            });\n        }\n        // go through existing items and generate update/remove events for them\n        this.cache.forEach((key, item) => {\n            const newItem = newItems[key];\n            if (newItem != null) {\n                this.handleItemMutated(key, newItem.data, newItem.revision);\n            }\n            else {\n                this.handleItemRemoved(key, null); // force deletion w/o revision\n            }\n            // once item is handled, remove it from incoming array\n            delete newItems[key];\n        });\n        // once we handled all the known items, handle remaining pack\n        for (let key in newItems) {\n            this.handleItemMutated(key, newItems[key].data, newItems[key].revision);\n        }\n    }\n    shouldIgnoreEvent(key, eventId) {\n        return key != null && eventId != null && this.cache.isKnown(key, eventId);\n    }\n    /**\n     * @private\n     */\n    _advanceLastEventId(eventId, revision) {\n        // LiveQuery is not revisioned in any way, so simply ignore second param and act upon lastEventId only\n        if (this.lastEventId < eventId) {\n            this.descriptor.last_event_id = eventId;\n        }\n    }\n}\nexports.LiveQueryImpl = LiveQueryImpl;\nasync function queryItems(params) {\n    let { network, queryString, uri, type } = params;\n    if (queryString == null) { // should not be null or undefined\n        throw new syncerror_1.SyncError(`Invalid query`, 400, 54507);\n    }\n    const liveQueryRequestBody = {\n        query_string: queryString // raw query string (like `key == \"value\" AND key2 != \"value2\"`)\n    };\n    if (type === LiveQuery.type) {\n        liveQueryRequestBody.type = type;\n    }\n    let response = await network.post(uri, liveQueryRequestBody, undefined, true);\n    return response.body;\n}\nexports.queryItems = queryItems;\n/**\n * @class\n * @alias LiveQuery\n * @classdesc Represents a long-running query against Flex data wherein the returned result set\n *     subsequently receives pushed updates whenever new (or updated) records would match the\n *     given expression. Updated results are presented row-by-row until this query is explicitly\n *     closed.\n *\n *     Use the {@link Client#liveQuery} method to create a live query.\n *\n * @property {String} sid The immutable identifier of this query object, assigned by the system.\n *\n * @fires LiveQuery#itemUpdated\n * @fires LiveQuery#itemRemoved\n */\nclass LiveQuery extends closeable_1.Closeable {\n    /**\n     * @private\n     */\n    constructor(liveQueryImpl) {\n        super();\n        this.liveQueryImpl = liveQueryImpl;\n        this.liveQueryImpl.attach(this);\n    }\n    // private props\n    static get type() {\n        return LiveQueryImpl.type;\n    }\n    get type() {\n        return LiveQueryImpl.type;\n    }\n    get lastEventId() {\n        return this.liveQueryImpl.lastEventId;\n    }\n    // public\n    get sid() {\n        return this.liveQueryImpl.sid;\n    }\n    /**\n     * Closes this query instance and unsubscribes from further service events.\n     * This will eventually stop the physical inflow of updates over the network, when all other instances of this query are closed as well.\n     * @public\n     */\n    close() {\n        super.close();\n        this.liveQueryImpl.detach(this.listenerUuid);\n    }\n    /**\n     * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching the current query expression.\n     * @public\n     */\n    getItems() {\n        this.ensureNotClosed();\n        return this.liveQueryImpl.getItems();\n    }\n}\nexports.LiveQuery = LiveQuery;\n/**\n * @class\n * @alias InstantQuery\n * @classdesc Allows repetitive quick searches against a specific Flex data. Unlike a\n * LiveQuery, this result set does not subscribe to any updates and therefore receives no events\n * beyond the initial result set.\n *\n * Use the {@link Client#instantQuery} method to create an Instant Query.\n *\n * @fires InstantQuery#searchResult\n */\nclass InstantQuery extends events_1.EventEmitter {\n    /**\n     * @private\n     */\n    constructor(params) {\n        super();\n        this.queryExpression = null;\n        this.items = {};\n        Object.assign(this, params);\n        this.updateIndexName(params.indexName);\n    }\n    // private props\n    static get type() {\n        return 'instant_query';\n    }\n    get type() {\n        return InstantQuery.type;\n    }\n    /**\n     * Spawns a new search request. The result will be provided asynchronously via the {@link InstantQuery#event:searchResult}\n     * event.\n     * @param {String} queryExpression A query expression to be executed against the given data index. For more information\n     * on the syntax read {@link Client#liveQuery}.\n     * @returns {Promise<void>} A promise that resolves when query result has been received.\n     * @public\n     */\n    async search(queryExpression) {\n        this.items = {};\n        return queryItems({\n            network: this.network,\n            uri: this.queryUri,\n            queryString: queryExpression\n        })\n            .then(response => {\n            this.queryExpression = queryExpression;\n            if (response.items) {\n                response.items.forEach((item) => {\n                    this.items[item.key] = item.data;\n                });\n            }\n            this.emit('searchResult', this.getItems());\n        })\n            .catch(err => {\n            logger_1.default.error(`Error '${err.message}' while executing query '${queryExpression}'`);\n            this.queryExpression = null;\n            throw err;\n        });\n    }\n    /**\n     * Instantiates a LiveQuery object based on the last known query expression that was passed to the\n     * {@link InstantQuery#search} method. This LiveQuery will start receiving updates with new results,\n     * while current object can be still used to execute repetitive searches.\n     * @returns {Promise<LiveQuery>} A promise which resolves when the LiveQuery object is ready.\n     * @public\n     */\n    async subscribe() {\n        if (this.queryExpression == null) { // should not be null or undefined\n            return Promise.reject(new syncerror_1.SyncError(`Invalid query`, 400, 54507));\n        }\n        return this.liveQueryCreator(this.indexName, this.queryExpression);\n    }\n    /**\n     * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching current query expression.\n     * @public\n     */\n    getItems() {\n        return this.items;\n    }\n    /**\n     * Set new index name\n     * @param {String} indexName New index name to set\n     * @returns void\n     * @public\n     */\n    updateIndexName(indexName) {\n        if (!indexName || typeof indexName !== 'string') {\n            throw new Error('Index name must contain a non-empty string value');\n        }\n        this.indexName = indexName;\n        this.queryUri = this.generateQueryUri(this.indexName);\n    }\n    generateQueryUri(indexName) {\n        return new uri_1.UriBuilder(this.insightsUri)\n            .pathSegment(indexName)\n            .pathSegment('Items')\n            .build();\n    }\n}\nexports.InstantQuery = InstantQuery;\nexports.default = LiveQuery;\n/**\n * @class InsightsItem\n * @classdesc An individual result from a LiveQuery or InstantQuery result set.\n * @property {String} key The identifier that maps to this item within the search result.\n * @property {Object} value The contents of the item.\n */\n/**\n * A result set, i.e. a collection of items that matched a LiveQuery or InstantQuery expression. Each result is a\n * key-value pair, where each key identifies its object uniquely. These results are equivalent to a set of\n * {@link InsightsItem}-s.\n * @typedef {Object.<string, Object>} LiveQuery#ItemsSnapshot\n */\n/**\n * Fired when an item has been added or updated.\n * @event LiveQuery#itemUpdated\n * @param {InsightsItem} item Updated item.\n * @example\n * liveQuery.on('itemUpdated', function(item) {\n *   console.log('Item ' + item.key + ' was updated');\n *   console.log('Item value: ', item.value);\n * });\n */\n/**\n * Fired when an existing item has been removed.\n * @event LiveQuery#itemRemoved\n * @param {Object} args Arguments provided with the event.\n * @param {String} args.key The key of the removed item.\n * @example\n * liveQuery.on('itemRemoved', function(args) {\n *   console.log('Item ' + args.key + ' was removed');\n * });\n */\n/**\n * Fired when a search result is ready.\n * @event InstantQuery#searchResult\n * @param {LiveQuery#ItemsSnapshot} items A snapshot of items matching current query expression.\n * @example\n * instantQuery.on('searchResult', function(items) {\n *    Object.entries(items).forEach(([key, value]) => {\n *      console.log('Search result item key: ' + key);\n *      console.log('Search result item value: ' + value);\n *    });\n * });\n */\n"]},"metadata":{},"sourceType":"script"}