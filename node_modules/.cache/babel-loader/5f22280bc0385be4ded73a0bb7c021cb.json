{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class ConcatPackedProgram {\n  constructor(shapes, axis) {\n    this.packedInputs = true;\n    this.packedOutput = true;\n    this.outputShape = [];\n    this.outputShape = backend_util.computeOutShape(shapes, axis);\n    const shape = this.outputShape;\n    const rank = shape.length;\n    const dtype = getCoordsDataType(rank);\n    const coords = getChannels('coords', rank);\n    const channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank);\n    this.variableNames = shapes.map((_, i) => \"T\".concat(i));\n    const offsets = new Array(shapes.length - 1);\n    offsets[0] = shapes[0][axis];\n\n    for (let i = 1; i < offsets.length; i++) {\n      offsets[i] = offsets[i - 1] + shapes[i][axis];\n    }\n\n    const channel = channels[axis];\n    const lastChannels = channels.slice(-2);\n    const allChannels = channels.join();\n    let getValueSnippet = \"if (\".concat(channel, \" < \").concat(offsets[0], \") {\\n        return getChannel(\\n            getT0(\").concat(allChannels, \"), vec2(\").concat(lastChannels.join(), \"));\\n        }\");\n\n    for (let i = 1; i < offsets.length; i++) {\n      const shift = offsets[i - 1]; // Note: the >= comparison below may seem unnecessary given the check\n      // above but is needed to workaround branch execution issues on some\n      // devices. It makes all the conditions exclusive without relying on\n      // execution order.\n\n      getValueSnippet += \"\\n        if (\".concat(channel, \" < \").concat(offsets[i], \"  && \").concat(channel, \" >= \").concat(offsets[i - 1], \") {\\n          return getChannel(\\n            getT\").concat(i, \"(\").concat(shiftedChannels(channels, channel, shift), \"),\\n            vec2(\").concat(shiftedChannels(lastChannels, channel, shift), \"));\\n        }\");\n    }\n\n    const lastIndex = offsets.length;\n    const shift = offsets[offsets.length - 1];\n    getValueSnippet += \"\\n        return getChannel(\\n          getT\".concat(lastIndex, \"(\").concat(shiftedChannels(channels, channel, shift), \"),\\n          vec2(\").concat(shiftedChannels(lastChannels, channel, shift), \"));\");\n    this.userCode = \"\\n      float getValue(\".concat(channels.map(x => 'int ' + x), \") {\\n        \").concat(getValueSnippet, \"\\n      }\\n\\n      void main() {\\n        \").concat(dtype, \" coords = getOutputCoords();\\n        vec4 result = vec4(getValue(\").concat(coords, \"), 0., 0., 0.);\\n\\n        \").concat(coords[rank - 1], \" = \").concat(coords[rank - 1], \" + 1;\\n        if (\").concat(coords[rank - 1], \" < \").concat(shape[rank - 1], \") {\\n          result.g = getValue(\").concat(coords, \");\\n        }\\n\\n        \").concat(coords[rank - 2], \" = \").concat(coords[rank - 2], \" + 1;\\n        if (\").concat(coords[rank - 2], \" < \").concat(shape[rank - 2], \") {\\n          result.a = getValue(\").concat(coords, \");\\n        }\\n\\n        \").concat(coords[rank - 1], \" = \").concat(coords[rank - 1], \" - 1;\\n        if (\").concat(coords[rank - 2], \" < \").concat(shape[rank - 2], \" &&\\n            \").concat(coords[rank - 1], \" < \").concat(shape[rank - 1], \") {\\n          result.b = getValue(\").concat(coords, \");\\n        }\\n        setOutput(result);\\n      }\\n    \");\n  }\n\n}\n/**\n * Return an expression for coordinates into a vector where a given channel\n * will be offset by [shift].\n *\n * @param channels the channels to consider\n * @param channel the channel we want shifted\n * @param shift  the amount to subtract from the channel.\n *\n * @returns a string of the form 'x, y-[shift], z' where any one channel can\n * have the shift applied.\n */\n\nfunction shiftedChannels(channels, channel, shift) {\n  const channelIdx = channels.indexOf(channel);\n  const res = channels.map((c, idx) => {\n    if (idx === channelIdx) {\n      return \"\".concat(c, \" - \").concat(shift);\n    } else {\n      return c;\n    }\n  });\n  return res.join();\n}","map":{"version":3,"sources":["../src/concat_packed_gpu.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,YAAR,QAA2B,uBAA3B;AAGA,SAAQ,WAAR,QAA0B,gBAA1B;AACA,SAAQ,iBAAR,QAAgC,mBAAhC;AAEA,OAAM,MAAO,mBAAP,CAA0B;AAO9B,EAAA,WAAA,CAAY,MAAZ,EAAgC,IAAhC,EAA4C;AAL5C,SAAA,YAAA,GAAe,IAAf;AACA,SAAA,YAAA,GAAe,IAAf;AACA,SAAA,WAAA,GAAwB,EAAxB;AAIE,SAAK,WAAL,GAAmB,YAAY,CAAC,eAAb,CAA6B,MAA7B,EAAqC,IAArC,CAAnB;AACA,UAAM,KAAK,GAAG,KAAK,WAAnB;AACA,UAAM,IAAI,GAAG,KAAK,CAAC,MAAnB;AACA,UAAM,KAAK,GAAG,iBAAiB,CAAC,IAAD,CAA/B;AACA,UAAM,MAAM,GAAG,WAAW,CAAC,QAAD,EAAW,IAAX,CAA1B;AACA,UAAM,QAAQ,GAAG,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB,GAArB,EAA0B,GAA1B,EAA+B,KAA/B,CAAqC,CAArC,EAAwC,IAAxC,CAAjB;AACA,SAAK,aAAL,GAAqB,MAAM,CAAC,GAAP,CAAW,CAAC,CAAD,EAAI,CAAJ,gBAAc,CAAd,CAAX,CAArB;AAEA,UAAM,OAAO,GAAa,IAAI,KAAJ,CAAU,MAAM,CAAC,MAAP,GAAgB,CAA1B,CAA1B;AACA,IAAA,OAAO,CAAC,CAAD,CAAP,GAAa,MAAM,CAAC,CAAD,CAAN,CAAU,IAAV,CAAb;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,OAAO,CAAC,MAA5B,EAAoC,CAAC,EAArC,EAAyC;AACvC,MAAA,OAAO,CAAC,CAAD,CAAP,GAAa,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,MAAM,CAAC,CAAD,CAAN,CAAU,IAAV,CAA9B;AACD;;AAED,UAAM,OAAO,GAAG,QAAQ,CAAC,IAAD,CAAxB;AACA,UAAM,YAAY,GAAG,QAAQ,CAAC,KAAT,CAAe,CAAC,CAAhB,CAArB;AACA,UAAM,WAAW,GAAG,QAAQ,CAAC,IAAT,EAApB;AAEA,QAAI,eAAe,iBAAU,OAAV,gBAAuB,OAAO,CAAC,CAAD,CAA9B,gEAEH,WAFG,qBAEmB,YAAY,CAAC,IAAb,EAFnB,mBAAnB;;AAIA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,OAAO,CAAC,MAA5B,EAAoC,CAAC,EAArC,EAAyC;AACvC,YAAM,KAAK,GAAG,OAAO,CAAC,CAAC,GAAG,CAAL,CAArB,CADuC,CAEvC;AACA;AACA;AACA;;AACA,MAAA,eAAe,4BACP,OADO,gBACM,OAAO,CAAC,CAAD,CADb,kBACwB,OADxB,iBACsC,OAAO,CAAC,CAAC,GAAG,CAAL,CAD7C,gEAGH,CAHG,cAGE,eAAe,CAAC,QAAD,EAAW,OAAX,EAAoB,KAApB,CAHjB,kCAIF,eAAe,CAAC,YAAD,EAAe,OAAf,EAAwB,KAAxB,CAJb,mBAAf;AAMD;;AACD,UAAM,SAAS,GAAG,OAAO,CAAC,MAA1B;AACA,UAAM,KAAK,GAAG,OAAO,CAAC,OAAO,CAAC,MAAR,GAAiB,CAAlB,CAArB;AACA,IAAA,eAAe,0DAEH,SAFG,cAEU,eAAe,CAAC,QAAD,EAAW,OAAX,EAAoB,KAApB,CAFzB,gCAGF,eAAe,CAAC,YAAD,EAAe,OAAf,EAAwB,KAAxB,CAHb,QAAf;AAKA,SAAK,QAAL,oCACmB,QAAQ,CAAC,GAAT,CAAa,CAAC,IAAI,SAAS,CAA3B,CADnB,0BAEM,eAFN,uDAMM,KANN,+EAOkC,MAPlC,wCASM,MAAM,CAAC,IAAI,GAAG,CAAR,CATZ,gBAS4B,MAAM,CAAC,IAAI,GAAG,CAAR,CATlC,gCAUU,MAAM,CAAC,IAAI,GAAG,CAAR,CAVhB,gBAUgC,KAAK,CAAC,IAAI,GAAG,CAAR,CAVrC,gDAW4B,MAX5B,sCAcM,MAAM,CAAC,IAAI,GAAG,CAAR,CAdZ,gBAc4B,MAAM,CAAC,IAAI,GAAG,CAAR,CAdlC,gCAeU,MAAM,CAAC,IAAI,GAAG,CAAR,CAfhB,gBAegC,KAAK,CAAC,IAAI,GAAG,CAAR,CAfrC,gDAgB4B,MAhB5B,sCAmBM,MAAM,CAAC,IAAI,GAAG,CAAR,CAnBZ,gBAmB4B,MAAM,CAAC,IAAI,GAAG,CAAR,CAnBlC,gCAoBU,MAAM,CAAC,IAAI,GAAG,CAAR,CApBhB,gBAoBgC,KAAK,CAAC,IAAI,GAAG,CAAR,CApBrC,8BAqBU,MAAM,CAAC,IAAI,GAAG,CAAR,CArBhB,gBAqBgC,KAAK,CAAC,IAAI,GAAG,CAAR,CArBrC,gDAsB4B,MAtB5B;AA2BD;;AA7E6B;AAgFhC;;;;;;;;;;AAUG;;AACH,SAAS,eAAT,CAAyB,QAAzB,EAA6C,OAA7C,EAA8D,KAA9D,EAA2E;AACzE,QAAM,UAAU,GAAG,QAAQ,CAAC,OAAT,CAAiB,OAAjB,CAAnB;AACA,QAAM,GAAG,GAAG,QAAQ,CAAC,GAAT,CAAa,CAAC,CAAD,EAAI,GAAJ,KAAW;AAClC,QAAI,GAAG,KAAK,UAAZ,EAAwB;AACtB,uBAAU,CAAV,gBAAiB,KAAjB;AACD,KAFD,MAEO;AACL,aAAO,CAAP;AACD;AACF,GANW,CAAZ;AAOA,SAAO,GAAG,CAAC,IAAJ,EAAP;AACD","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class ConcatPackedProgram implements GPGPUProgram {\n  variableNames: string[];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(shapes: number[][], axis: number) {\n    this.outputShape = backend_util.computeOutShape(shapes, axis);\n    const shape = this.outputShape;\n    const rank = shape.length;\n    const dtype = getCoordsDataType(rank);\n    const coords = getChannels('coords', rank);\n    const channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank);\n    this.variableNames = shapes.map((_, i) => `T${i}`);\n\n    const offsets: number[] = new Array(shapes.length - 1);\n    offsets[0] = shapes[0][axis];\n    for (let i = 1; i < offsets.length; i++) {\n      offsets[i] = offsets[i - 1] + shapes[i][axis];\n    }\n\n    const channel = channels[axis];\n    const lastChannels = channels.slice(-2);\n    const allChannels = channels.join();\n\n    let getValueSnippet = `if (${channel} < ${offsets[0]}) {\n        return getChannel(\n            getT0(${allChannels}), vec2(${lastChannels.join()}));\n        }`;\n    for (let i = 1; i < offsets.length; i++) {\n      const shift = offsets[i - 1];\n      // Note: the >= comparison below may seem unnecessary given the check\n      // above but is needed to workaround branch execution issues on some\n      // devices. It makes all the conditions exclusive without relying on\n      // execution order.\n      getValueSnippet += `\n        if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {\n          return getChannel(\n            getT${i}(${shiftedChannels(channels, channel, shift)}),\n            vec2(${shiftedChannels(lastChannels, channel, shift)}));\n        }`;\n    }\n    const lastIndex = offsets.length;\n    const shift = offsets[offsets.length - 1];\n    getValueSnippet += `\n        return getChannel(\n          getT${lastIndex}(${shiftedChannels(channels, channel, shift)}),\n          vec2(${shiftedChannels(lastChannels, channel, shift)}));`;\n\n    this.userCode = `\n      float getValue(${channels.map(x => 'int ' + x)}) {\n        ${getValueSnippet}\n      }\n\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${coords}), 0., 0., 0.);\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} + 1;\n        if (${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.g = getValue(${coords});\n        }\n\n        ${coords[rank - 2]} = ${coords[rank - 2]} + 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]}) {\n          result.a = getValue(${coords});\n        }\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} - 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]} &&\n            ${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.b = getValue(${coords});\n        }\n        setOutput(result);\n      }\n    `;\n  }\n}\n\n/**\n * Return an expression for coordinates into a vector where a given channel\n * will be offset by [shift].\n *\n * @param channels the channels to consider\n * @param channel the channel we want shifted\n * @param shift  the amount to subtract from the channel.\n *\n * @returns a string of the form 'x, y-[shift], z' where any one channel can\n * have the shift applied.\n */\nfunction shiftedChannels(channels: string[], channel: string, shift: number) {\n  const channelIdx = channels.indexOf(channel);\n  const res = channels.map((c, idx) => {\n    if (idx === channelIdx) {\n      return `${c} - ${shift}`;\n    } else {\n      return c;\n    }\n  });\n  return res.join();\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}