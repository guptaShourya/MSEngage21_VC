{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/shouryagupta/Desktop/MS Engage 21/MSEngage21_VC/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\n\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Einsum, util } from '@tensorflow/tfjs-core';\nimport { multiply } from './Multiply';\nimport { reshape } from './Reshape';\nimport { sum } from './Sum';\nimport { transpose } from './Transpose';\nexport function einsum(args) {\n  const inputs = args.inputs,\n        backend = args.backend,\n        attrs = args.attrs;\n  const equation = attrs.equation;\n  const tensors = inputs;\n\n  const _backend_util$decodeE = backend_util.decodeEinsumEquation(equation, tensors.length),\n        allDims = _backend_util$decodeE.allDims,\n        summedDims = _backend_util$decodeE.summedDims,\n        idDims = _backend_util$decodeE.idDims;\n\n  backend_util.checkEinsumDimSizes(allDims.length, idDims, tensors);\n\n  const _backend_util$getEins = backend_util.getEinsumComputePath(summedDims, idDims),\n        path = _backend_util$getEins.path,\n        steps = _backend_util$getEins.steps;\n\n  const nSteps = steps.length;\n  let out = null;\n  let numDimsRemaining = allDims.length;\n  const tensorsToDispose = [];\n\n  for (let i = 0; i < nSteps; ++i) {\n    var _iterator = _createForOfIteratorHelper(steps[i]),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        const idTerm = _step.value;\n\n        const _backend_util$getEins2 = backend_util.getEinsumPermutation(numDimsRemaining, idDims[idTerm]),\n              perm = _backend_util$getEins2.permutationIndices,\n              dimsToExpand = _backend_util$getEins2.expandDims;\n\n        let x;\n\n        if (backend_util.isIdentityPermutation(perm)) {\n          x = tensors[idTerm];\n        } else {\n          x = transpose({\n            inputs: {\n              x: tensors[idTerm]\n            },\n            backend,\n            attrs: {\n              perm\n            }\n          });\n          tensorsToDispose.push(x);\n        }\n\n        const targetShape = x.shape.slice();\n\n        for (let k = 0; k < dimsToExpand.length; ++k) {\n          targetShape.splice(dimsToExpand[k], 0, 1);\n        }\n\n        if (!util.arraysEqual(x.shape, targetShape)) {\n          x = reshape({\n            inputs: {\n              x\n            },\n            backend,\n            attrs: {\n              shape: targetShape\n            }\n          });\n          tensorsToDispose.push(x);\n        }\n\n        if (out === null) {\n          out = x;\n        } else {\n          // tslint:disable-next-line: no-unnecessary-type-assertion\n          out = multiply({\n            inputs: {\n              a: x,\n              b: out\n            },\n            backend\n          });\n          tensorsToDispose.push(out);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    if (i < nSteps - 1) {\n      if (path[i] >= 0) {\n        out = sum({\n          inputs: {\n            x: out\n          },\n          backend,\n          attrs: {\n            axis: path[i] - (allDims.length - numDimsRemaining),\n            keepDims: false\n          }\n        });\n        tensorsToDispose.push(out);\n      }\n\n      numDimsRemaining--;\n    }\n  } // Clean up intermediate tensors.\n\n\n  for (var _i = 0, _tensorsToDispose = tensorsToDispose; _i < _tensorsToDispose.length; _i++) {\n    const tensorInfo = _tensorsToDispose[_i];\n\n    if (tensorInfo === out) {\n      continue;\n    }\n\n    backend.disposeIntermediateTensorInfo(tensorInfo);\n  }\n\n  return out;\n}\nexport const einsumConfig = {\n  kernelName: Einsum,\n  backendName: 'cpu',\n  kernelFunc: einsum\n};","map":{"version":3,"sources":["../../src/kernels/Einsum.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Einsum, EinsumAttrs, EinsumInputs, KernelConfig, KernelFunc, Tensor, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\n\nimport {multiply} from './Multiply';\nimport {reshape} from './Reshape';\nimport {sum} from './Sum';\nimport {transpose} from './Transpose';\n\nexport function einsum(\n    args: {inputs: EinsumInputs, backend: MathBackendCPU, attrs: EinsumAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {equation} = attrs;\n  const tensors = inputs as Tensor[];\n\n  const {allDims, summedDims, idDims} =\n      backend_util.decodeEinsumEquation(equation, tensors.length);\n  backend_util.checkEinsumDimSizes(allDims.length, idDims, tensors);\n  const {path, steps} = backend_util.getEinsumComputePath(summedDims, idDims);\n\n  const nSteps = steps.length;\n  let out: TensorInfo|null = null;\n  let numDimsRemaining = allDims.length;\n  const tensorsToDispose: TensorInfo[] = [];\n  for (let i = 0; i < nSteps; ++i) {\n    for (const idTerm of steps[i]) {\n      const {permutationIndices: perm, expandDims: dimsToExpand} =\n          backend_util.getEinsumPermutation(numDimsRemaining, idDims[idTerm]);\n      let x: TensorInfo;\n      if (backend_util.isIdentityPermutation(perm)) {\n        x = tensors[idTerm];\n      } else {\n        x = transpose({inputs: {x: tensors[idTerm]}, backend, attrs: {perm}});\n        tensorsToDispose.push(x);\n      }\n      const targetShape: number[] = x.shape.slice();\n      for (let k = 0; k < dimsToExpand.length; ++k) {\n        targetShape.splice(dimsToExpand[k], 0, 1);\n      }\n\n      if (!util.arraysEqual(x.shape, targetShape)) {\n        x = reshape({inputs: {x}, backend, attrs: {shape: targetShape}});\n        tensorsToDispose.push(x);\n      }\n      if (out === null) {\n        out = x;\n      } else {\n        // tslint:disable-next-line: no-unnecessary-type-assertion\n        out = multiply({inputs: {a: x, b: out}, backend}) as TensorInfo;\n        tensorsToDispose.push(out);\n      }\n    }\n    if (i < nSteps - 1) {\n      if (path[i] >= 0) {\n        out = sum({\n          inputs: {x: out},\n          backend,\n          attrs: {\n            axis: path[i] - (allDims.length - numDimsRemaining),\n            keepDims: false\n          }\n        });\n        tensorsToDispose.push(out);\n      }\n      numDimsRemaining--;\n    }\n  }\n\n  // Clean up intermediate tensors.\n  for (const tensorInfo of tensorsToDispose) {\n    if (tensorInfo === out) {\n      continue;\n    }\n    backend.disposeIntermediateTensorInfo(tensorInfo);\n  }\n\n  return out;\n}\n\nexport const einsumConfig: KernelConfig = {\n  kernelName: Einsum,\n  backendName: 'cpu',\n  kernelFunc: einsum as {} as KernelFunc\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}