{"ast":null,"code":"import _regeneratorRuntime from \"/Users/shouryagupta/Desktop/MS Engage 21/MSEngage21_VC/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/shouryagupta/Desktop/MS Engage 21/MSEngage21_VC/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { convertToTensor } from '../tensor_util_env';\nimport { assert, assertShapesMatch, getTypedArrayFromDType } from '../util';\nimport { tensor } from './tensor';\n/**\n * Returns whether the targets are in the top K predictions.\n *\n * ```js\n * const predictions = tf.tensor2d([[20, 10, 40, 30], [30, 50, -20, 10]]);\n * const targets = tf.tensor1d([2, 0]);\n * const precision = await tf.inTopKAsync(predictions, targets);\n * precision.print();\n * ```\n * @param predictions 2-D or higher `tf.Tensor` with last dimension being\n *     at least `k`.\n * @param targets 1-D or higher `tf.Tensor`.\n * @param k Optional Number of top elements to look at for computing precision,\n *     default to 1.\n *\n * @doc {heading: 'Operations', subheading: 'Evaluation'}\n */\n\nfunction inTopKAsync_(_x, _x2) {\n  return _inTopKAsync_.apply(this, arguments);\n}\n\nfunction _inTopKAsync_() {\n  _inTopKAsync_ = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(predictions, targets, k = 1) {\n    var $predictions, $targets, lastDim, predictionsVals, targetsVals, batch, size, precision, b, offset, vals, valAndInd, i;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          $predictions = convertToTensor(predictions, 'predictions', 'inTopK');\n          $targets = convertToTensor(targets, 'targets', 'inTopK');\n          assert($predictions.rank > 1, () => 'inTopK() expects the predictions to be of rank 2 or higher, ' + \"but got \".concat($predictions.rank));\n          assert($predictions.rank - 1 === $targets.rank, () => \"predictions rank should be 1 larger than \" + \"targets rank, but got predictions rank \" + \"\".concat($predictions.rank, \" and targets rank \").concat($targets.rank));\n          assertShapesMatch($predictions.shape.slice(0, $predictions.shape.length - 1), $targets.shape, \"predictions's shape should be align with the targets' shape, \" + 'except the last dimension.');\n          lastDim = $predictions.shape[$predictions.shape.length - 1];\n          assert(k > 0 && k <= lastDim, () => \"'k' passed to inTopK() must be > 0 && <= the predictions last \" + \"dimension (\".concat(lastDim, \"), but got \").concat(k));\n          _context.next = 9;\n          return $predictions.data();\n\n        case 9:\n          predictionsVals = _context.sent;\n          _context.next = 12;\n          return $targets.data();\n\n        case 12:\n          targetsVals = _context.sent;\n          // Reshape predictionsVals into a 2d tensor [batch, lastDim]\n          // and look up topK along lastDim.\n          batch = predictionsVals.length / lastDim, size = lastDim;\n          precision = getTypedArrayFromDType('bool', batch);\n          b = 0;\n\n        case 16:\n          if (!(b < batch)) {\n            _context.next = 34;\n            break;\n          }\n\n          offset = b * size;\n          vals = predictionsVals.subarray(offset, offset + size);\n          valAndInd = [];\n\n          for (i = 0; i < vals.length; i++) {\n            valAndInd.push({\n              value: vals[i],\n              index: i\n            });\n          }\n\n          valAndInd.sort((a, b) => b.value - a.value);\n          precision[b] = 0;\n          i = 0;\n\n        case 24:\n          if (!(i < k)) {\n            _context.next = 31;\n            break;\n          }\n\n          if (!(valAndInd[i].index === targetsVals[b])) {\n            _context.next = 28;\n            break;\n          }\n\n          precision[b] = 1;\n          return _context.abrupt(\"break\", 31);\n\n        case 28:\n          i++;\n          _context.next = 24;\n          break;\n\n        case 31:\n          b++;\n          _context.next = 16;\n          break;\n\n        case 34:\n          if (predictions !== $predictions) {\n            $predictions.dispose();\n          }\n\n          if (targets !== $targets) {\n            $targets.dispose();\n          } // Output precision has the same shape as targets.\n\n\n          return _context.abrupt(\"return\", tensor(precision, $targets.shape, 'bool'));\n\n        case 37:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _inTopKAsync_.apply(this, arguments);\n}\n\nexport const inTopKAsync = inTopKAsync_;","map":{"version":3,"sources":["../../src/ops/in_top_k.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {assert, assertShapesMatch, getTypedArrayFromDType} from '../util';\nimport {tensor} from './tensor';\n\n/**\n * Returns whether the targets are in the top K predictions.\n *\n * ```js\n * const predictions = tf.tensor2d([[20, 10, 40, 30], [30, 50, -20, 10]]);\n * const targets = tf.tensor1d([2, 0]);\n * const precision = await tf.inTopKAsync(predictions, targets);\n * precision.print();\n * ```\n * @param predictions 2-D or higher `tf.Tensor` with last dimension being\n *     at least `k`.\n * @param targets 1-D or higher `tf.Tensor`.\n * @param k Optional Number of top elements to look at for computing precision,\n *     default to 1.\n *\n * @doc {heading: 'Operations', subheading: 'Evaluation'}\n */\nasync function inTopKAsync_<T extends Tensor, U extends Tensor>(\n    predictions: T|TensorLike, targets: U|TensorLike, k = 1): Promise<U> {\n  const $predictions = convertToTensor(predictions, 'predictions', 'inTopK');\n  const $targets = convertToTensor(targets, 'targets', 'inTopK');\n\n  assert(\n      $predictions.rank > 1,\n      () => 'inTopK() expects the predictions to be of rank 2 or higher, ' +\n          `but got ${$predictions.rank}`);\n  assert(\n      $predictions.rank - 1 === $targets.rank,\n      () => `predictions rank should be 1 larger than ` +\n          `targets rank, but got predictions rank ` +\n          `${$predictions.rank} and targets rank ${$targets.rank}`);\n  assertShapesMatch(\n      $predictions.shape.slice(0, $predictions.shape.length - 1),\n      $targets.shape,\n      `predictions's shape should be align with the targets' shape, ` +\n          'except the last dimension.');\n  const lastDim = $predictions.shape[$predictions.shape.length - 1];\n  assert(\n      k > 0 && k <= lastDim,\n      () => `'k' passed to inTopK() must be > 0 && <= the predictions last ` +\n          `dimension (${lastDim}), but got ${k}`);\n\n  const predictionsVals = await $predictions.data();\n  const targetsVals = await $targets.data();\n\n  // Reshape predictionsVals into a 2d tensor [batch, lastDim]\n  // and look up topK along lastDim.\n  const [batch, size] = [predictionsVals.length / lastDim, lastDim];\n  const precision = getTypedArrayFromDType('bool', batch);\n\n  for (let b = 0; b < batch; b++) {\n    const offset = b * size;\n    const vals = predictionsVals.subarray(offset, offset + size);\n    const valAndInd: Array<{value: number, index: number}> = [];\n    for (let i = 0; i < vals.length; i++) {\n      valAndInd.push({value: vals[i], index: i});\n    }\n    valAndInd.sort((a, b) => b.value - a.value);\n\n    precision[b] = 0;\n    for (let i = 0; i < k; i++) {\n      if (valAndInd[i].index === targetsVals[b]) {\n        precision[b] = 1;\n        break;\n      }\n    }\n  }\n\n  if (predictions !== $predictions) {\n    $predictions.dispose();\n  }\n  if (targets !== $targets) {\n    $targets.dispose();\n  }\n\n  // Output precision has the same shape as targets.\n  return tensor(precision, $targets.shape, 'bool') as U;\n}\n\nexport const inTopKAsync = inTopKAsync_;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}