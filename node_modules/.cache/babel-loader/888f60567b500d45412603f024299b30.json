{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VirtualBackgroundProcessor = void 0;\n\nvar BackgroundProcessor_1 = require(\"./BackgroundProcessor\");\n\nvar types_1 = require(\"../../types\");\n/**\n * The VirtualBackgroundProcessor, when added to a VideoTrack,\n * replaces the background in each video frame with a given image,\n * and leaves the foreground (person(s)) untouched. Each instance of\n * VirtualBackgroundProcessor should be added to only one VideoTrack\n * at a time to prevent overlapping of image data from multiple VideoTracks.\n *\n * @example\n *\n * ```ts\n * import { createLocalVideoTrack } from 'twilio-video';\n * import { VirtualBackgroundProcessor } from '@twilio/video-processors';\n *\n * let virtualBackground;\n * const img = new Image();\n *\n * img.onload = () => {\n *   virtualBackground = new VirtualBackgroundProcessor({\n *     assetsPath: 'https://my-server-path/assets',\n *     backgroundImage: img,\n *   });\n *\n *   virtualBackground.loadModel().then(() => {\n *     createLocalVideoTrack({\n *       width: 640,\n *       height: 480,\n *       frameRate: 24\n *     }).then(track => {\n *       track.addProcessor(virtualBackground);\n *     });\n *   });\n * };\n * img.src = '/background.jpg';\n * ```\n */\n\n\nvar VirtualBackgroundProcessor =\n/** @class */\nfunction (_super) {\n  __extends(VirtualBackgroundProcessor, _super);\n  /**\n   * Construct a VirtualBackgroundProcessor. Default values will be used for\n   * any missing optional properties in [[VirtualBackgroundProcessorOptions]],\n   * and invalid properties will be ignored.\n   */\n\n\n  function VirtualBackgroundProcessor(options) {\n    var _this = _super.call(this, options) || this; // tslint:disable-next-line no-unused-variable\n\n\n    _this._name = 'VirtualBackgroundProcessor';\n    _this.backgroundImage = options.backgroundImage;\n    _this.fitType = options.fitType;\n    return _this;\n  }\n\n  Object.defineProperty(VirtualBackgroundProcessor.prototype, \"backgroundImage\", {\n    /**\n     * The HTMLImageElement representing the current background image.\n     */\n    get: function get() {\n      return this._backgroundImage;\n    },\n\n    /**\n     * Set an HTMLImageElement as the new background image.\n     * An error will be raised if the image hasn't been fully loaded yet. Additionally, the image must follow\n     * [security guidelines](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image)\n     * when loading the image from a different origin. Failing to do so will result to an empty output frame.\n     */\n    set: function set(image) {\n      if (!image || !image.complete || !image.naturalHeight) {\n        throw new Error('Invalid image. Make sure that the image is an HTMLImageElement and has been successfully loaded');\n      }\n\n      this._backgroundImage = image;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(VirtualBackgroundProcessor.prototype, \"fitType\", {\n    /**\n     * The current [[ImageFit]] for positioning of the background image in the viewport.\n     */\n    get: function get() {\n      return this._fitType;\n    },\n\n    /**\n     * Set a new [[ImageFit]] to be used for positioning the background image in the viewport.\n     */\n    set: function set(fitType) {\n      var validTypes = Object.keys(types_1.ImageFit);\n\n      if (!validTypes.includes(fitType)) {\n        console.warn(\"Valid fitType not found. Using '\" + types_1.ImageFit.Fill + \"' as default.\");\n        fitType = types_1.ImageFit.Fill;\n      }\n\n      this._fitType = fitType;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  VirtualBackgroundProcessor.prototype._setBackground = function () {\n    var img = this._backgroundImage;\n    var imageWidth = img.naturalWidth;\n    var imageHeight = img.naturalHeight;\n    var canvasWidth = this._outputCanvas.width;\n    var canvasHeight = this._outputCanvas.height;\n\n    if (this._fitType === types_1.ImageFit.Fill) {\n      this._outputContext.drawImage(img, 0, 0, imageWidth, imageHeight, 0, 0, canvasWidth, canvasHeight);\n    } else if (this._fitType === types_1.ImageFit.None) {\n      this._outputContext.drawImage(img, 0, 0, imageWidth, imageHeight);\n    } else if (this._fitType === types_1.ImageFit.Contain) {\n      var _a = this._getFitPosition(imageWidth, imageHeight, canvasWidth, canvasHeight, types_1.ImageFit.Contain),\n          x = _a.x,\n          y = _a.y,\n          w = _a.w,\n          h = _a.h;\n\n      this._outputContext.drawImage(img, 0, 0, imageWidth, imageHeight, x, y, w, h);\n    } else if (this._fitType === types_1.ImageFit.Cover) {\n      var _b = this._getFitPosition(imageWidth, imageHeight, canvasWidth, canvasHeight, types_1.ImageFit.Cover),\n          x = _b.x,\n          y = _b.y,\n          w = _b.w,\n          h = _b.h;\n\n      this._outputContext.drawImage(img, 0, 0, imageWidth, imageHeight, x, y, w, h);\n    }\n  };\n\n  VirtualBackgroundProcessor.prototype._getFitPosition = function (contentWidth, contentHeight, viewportWidth, viewportHeight, type) {\n    // Calculate new content width to fit viewport width\n    var factor = viewportWidth / contentWidth;\n    var newContentWidth = viewportWidth;\n    var newContentHeight = factor * contentHeight; // Scale down the resulting height and width more\n    // to fit viewport height if the content still exceeds it\n\n    if (type === types_1.ImageFit.Contain && newContentHeight > viewportHeight || type === types_1.ImageFit.Cover && viewportHeight > newContentHeight) {\n      factor = viewportHeight / newContentHeight;\n      newContentWidth = factor * newContentWidth;\n      newContentHeight = viewportHeight;\n    } // Calculate the destination top left corner to center the content\n\n\n    var x = (viewportWidth - newContentWidth) / 2;\n    var y = (viewportHeight - newContentHeight) / 2;\n    return {\n      x: x,\n      y: y,\n      w: newContentWidth,\n      h: newContentHeight\n    };\n  };\n\n  return VirtualBackgroundProcessor;\n}(BackgroundProcessor_1.BackgroundProcessor);\n\nexports.VirtualBackgroundProcessor = VirtualBackgroundProcessor;","map":{"version":3,"sources":["../../../lib/processors/background/VirtualBackgroundProcessor.ts"],"names":[],"mappings":"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","sourcesContent":["import { BackgroundProcessor, BackgroundProcessorOptions } from './BackgroundProcessor';\nimport { ImageFit } from '../../types';\n\n/**\n * Options passed to [[VirtualBackgroundProcessor]] constructor.\n */\nexport interface VirtualBackgroundProcessorOptions extends BackgroundProcessorOptions {\n  /**\n   * The HTMLImageElement to use for background replacement.\n   * An error will be raised if the image hasn't been fully loaded yet. Additionally, the image must follow\n   * [security guidelines](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image)\n   * when loading the image from a different origin. Failing to do so will result to an empty output frame.\n   */\n  backgroundImage: HTMLImageElement;\n\n  /**\n   * The [[ImageFit]] to use for positioning of the background image in the viewport.\n   * @default\n   * ```html\n   * 'Fill'\n   * ```\n   */\n  fitType?: ImageFit;\n}\n\n/**\n * The VirtualBackgroundProcessor, when added to a VideoTrack,\n * replaces the background in each video frame with a given image,\n * and leaves the foreground (person(s)) untouched. Each instance of\n * VirtualBackgroundProcessor should be added to only one VideoTrack\n * at a time to prevent overlapping of image data from multiple VideoTracks.\n *\n * @example\n *\n * ```ts\n * import { createLocalVideoTrack } from 'twilio-video';\n * import { VirtualBackgroundProcessor } from '@twilio/video-processors';\n *\n * let virtualBackground;\n * const img = new Image();\n *\n * img.onload = () => {\n *   virtualBackground = new VirtualBackgroundProcessor({\n *     assetsPath: 'https://my-server-path/assets',\n *     backgroundImage: img,\n *   });\n *\n *   virtualBackground.loadModel().then(() => {\n *     createLocalVideoTrack({\n *       width: 640,\n *       height: 480,\n *       frameRate: 24\n *     }).then(track => {\n *       track.addProcessor(virtualBackground);\n *     });\n *   });\n * };\n * img.src = '/background.jpg';\n * ```\n */\nexport class VirtualBackgroundProcessor extends BackgroundProcessor {\n\n  private _backgroundImage!: HTMLImageElement;\n  private _fitType!: ImageFit;\n  // tslint:disable-next-line no-unused-variable\n  private readonly _name: string = 'VirtualBackgroundProcessor';\n\n  /**\n   * Construct a VirtualBackgroundProcessor. Default values will be used for\n   * any missing optional properties in [[VirtualBackgroundProcessorOptions]],\n   * and invalid properties will be ignored.\n   */\n  constructor(options: VirtualBackgroundProcessorOptions) {\n    super(options);\n    this.backgroundImage = options.backgroundImage;\n    this.fitType = options.fitType!;\n  }\n\n  /**\n   * The HTMLImageElement representing the current background image.\n   */\n  get backgroundImage(): HTMLImageElement {\n    return this._backgroundImage;\n  }\n\n  /**\n   * Set an HTMLImageElement as the new background image.\n   * An error will be raised if the image hasn't been fully loaded yet. Additionally, the image must follow\n   * [security guidelines](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image)\n   * when loading the image from a different origin. Failing to do so will result to an empty output frame.\n   */\n  set backgroundImage(image: HTMLImageElement) {\n    if (!image || !image.complete || !image.naturalHeight) {\n      throw new Error('Invalid image. Make sure that the image is an HTMLImageElement and has been successfully loaded');\n    }\n    this._backgroundImage = image;\n  }\n\n  /**\n   * The current [[ImageFit]] for positioning of the background image in the viewport.\n   */\n  get fitType(): ImageFit {\n    return this._fitType;\n  }\n\n  /**\n   * Set a new [[ImageFit]] to be used for positioning the background image in the viewport.\n   */\n  set fitType(fitType: ImageFit) {\n    const validTypes = Object.keys(ImageFit);\n    if (!validTypes.includes(fitType as any)) {\n      console.warn(`Valid fitType not found. Using '${ImageFit.Fill}' as default.`);\n      fitType = ImageFit.Fill;\n    }\n    this._fitType = fitType;\n  }\n\n  protected _setBackground(): void {\n    const img = this._backgroundImage;\n    const imageWidth = img.naturalWidth;\n    const imageHeight = img.naturalHeight;\n    const canvasWidth = this._outputCanvas.width;\n    const canvasHeight = this._outputCanvas.height;\n\n    if (this._fitType === ImageFit.Fill) {\n      this._outputContext.drawImage(img, 0, 0, imageWidth, imageHeight, 0, 0, canvasWidth, canvasHeight);\n    } else if (this._fitType === ImageFit.None) {\n      this._outputContext.drawImage(img, 0, 0, imageWidth, imageHeight);\n    } else if (this._fitType === ImageFit.Contain) {\n      const { x, y, w, h } = this._getFitPosition(imageWidth, imageHeight, canvasWidth, canvasHeight, ImageFit.Contain);\n      this._outputContext.drawImage(img, 0, 0, imageWidth, imageHeight, x, y, w, h);\n    } else if (this._fitType === ImageFit.Cover) {\n      const { x, y, w, h } = this._getFitPosition(imageWidth, imageHeight, canvasWidth, canvasHeight, ImageFit.Cover);\n      this._outputContext.drawImage(img, 0, 0, imageWidth, imageHeight, x, y, w, h);\n    }\n  }\n\n  private _getFitPosition(contentWidth: number, contentHeight: number,\n    viewportWidth: number, viewportHeight: number, type: ImageFit)\n      : { h: number, w: number, x: number, y: number } {\n\n    // Calculate new content width to fit viewport width\n    let factor = viewportWidth / contentWidth;\n    let newContentWidth = viewportWidth;\n    let newContentHeight = factor * contentHeight;\n\n    // Scale down the resulting height and width more\n    // to fit viewport height if the content still exceeds it\n    if ((type === ImageFit.Contain && newContentHeight > viewportHeight)\n      || (type === ImageFit.Cover && viewportHeight > newContentHeight)) {\n      factor = viewportHeight / newContentHeight;\n      newContentWidth = factor * newContentWidth;\n      newContentHeight = viewportHeight;\n    }\n\n    // Calculate the destination top left corner to center the content\n    const x = (viewportWidth - newContentWidth) / 2;\n    const y = (viewportHeight - newContentHeight) / 2;\n\n    return {\n      x, y,\n      w: newContentWidth,\n      h: newContentHeight,\n    };\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}