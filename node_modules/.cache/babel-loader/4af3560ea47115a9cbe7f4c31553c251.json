{"ast":null,"code":"import _regeneratorRuntime from \"/Users/shouryagupta/Desktop/MS Engage 21/MSEngage21_VC/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/shouryagupta/Desktop/MS Engage 21/MSEngage21_VC/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { scalar } from '@tensorflow/tfjs-core';\nimport { TensorArray } from '../../executor/tensor_array';\nimport { fromTensor, reserve, scatter, split } from '../../executor/tensor_list';\nimport { cloneTensor, getParamValue, getTensor } from './utils';\nexport const executeOp = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(node, tensorMap, context) {\n    var thenFunc, elseFunc, cond, args, condValue, bodyFunc, condFunc, condResult, argIds, result, origResult, resultIds, pred, data, inputName, frameId, size, dtype, elementShape, dynamicSize, clearAfterRead, identicalElementShapes, name, tensorArray, id, index, writeTensor, writeTensorArray, readId, readIndex, readTensorArray, gatherId, gatherIndices, gatherDtype, gatherTensorArray, scatterId, scatterIndices, scatterTensor, scatterTensorArray, concatId, concatTensorArray, concatDtype, splitId, splitTensor, lengths, splitTensorArray, sizeId, sizeTensorArray, closeId, closeTensorArray, idTensor, tensorList, elementDType, numElements, elementDtype, numElementsParam, tensor;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.t0 = node.op;\n          _context.next = _context.t0 === 'If' ? 3 : _context.t0 === 'StatelessIf' ? 3 : _context.t0 === 'While' ? 15 : _context.t0 === 'StatelessWhile' ? 15 : _context.t0 === 'LoopCond' ? 44 : _context.t0 === 'Switch' ? 46 : _context.t0 === 'Merge' ? 57 : _context.t0 === 'Enter' ? 62 : _context.t0 === 'Exit' ? 66 : _context.t0 === 'NextIteration' ? 69 : _context.t0 === 'TensorArrayV3' ? 72 : _context.t0 === 'TensorArrayWriteV3' ? 82 : _context.t0 === 'TensorArrayReadV3' ? 88 : _context.t0 === 'TensorArrayGatherV3' ? 92 : _context.t0 === 'TensorArrayScatterV3' ? 97 : _context.t0 === 'TensorArrayConcatV3' ? 103 : _context.t0 === 'TensorArraySplitV3' ? 107 : _context.t0 === 'TensorArraySizeV3' ? 113 : _context.t0 === 'TensorArrayCloseV3' ? 116 : _context.t0 === 'TensorListSetItem' ? 120 : _context.t0 === 'TensorListGetItem' ? 126 : _context.t0 === 'TensorListScatterV2' ? 132 : _context.t0 === 'TensorListScatter' ? 132 : _context.t0 === 'TensorListReserve' ? 139 : _context.t0 === 'EmptyTensorList' ? 139 : _context.t0 === 'TensorListGather' ? 146 : _context.t0 === 'TensorListStack' ? 152 : _context.t0 === 'TensorListFromTensor' ? 158 : _context.t0 === 'TensorListConcat' ? 164 : _context.t0 === 'TensorListPushBack' ? 169 : _context.t0 === 'TensorListPopBack' ? 174 : _context.t0 === 'TensorListSplit' ? 179 : 185;\n          break;\n\n        case 3:\n          thenFunc = getParamValue('thenBranch', node, tensorMap, context);\n          elseFunc = getParamValue('elseBranch', node, tensorMap, context);\n          cond = getParamValue('cond', node, tensorMap, context);\n          args = getParamValue('args', node, tensorMap, context);\n          _context.next = 9;\n          return cond.data();\n\n        case 9:\n          condValue = _context.sent;\n\n          if (!condValue[0]) {\n            _context.next = 14;\n            break;\n          }\n\n          return _context.abrupt(\"return\", context.functionMap[thenFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap));\n\n        case 14:\n          return _context.abrupt(\"return\", context.functionMap[elseFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap));\n\n        case 15:\n          bodyFunc = getParamValue('body', node, tensorMap, context);\n          condFunc = getParamValue('cond', node, tensorMap, context);\n          args = getParamValue('args', node, tensorMap, context); // Calculate the condition of the loop\n\n          _context.next = 20;\n          return context.functionMap[condFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);\n\n        case 20:\n          condResult = _context.sent;\n          argIds = args.map(tensor => tensor.id);\n          _context.next = 24;\n          return condResult[0].data();\n\n        case 24:\n          condValue = _context.sent;\n          // Dispose the intermediate tensors for condition function\n          condResult.forEach(tensor => {\n            if (!tensor.kept && argIds.indexOf(tensor.id) === -1) {\n              tensor.dispose();\n            }\n          });\n          result = args;\n\n        case 27:\n          if (!condValue[0]) {\n            _context.next = 43;\n            break;\n          }\n\n          // Record the previous result for intermediate tensor tracking\n          origResult = result; // Execution the body of the loop\n\n          _context.next = 31;\n          return context.functionMap[bodyFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap);\n\n        case 31:\n          result = _context.sent;\n          resultIds = result.map(tensor => tensor.id); // Dispose the intermediate tensor for body function that is not global\n          // kept, not input/output of the body function\n\n          origResult.forEach(tensor => {\n            if (!tensor.kept && argIds.indexOf(tensor.id) === -1 && resultIds.indexOf(tensor.id) === -1) {\n              tensor.dispose();\n            }\n          }); // Recalcuate the condition of the loop using the latest results.\n\n          _context.next = 36;\n          return context.functionMap[condFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap);\n\n        case 36:\n          condResult = _context.sent;\n          _context.next = 39;\n          return condResult[0].data();\n\n        case 39:\n          condValue = _context.sent;\n          // Dispose the intermediate tensors for condition function\n          condResult.forEach(tensor => {\n            if (!tensor.kept && argIds.indexOf(tensor.id) === -1 && resultIds.indexOf(tensor.id) === -1) {\n              tensor.dispose();\n            }\n          });\n          _context.next = 27;\n          break;\n\n        case 43:\n          return _context.abrupt(\"return\", result);\n\n        case 44:\n          pred = getParamValue('pred', node, tensorMap, context);\n          return _context.abrupt(\"return\", [cloneTensor(pred)]);\n\n        case 46:\n          pred = getParamValue('pred', node, tensorMap, context);\n          data = getParamValue('data', node, tensorMap, context);\n\n          if (!data.kept) {\n            data = cloneTensor(data);\n          } // Outputs nodes :0 => false, :1 => true\n\n\n          _context.next = 51;\n          return pred.data();\n\n        case 51:\n          if (!_context.sent[0]) {\n            _context.next = 55;\n            break;\n          }\n\n          _context.t1 = [undefined, data];\n          _context.next = 56;\n          break;\n\n        case 55:\n          _context.t1 = [data, undefined];\n\n        case 56:\n          return _context.abrupt(\"return\", _context.t1);\n\n        case 57:\n          inputName = node.inputNames.find(name => getTensor(name, tensorMap, context) !== undefined);\n\n          if (!inputName) {\n            _context.next = 61;\n            break;\n          }\n\n          data = getTensor(inputName, tensorMap, context);\n          return _context.abrupt(\"return\", [cloneTensor(data)]);\n\n        case 61:\n          return _context.abrupt(\"return\", undefined);\n\n        case 62:\n          frameId = getParamValue('frameName', node, tensorMap, context);\n          data = getParamValue('tensor', node, tensorMap, context);\n          context.enterFrame(frameId);\n          return _context.abrupt(\"return\", [cloneTensor(data)]);\n\n        case 66:\n          data = getParamValue('tensor', node, tensorMap, context);\n          context.exitFrame();\n          return _context.abrupt(\"return\", [cloneTensor(data)]);\n\n        case 69:\n          data = getParamValue('tensor', node, tensorMap, context);\n          context.nextIteration();\n          return _context.abrupt(\"return\", [cloneTensor(data)]);\n\n        case 72:\n          size = getParamValue('size', node, tensorMap, context);\n          dtype = getParamValue('dtype', node, tensorMap, context);\n          elementShape = getParamValue('elementShape', node, tensorMap, context);\n          dynamicSize = getParamValue('dynamicSize', node, tensorMap, context);\n          clearAfterRead = getParamValue('clearAfterRead', node, tensorMap, context);\n          identicalElementShapes = getParamValue('identicalElementShapes', node, tensorMap, context);\n          name = getParamValue('name', node, tensorMap, context);\n          tensorArray = new TensorArray(name, dtype, size, elementShape, identicalElementShapes, dynamicSize, clearAfterRead);\n          context.addTensorArray(tensorArray);\n          return _context.abrupt(\"return\", [tensorArray.idTensor, scalar(1.0)]);\n\n        case 82:\n          id = getParamValue('tensorArrayId', node, tensorMap, context);\n          index = getParamValue('index', node, tensorMap, context);\n          writeTensor = getParamValue('tensor', node, tensorMap, context);\n          writeTensorArray = context.getTensorArray(id.id);\n          writeTensorArray.write(index, writeTensor);\n          return _context.abrupt(\"return\", [writeTensorArray.idTensor]);\n\n        case 88:\n          readId = getParamValue('tensorArrayId', node, tensorMap, context);\n          readIndex = getParamValue('index', node, tensorMap, context);\n          readTensorArray = context.getTensorArray(readId.id);\n          return _context.abrupt(\"return\", [readTensorArray.read(readIndex)]);\n\n        case 92:\n          gatherId = getParamValue('tensorArrayId', node, tensorMap, context);\n          gatherIndices = getParamValue('indices', node, tensorMap, context);\n          gatherDtype = getParamValue('dtype', node, tensorMap, context);\n          gatherTensorArray = context.getTensorArray(gatherId.id);\n          return _context.abrupt(\"return\", [gatherTensorArray.gather(gatherIndices, gatherDtype)]);\n\n        case 97:\n          scatterId = getParamValue('tensorArrayId', node, tensorMap, context);\n          scatterIndices = getParamValue('indices', node, tensorMap, context);\n          scatterTensor = getParamValue('tensor', node, tensorMap, context);\n          scatterTensorArray = context.getTensorArray(scatterId.id);\n          scatterTensorArray.scatter(scatterIndices, scatterTensor);\n          return _context.abrupt(\"return\", [scatterTensorArray.idTensor]);\n\n        case 103:\n          concatId = getParamValue('tensorArrayId', node, tensorMap, context);\n          concatTensorArray = context.getTensorArray(concatId.id);\n          concatDtype = getParamValue('dtype', node, tensorMap, context);\n          return _context.abrupt(\"return\", [concatTensorArray.concat(concatDtype)]);\n\n        case 107:\n          splitId = getParamValue('tensorArrayId', node, tensorMap, context);\n          splitTensor = getParamValue('tensor', node, tensorMap, context);\n          lengths = getParamValue('lengths', node, tensorMap, context);\n          splitTensorArray = context.getTensorArray(splitId.id);\n          splitTensorArray.split(lengths, splitTensor);\n          return _context.abrupt(\"return\", [splitTensorArray.idTensor]);\n\n        case 113:\n          sizeId = getParamValue('tensorArrayId', node, tensorMap, context);\n          sizeTensorArray = context.getTensorArray(sizeId.id);\n          return _context.abrupt(\"return\", [scalar(sizeTensorArray.size(), 'int32')]);\n\n        case 116:\n          closeId = getParamValue('tensorArrayId', node, tensorMap, context);\n          closeTensorArray = context.getTensorArray(closeId.id);\n          closeTensorArray.clearAndClose();\n          return _context.abrupt(\"return\", [closeTensorArray.idTensor]);\n\n        case 120:\n          idTensor = getParamValue('tensorListId', node, tensorMap, context);\n          index = getParamValue('index', node, tensorMap, context);\n          writeTensor = getParamValue('tensor', node, tensorMap, context);\n          tensorList = context.getTensorList(idTensor.id);\n          tensorList.setItem(index, writeTensor);\n          return _context.abrupt(\"return\", [tensorList.idTensor]);\n\n        case 126:\n          idTensor = getParamValue('tensorListId', node, tensorMap, context);\n          readIndex = getParamValue('index', node, tensorMap, context);\n          elementShape = getParamValue('elementShape', node, tensorMap, context);\n          elementDType = getParamValue('elementDType', node, tensorMap, context);\n          tensorList = context.getTensorList(idTensor.id);\n          return _context.abrupt(\"return\", [tensorList.getItem(readIndex, elementShape, elementDType)]);\n\n        case 132:\n          scatterIndices = getParamValue('indices', node, tensorMap, context);\n          scatterTensor = getParamValue('tensor', node, tensorMap, context);\n          elementShape = getParamValue('elementShape', node, tensorMap, context);\n          numElements = getParamValue('numElements', node, tensorMap, context);\n          tensorList = scatter(scatterTensor, scatterIndices, elementShape, numElements);\n          context.addTensorList(tensorList);\n          return _context.abrupt(\"return\", [tensorList.idTensor]);\n\n        case 139:\n          elementShape = getParamValue('elementShape', node, tensorMap, context);\n          elementDtype = getParamValue('elementDType', node, tensorMap, context);\n\n          if (node.op === 'TensorListReserve') {\n            numElementsParam = 'numElements';\n          } else {\n            numElementsParam = 'maxNumElements';\n          }\n\n          numElements = getParamValue(numElementsParam, node, tensorMap, context);\n          tensorList = reserve(elementShape, elementDtype, numElements);\n          context.addTensorList(tensorList);\n          return _context.abrupt(\"return\", [tensorList.idTensor]);\n\n        case 146:\n          gatherId = getParamValue('tensorListId', node, tensorMap, context);\n          gatherIndices = getParamValue('indices', node, tensorMap, context);\n          elementShape = getParamValue('elementShape', node, tensorMap, context);\n          elementDtype = getParamValue('elementDType', node, tensorMap, context);\n          tensorList = context.getTensorList(gatherId.id);\n          return _context.abrupt(\"return\", [tensorList.gather(gatherIndices, elementDtype, elementShape)]);\n\n        case 152:\n          idTensor = getParamValue('tensorListId', node, tensorMap, context);\n          elementShape = getParamValue('elementShape', node, tensorMap, context);\n          elementDtype = getParamValue('elementDType', node, tensorMap, context);\n          numElements = getParamValue('numElements', node, tensorMap, context);\n          tensorList = context.getTensorList(idTensor.id);\n          return _context.abrupt(\"return\", [tensorList.stack(elementShape, elementDtype, numElements)]);\n\n        case 158:\n          tensor = getParamValue('tensor', node, tensorMap, context);\n          elementShape = getParamValue('elementShape', node, tensorMap, context);\n          elementDtype = getParamValue('elementDType', node, tensorMap, context);\n          tensorList = fromTensor(tensor, elementShape, elementDtype);\n          context.addTensorList(tensorList);\n          return _context.abrupt(\"return\", [tensorList.idTensor]);\n\n        case 164:\n          concatId = getParamValue('tensorListId', node, tensorMap, context);\n          tensorList = context.getTensorList(concatId.id);\n          concatDtype = getParamValue('dtype', node, tensorMap, context);\n          elementShape = getParamValue('elementShape', node, tensorMap, context);\n          return _context.abrupt(\"return\", [tensorList.concat(concatDtype, elementShape)]);\n\n        case 169:\n          idTensor = getParamValue('tensorListId', node, tensorMap, context);\n          writeTensor = getParamValue('tensor', node, tensorMap, context);\n          tensorList = context.getTensorList(idTensor.id);\n          tensorList.pushBack(writeTensor);\n          return _context.abrupt(\"return\", [tensorList.idTensor]);\n\n        case 174:\n          idTensor = getParamValue('tensorListId', node, tensorMap, context);\n          elementShape = getParamValue('elementShape', node, tensorMap, context);\n          elementDType = getParamValue('elementDType', node, tensorMap, context);\n          tensorList = context.getTensorList(idTensor.id);\n          return _context.abrupt(\"return\", [tensorList.popBack(elementShape, elementDType)]);\n\n        case 179:\n          splitTensor = getParamValue('tensor', node, tensorMap, context);\n          elementShape = getParamValue('elementShape', node, tensorMap, context);\n          lengths = getParamValue('lengths', node, tensorMap, context);\n          tensorList = split(splitTensor, lengths, elementShape);\n          context.addTensorList(tensorList);\n          return _context.abrupt(\"return\", [tensorList.idTensor]);\n\n        case 185:\n          throw TypeError(\"Node type \".concat(node.op, \" is not implemented\"));\n\n        case 186:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n\n  return function executeOp(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport const CATEGORY = 'control';","map":{"version":3,"sources":["../../../src/operations/executors/control_executor.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, scalar, Tensor} from '@tensorflow/tfjs-core';\n\nimport {NamedTensorsMap} from '../../data/types';\nimport {ExecutionContext} from '../../executor/execution_context';\nimport {TensorArray} from '../../executor/tensor_array';\nimport {fromTensor, reserve, scatter, split} from '../../executor/tensor_list';\nimport {InternalOpAsyncExecutor, Node} from '../types';\n\nimport {cloneTensor, getParamValue, getTensor} from './utils';\n\nexport const executeOp: InternalOpAsyncExecutor = async(\n    node: Node, tensorMap: NamedTensorsMap,\n    context: ExecutionContext): Promise<Tensor[]> => {\n  switch (node.op) {\n    case 'If':\n    case 'StatelessIf': {\n      const thenFunc =\n          getParamValue('thenBranch', node, tensorMap, context) as string;\n      const elseFunc =\n          getParamValue('elseBranch', node, tensorMap, context) as string;\n      const cond = getParamValue('cond', node, tensorMap, context) as Tensor;\n      const args = getParamValue('args', node, tensorMap, context) as Tensor[];\n      const condValue = await cond.data();\n      if (condValue[0]) {\n        return context.functionMap[thenFunc].executeFunctionAsync(\n            args, context.tensorArrayMap, context.tensorListMap);\n      } else {\n        return context.functionMap[elseFunc].executeFunctionAsync(\n            args, context.tensorArrayMap, context.tensorListMap);\n      }\n    }\n    case 'While':\n    case 'StatelessWhile': {\n      const bodyFunc =\n          getParamValue('body', node, tensorMap, context) as string;\n      const condFunc =\n          getParamValue('cond', node, tensorMap, context) as string;\n      const args = getParamValue('args', node, tensorMap, context) as Tensor[];\n\n      // Calculate the condition of the loop\n      const condResult =\n          (await context.functionMap[condFunc].executeFunctionAsync(\n              args, context.tensorArrayMap, context.tensorListMap));\n      const argIds = args.map(tensor => tensor.id);\n      let condValue = await condResult[0].data();\n      // Dispose the intermediate tensors for condition function\n      condResult.forEach(tensor => {\n        if (!tensor.kept && argIds.indexOf(tensor.id) === -1) {\n          tensor.dispose();\n        }\n      });\n\n      let result: Tensor[] = args;\n\n      while (condValue[0]) {\n        // Record the previous result for intermediate tensor tracking\n        const origResult = result;\n        // Execution the body of the loop\n        result = await context.functionMap[bodyFunc].executeFunctionAsync(\n            result, context.tensorArrayMap, context.tensorListMap);\n        const resultIds = result.map(tensor => tensor.id);\n\n        // Dispose the intermediate tensor for body function that is not global\n        // kept, not input/output of the body function\n        origResult.forEach(tensor => {\n          if (!tensor.kept && argIds.indexOf(tensor.id) === -1 &&\n              resultIds.indexOf(tensor.id) === -1) {\n            tensor.dispose();\n          }\n        });\n\n        // Recalcuate the condition of the loop using the latest results.\n        const condResult =\n            (await context.functionMap[condFunc].executeFunctionAsync(\n                result, context.tensorArrayMap, context.tensorListMap));\n        condValue = await condResult[0].data();\n        // Dispose the intermediate tensors for condition function\n        condResult.forEach(tensor => {\n          if (!tensor.kept && argIds.indexOf(tensor.id) === -1 &&\n              resultIds.indexOf(tensor.id) === -1) {\n            tensor.dispose();\n          }\n        });\n      }\n      return result;\n    }\n    case 'LoopCond': {\n      const pred = getParamValue('pred', node, tensorMap, context) as Tensor;\n      return [cloneTensor(pred)];\n    }\n    case 'Switch': {\n      const pred = getParamValue('pred', node, tensorMap, context) as Tensor;\n      let data = getParamValue('data', node, tensorMap, context) as Tensor;\n      if (!data.kept) {\n        data = cloneTensor(data);\n      }\n      // Outputs nodes :0 => false, :1 => true\n      return (await pred.data())[0] ? [undefined, data] : [data, undefined];\n    }\n    case 'Merge': {\n      const inputName = node.inputNames.find(\n          name => getTensor(name, tensorMap, context) !== undefined);\n      if (inputName) {\n        const data = getTensor(inputName, tensorMap, context);\n        return [cloneTensor(data)];\n      }\n      return undefined;\n    }\n    case 'Enter': {\n      const frameId =\n          getParamValue('frameName', node, tensorMap, context) as string;\n      const data = getParamValue('tensor', node, tensorMap, context) as Tensor;\n      context.enterFrame(frameId);\n      return [cloneTensor(data)];\n    }\n    case 'Exit': {\n      const data = getParamValue('tensor', node, tensorMap, context) as Tensor;\n      context.exitFrame();\n      return [cloneTensor(data)];\n    }\n    case 'NextIteration': {\n      const data = getParamValue('tensor', node, tensorMap, context) as Tensor;\n      context.nextIteration();\n      return [cloneTensor(data)];\n    }\n    case 'TensorArrayV3': {\n      const size = getParamValue('size', node, tensorMap, context) as number;\n      const dtype =\n          getParamValue('dtype', node, tensorMap, context) as DataType;\n      const elementShape =\n          getParamValue('elementShape', node, tensorMap, context) as number[];\n      const dynamicSize =\n          getParamValue('dynamicSize', node, tensorMap, context) as boolean;\n      const clearAfterRead =\n          getParamValue('clearAfterRead', node, tensorMap, context) as boolean;\n      const identicalElementShapes =\n          getParamValue('identicalElementShapes', node, tensorMap, context) as\n          boolean;\n      const name = getParamValue('name', node, tensorMap, context) as string;\n      const tensorArray = new TensorArray(\n          name, dtype, size, elementShape, identicalElementShapes, dynamicSize,\n          clearAfterRead);\n      context.addTensorArray(tensorArray);\n      return [tensorArray.idTensor, scalar(1.0)];\n    }\n    case 'TensorArrayWriteV3': {\n      const id =\n          getParamValue('tensorArrayId', node, tensorMap, context) as Tensor;\n      const index = getParamValue('index', node, tensorMap, context) as number;\n      const writeTensor =\n          getParamValue('tensor', node, tensorMap, context) as Tensor;\n      const writeTensorArray = context.getTensorArray(id.id);\n      writeTensorArray.write(index, writeTensor);\n      return [writeTensorArray.idTensor];\n    }\n    case 'TensorArrayReadV3': {\n      const readId =\n          getParamValue('tensorArrayId', node, tensorMap, context) as Tensor;\n      const readIndex =\n          getParamValue('index', node, tensorMap, context) as number;\n      const readTensorArray = context.getTensorArray(readId.id);\n      return [readTensorArray.read(readIndex)];\n    }\n    case 'TensorArrayGatherV3': {\n      const gatherId =\n          getParamValue('tensorArrayId', node, tensorMap, context) as Tensor;\n      const gatherIndices =\n          getParamValue('indices', node, tensorMap, context) as number[];\n      const gatherDtype =\n          getParamValue('dtype', node, tensorMap, context) as DataType;\n      const gatherTensorArray = context.getTensorArray(gatherId.id);\n      return [gatherTensorArray.gather(gatherIndices, gatherDtype)];\n    }\n    case 'TensorArrayScatterV3': {\n      const scatterId =\n          getParamValue('tensorArrayId', node, tensorMap, context) as Tensor;\n      const scatterIndices =\n          getParamValue('indices', node, tensorMap, context) as number[];\n      const scatterTensor =\n          getParamValue('tensor', node, tensorMap, context) as Tensor;\n      const scatterTensorArray = context.getTensorArray(scatterId.id);\n      scatterTensorArray.scatter(scatterIndices, scatterTensor);\n      return [scatterTensorArray.idTensor];\n    }\n    case 'TensorArrayConcatV3': {\n      const concatId =\n          getParamValue('tensorArrayId', node, tensorMap, context) as Tensor;\n      const concatTensorArray = context.getTensorArray(concatId.id);\n      const concatDtype =\n          getParamValue('dtype', node, tensorMap, context) as DataType;\n      return [concatTensorArray.concat(concatDtype)];\n    }\n    case 'TensorArraySplitV3': {\n      const splitId =\n          getParamValue('tensorArrayId', node, tensorMap, context) as Tensor;\n      const splitTensor =\n          getParamValue('tensor', node, tensorMap, context) as Tensor;\n      const lengths =\n          getParamValue('lengths', node, tensorMap, context) as number[];\n      const splitTensorArray = context.getTensorArray(splitId.id);\n      splitTensorArray.split(lengths, splitTensor);\n      return [splitTensorArray.idTensor];\n    }\n    case 'TensorArraySizeV3': {\n      const sizeId =\n          getParamValue('tensorArrayId', node, tensorMap, context) as Tensor;\n      const sizeTensorArray = context.getTensorArray(sizeId.id);\n      return [scalar(sizeTensorArray.size(), 'int32')];\n    }\n    case 'TensorArrayCloseV3': {\n      const closeId =\n          getParamValue('tensorArrayId', node, tensorMap, context) as Tensor;\n      const closeTensorArray = context.getTensorArray(closeId.id);\n      closeTensorArray.clearAndClose();\n      return [closeTensorArray.idTensor];\n    }\n    case 'TensorListSetItem': {\n      const idTensor =\n          getParamValue('tensorListId', node, tensorMap, context) as Tensor;\n      const index = getParamValue('index', node, tensorMap, context) as number;\n      const writeTensor =\n          getParamValue('tensor', node, tensorMap, context) as Tensor;\n      const tensorList = context.getTensorList(idTensor.id);\n      tensorList.setItem(index, writeTensor);\n      return [tensorList.idTensor];\n    }\n    case 'TensorListGetItem': {\n      const idTensor =\n          getParamValue('tensorListId', node, tensorMap, context) as Tensor;\n      const readIndex =\n          getParamValue('index', node, tensorMap, context) as number;\n      const elementShape =\n          getParamValue('elementShape', node, tensorMap, context) as number[];\n\n      const elementDType =\n          getParamValue('elementDType', node, tensorMap, context) as DataType;\n      const tensorList = context.getTensorList(idTensor.id);\n      return [tensorList.getItem(readIndex, elementShape, elementDType)];\n    }\n    case 'TensorListScatterV2':\n    case 'TensorListScatter': {\n      const scatterIndices =\n          getParamValue('indices', node, tensorMap, context) as number[];\n      const scatterTensor =\n          getParamValue('tensor', node, tensorMap, context) as Tensor;\n      const elementShape =\n          getParamValue('elementShape', node, tensorMap, context) as number[];\n      const numElements =\n          getParamValue('numElements', node, tensorMap, context) as number;\n      const tensorList =\n          scatter(scatterTensor, scatterIndices, elementShape, numElements);\n      context.addTensorList(tensorList);\n      return [tensorList.idTensor];\n    }\n    case 'TensorListReserve':\n    case 'EmptyTensorList': {\n      const elementShape =\n          getParamValue('elementShape', node, tensorMap, context) as number[];\n      const elementDtype =\n          getParamValue('elementDType', node, tensorMap, context) as DataType;\n      let numElementsParam;\n\n      if (node.op === 'TensorListReserve') {\n        numElementsParam = 'numElements';\n      } else {\n        numElementsParam = 'maxNumElements';\n      }\n\n      const numElements =\n          getParamValue(numElementsParam, node, tensorMap, context) as number;\n\n      const tensorList = reserve(elementShape, elementDtype, numElements);\n      context.addTensorList(tensorList);\n      return [tensorList.idTensor];\n    }\n    case 'TensorListGather': {\n      const gatherId =\n          getParamValue('tensorListId', node, tensorMap, context) as Tensor;\n      const gatherIndices =\n          getParamValue('indices', node, tensorMap, context) as number[];\n      const elementShape =\n          getParamValue('elementShape', node, tensorMap, context) as number[];\n      const elementDtype =\n          getParamValue('elementDType', node, tensorMap, context) as DataType;\n      const tensorList = context.getTensorList(gatherId.id);\n      return [tensorList.gather(gatherIndices, elementDtype, elementShape)];\n    }\n    case 'TensorListStack': {\n      const idTensor =\n          getParamValue('tensorListId', node, tensorMap, context) as Tensor;\n      const elementShape =\n          getParamValue('elementShape', node, tensorMap, context) as number[];\n      const elementDtype =\n          getParamValue('elementDType', node, tensorMap, context) as DataType;\n      const numElements =\n          getParamValue('numElements', node, tensorMap, context) as number;\n      const tensorList = context.getTensorList(idTensor.id);\n      return [tensorList.stack(elementShape, elementDtype, numElements)];\n    }\n    case 'TensorListFromTensor': {\n      const tensor =\n          getParamValue('tensor', node, tensorMap, context) as Tensor;\n      const elementShape =\n          getParamValue('elementShape', node, tensorMap, context) as number[];\n      const elementDtype =\n          getParamValue('elementDType', node, tensorMap, context) as DataType;\n      const tensorList = fromTensor(tensor, elementShape, elementDtype);\n      context.addTensorList(tensorList);\n      return [tensorList.idTensor];\n    }\n    case 'TensorListConcat': {\n      const concatId =\n          getParamValue('tensorListId', node, tensorMap, context) as Tensor;\n      const tensorList = context.getTensorList(concatId.id);\n      const concatDtype =\n          getParamValue('dtype', node, tensorMap, context) as DataType;\n      const elementShape =\n          getParamValue('elementShape', node, tensorMap, context) as number[];\n      return [tensorList.concat(concatDtype, elementShape)];\n    }\n    case 'TensorListPushBack': {\n      const idTensor =\n          getParamValue('tensorListId', node, tensorMap, context) as Tensor;\n      const writeTensor =\n          getParamValue('tensor', node, tensorMap, context) as Tensor;\n      const tensorList = context.getTensorList(idTensor.id);\n      tensorList.pushBack(writeTensor);\n      return [tensorList.idTensor];\n    }\n    case 'TensorListPopBack': {\n      const idTensor =\n          getParamValue('tensorListId', node, tensorMap, context) as Tensor;\n      const elementShape =\n          getParamValue('elementShape', node, tensorMap, context) as number[];\n      const elementDType =\n          getParamValue('elementDType', node, tensorMap, context) as DataType;\n      const tensorList = context.getTensorList(idTensor.id);\n      return [tensorList.popBack(elementShape, elementDType)];\n    }\n    case 'TensorListSplit': {\n      const splitTensor =\n          getParamValue('tensor', node, tensorMap, context) as Tensor;\n      const elementShape =\n          getParamValue('elementShape', node, tensorMap, context) as number[];\n      const lengths =\n          getParamValue('lengths', node, tensorMap, context) as number[];\n\n      const tensorList = split(splitTensor, lengths, elementShape);\n      context.addTensorList(tensorList);\n      return [tensorList.idTensor];\n    }\n    default:\n      throw TypeError(`Node type ${node.op} is not implemented`);\n  }\n};\n\nexport const CATEGORY = 'control';\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}