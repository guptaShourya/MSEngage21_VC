{"ast":null,"code":"/*\n@license\nThe following license applies to all parts of this software except as\ndocumented below.\n\n    Copyright (c) 2019, Twilio, inc.\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions are\n    met:\n\n      1. Redistributions of source code must retain the above copyright\n         notice, this list of conditions and the following disclaimer.\n\n      2. Redistributions in binary form must reproduce the above copyright\n         notice, this list of conditions and the following disclaimer in\n         the documentation and/or other materials provided with the\n         distribution.\n\n      3. Neither the name of Twilio nor the names of its contributors may\n         be used to endorse or promote products derived from this software\n         without specific prior written permission.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nThis software includes javascript-state-machine under the following license.\n\n    Copyright (c) 2012, 2013, 2014, 2015, Jake Gordon and contributors\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\nThis software includes loglevel under the following license.\n\n    Copyright (c) 2013 Tim Perry\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use,\n    copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following\n    conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER DEALINGS IN THE SOFTWARE.\n\nThis software includes q under the following license.\n\n    Copyright 2009â€“2014 Kristopher Michael Kowal. All rights reserved.\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to\n    deal in the Software without restriction, including without limitation the\n    rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n    sell copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in\n    all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n    IN THE SOFTWARE.\n\nThis software includes platform.js under the following license.\n\n    Copyright 2014 Benjamin Tan <https://d10.github.io/>\n    Copyright 2011-2015 John-David Dalton <http://allyoucanleet.com/>\n\n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n    \"Software\"), to deal in the Software without restriction, including\n    without limitation the rights to use, copy, modify, merge, publish,\n    distribute, sublicense, and/or sell copies of the Software, and to\n    permit persons to whom the Software is furnished to do so, subject to\n    the following conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n    LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n'use strict';\n\nrequire(\"core-js/modules/es.symbol\");\n\nrequire(\"core-js/modules/es.symbol.description\");\n\nrequire(\"core-js/modules/es.symbol.iterator\");\n\nrequire(\"core-js/modules/es.array.concat\");\n\nrequire(\"core-js/modules/es.array.filter\");\n\nrequire(\"core-js/modules/es.array.find\");\n\nrequire(\"core-js/modules/es.array.from\");\n\nrequire(\"core-js/modules/es.array.iterator\");\n\nrequire(\"core-js/modules/es.array.map\");\n\nrequire(\"core-js/modules/es.array.slice\");\n\nrequire(\"core-js/modules/es.array.sort\");\n\nrequire(\"core-js/modules/es.array.splice\");\n\nrequire(\"core-js/modules/es.array-buffer.constructor\");\n\nrequire(\"core-js/modules/es.map\");\n\nrequire(\"core-js/modules/es.number.constructor\");\n\nrequire(\"core-js/modules/es.number.is-integer\");\n\nrequire(\"core-js/modules/es.object.assign\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptor\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptors\");\n\nrequire(\"core-js/modules/es.object.keys\");\n\nrequire(\"core-js/modules/es.object.to-string\");\n\nrequire(\"core-js/modules/es.promise\");\n\nrequire(\"core-js/modules/es.reflect.construct\");\n\nrequire(\"core-js/modules/es.regexp.exec\");\n\nrequire(\"core-js/modules/es.regexp.to-string\");\n\nrequire(\"core-js/modules/es.set\");\n\nrequire(\"core-js/modules/es.string.iterator\");\n\nrequire(\"core-js/modules/es.string.replace\");\n\nrequire(\"core-js/modules/es.typed-array.uint8-array\");\n\nrequire(\"core-js/modules/es.typed-array.copy-within\");\n\nrequire(\"core-js/modules/es.typed-array.every\");\n\nrequire(\"core-js/modules/es.typed-array.fill\");\n\nrequire(\"core-js/modules/es.typed-array.filter\");\n\nrequire(\"core-js/modules/es.typed-array.find\");\n\nrequire(\"core-js/modules/es.typed-array.find-index\");\n\nrequire(\"core-js/modules/es.typed-array.for-each\");\n\nrequire(\"core-js/modules/es.typed-array.includes\");\n\nrequire(\"core-js/modules/es.typed-array.index-of\");\n\nrequire(\"core-js/modules/es.typed-array.iterator\");\n\nrequire(\"core-js/modules/es.typed-array.join\");\n\nrequire(\"core-js/modules/es.typed-array.last-index-of\");\n\nrequire(\"core-js/modules/es.typed-array.map\");\n\nrequire(\"core-js/modules/es.typed-array.reduce\");\n\nrequire(\"core-js/modules/es.typed-array.reduce-right\");\n\nrequire(\"core-js/modules/es.typed-array.reverse\");\n\nrequire(\"core-js/modules/es.typed-array.slice\");\n\nrequire(\"core-js/modules/es.typed-array.some\");\n\nrequire(\"core-js/modules/es.typed-array.sort\");\n\nrequire(\"core-js/modules/es.typed-array.to-locale-string\");\n\nrequire(\"core-js/modules/es.typed-array.to-string\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator\");\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');\n\nvar _createClass = require('@babel/runtime/helpers/createClass');\n\nvar _assertThisInitialized = require('@babel/runtime/helpers/assertThisInitialized');\n\nvar _inherits = require('@babel/runtime/helpers/inherits');\n\nvar _possibleConstructorReturn = require('@babel/runtime/helpers/possibleConstructorReturn');\n\nvar _getPrototypeOf = require('@babel/runtime/helpers/getPrototypeOf');\n\nvar _defineProperty = require('@babel/runtime/helpers/defineProperty');\n\nvar _classCallCheck = require('@babel/runtime/helpers/classCallCheck');\n\nvar _regeneratorRuntime = require('@babel/runtime/regenerator');\n\nvar _typeof = require('@babel/runtime/helpers/typeof');\n\nvar loglevelLog = require('loglevel');\n\nvar _slicedToArray = require('@babel/runtime/helpers/slicedToArray');\n\nvar operationRetrier = require('operation-retrier');\n\nvar JsonDiff = require('rfc6902');\n\nvar twilsock = require('twilsock');\n\nvar twilioNotifications = require('twilio-notifications');\n\nvar twilioSync = require('twilio-sync');\n\nvar twilioMcsClient = require('twilio-mcs-client');\n\nvar uuid = require('uuid');\n\nvar platform = require('platform');\n\nvar _wrapNativeSuper = require('@babel/runtime/helpers/wrapNativeSuper');\n\nvar iso8601Duration = require('iso8601-duration');\n\nvar _toConsumableArray = require('@babel/runtime/helpers/toConsumableArray');\n\nvar twilioSdkTypeValidator = require('twilio-sdk-type-validator');\n\nvar telemetrytracker = require('twilsock/lib/services/telemetrytracker');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function get() {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n['default'] = e;\n  return Object.freeze(n);\n}\n\nvar _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);\n\nvar _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);\n\nvar _assertThisInitialized__default = /*#__PURE__*/_interopDefaultLegacy(_assertThisInitialized);\n\nvar _inherits__default = /*#__PURE__*/_interopDefaultLegacy(_inherits);\n\nvar _possibleConstructorReturn__default = /*#__PURE__*/_interopDefaultLegacy(_possibleConstructorReturn);\n\nvar _getPrototypeOf__default = /*#__PURE__*/_interopDefaultLegacy(_getPrototypeOf);\n\nvar _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);\n\nvar _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);\n\nvar _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);\n\nvar _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);\n\nvar loglevelLog__namespace = /*#__PURE__*/_interopNamespace(loglevelLog);\n\nvar _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);\n\nvar JsonDiff__namespace = /*#__PURE__*/_interopNamespace(JsonDiff);\n\nvar uuid__namespace = /*#__PURE__*/_interopNamespace(uuid);\n\nvar platform__namespace = /*#__PURE__*/_interopNamespace(platform);\n\nvar _wrapNativeSuper__default = /*#__PURE__*/_interopDefaultLegacy(_wrapNativeSuper);\n\nvar _toConsumableArray__default = /*#__PURE__*/_interopDefaultLegacy(_toConsumableArray);\n\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof__default['default'](Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nfunction __metadata(metadataKey, metadataValue) {\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof__default['default'](Reflect)) === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nvar domain; // This constructor is used to store event handlers. Instantiating this is\n// faster than explicitly calling `Object.create(null)` to get a \"clean\" empty\n// object (tested with v8 v4.9).\n\nfunction EventHandlers() {}\n\nEventHandlers.prototype = Object.create(null);\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n} // nodejs oddity\n// require('events') === require('events').EventEmitter\n\n\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.usingDomains = false;\nEventEmitter.prototype.domain = undefined;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\n\nEventEmitter.defaultMaxListeners = 10;\n\nEventEmitter.init = function () {\n  this.domain = null;\n\n  if (EventEmitter.usingDomains) {\n    // if there is an active domain, then attach to it.\n    if (domain.active) ;\n  }\n\n  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = new EventHandlers();\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n}; // Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\n\n\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n)) throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n}; // These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\n\n\nfunction emitNone(handler, isFn, self) {\n  if (isFn) handler.call(self);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n\n    for (var i = 0; i < len; ++i) {\n      listeners[i].call(self);\n    }\n  }\n}\n\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn) handler.call(self, arg1);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n\n    for (var i = 0; i < len; ++i) {\n      listeners[i].call(self, arg1);\n    }\n  }\n}\n\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn) handler.call(self, arg1, arg2);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n\n    for (var i = 0; i < len; ++i) {\n      listeners[i].call(self, arg1, arg2);\n    }\n  }\n}\n\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn) handler.call(self, arg1, arg2, arg3);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n\n    for (var i = 0; i < len; ++i) {\n      listeners[i].call(self, arg1, arg2, arg3);\n    }\n  }\n}\n\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn) handler.apply(self, args);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n\n    for (var i = 0; i < len; ++i) {\n      listeners[i].apply(self, args);\n    }\n  }\n}\n\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events, domain;\n  var doError = type === 'error';\n  events = this._events;\n  if (events) doError = doError && events.error == null;else if (!doError) return false;\n  domain = this.domain; // If there is no 'error' event listener then throw.\n\n  if (doError) {\n    er = arguments[1];\n\n    if (domain) {\n      if (!er) er = new Error('Uncaught, unspecified \"error\" event');\n      er.domainEmitter = this;\n      er.domain = domain;\n      er.domainThrown = false;\n      domain.emit('error', er);\n    } else if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n\n    return false;\n  }\n\n  handler = events[type];\n  if (!handler) return false;\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n\n  switch (len) {\n    // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n    // slower\n\n    default:\n      args = new Array(len - 1);\n\n      for (i = 1; i < len; i++) {\n        args[i - 1] = arguments[i];\n      }\n\n      emitMany(handler, isFn, this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n  if (typeof listener !== 'function') throw new TypeError('\"listener\" argument must be a function');\n  events = target._events;\n\n  if (!events) {\n    events = target._events = new EventHandlers();\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n\n      events = target._events;\n    }\n\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] : [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    } // Check for listener leak\n\n\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + type + ' listeners added. ' + 'Use emitter.setMaxListeners() to increase limit');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        emitWarning(w);\n      }\n    }\n  }\n\n  return target;\n}\n\nfunction emitWarning(e) {\n  typeof console.warn === 'function' ? console.warn(e) : console.log(e);\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\n\nfunction _onceWrap(target, type, listener) {\n  var fired = false;\n\n  function g() {\n    target.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(target, arguments);\n    }\n  }\n\n  g.listener = listener;\n  return g;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  if (typeof listener !== 'function') throw new TypeError('\"listener\" argument must be a function');\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n}; // emits a 'removeListener' event iff the listener was removed\n\n\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  var list, events, position, i, originalListener;\n  if (typeof listener !== 'function') throw new TypeError('\"listener\" argument must be a function');\n  events = this._events;\n  if (!events) return this;\n  list = events[type];\n  if (!list) return this;\n\n  if (list === listener || list.listener && list.listener === listener) {\n    if (--this._eventsCount === 0) this._events = new EventHandlers();else {\n      delete events[type];\n      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n    }\n  } else if (typeof list !== 'function') {\n    position = -1;\n\n    for (i = list.length; i-- > 0;) {\n      if (list[i] === listener || list[i].listener && list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0) return this;\n\n    if (list.length === 1) {\n      list[0] = undefined;\n\n      if (--this._eventsCount === 0) {\n        this._events = new EventHandlers();\n        return this;\n      } else {\n        delete events[type];\n      }\n    } else {\n      spliceOne(list, position);\n    }\n\n    if (events.removeListener) this.emit('removeListener', type, originalListener || listener);\n  }\n\n  return this;\n}; // Alias for removeListener added in NodeJS 10.0\n// https://nodejs.org/api/events.html#events_emitter_off_eventname_listener\n\n\nEventEmitter.prototype.off = function (type, listener) {\n  return this.removeListener(type, listener);\n};\n\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  var listeners, events;\n  events = this._events;\n  if (!events) return this; // not listening for removeListener, no need to emit\n\n  if (!events.removeListener) {\n    if (arguments.length === 0) {\n      this._events = new EventHandlers();\n      this._eventsCount = 0;\n    } else if (events[type]) {\n      if (--this._eventsCount === 0) this._events = new EventHandlers();else delete events[type];\n    }\n\n    return this;\n  } // emit removeListener for all listeners on all events\n\n\n  if (arguments.length === 0) {\n    var keys = Object.keys(events);\n\n    for (var i = 0, key; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n\n    this.removeAllListeners('removeListener');\n    this._events = new EventHandlers();\n    this._eventsCount = 0;\n    return this;\n  }\n\n  listeners = events[type];\n\n  if (typeof listeners === 'function') {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    do {\n      this.removeListener(type, listeners[listeners.length - 1]);\n    } while (listeners[0]);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  var evlistener;\n  var ret;\n  var events = this._events;\n  if (!events) ret = [];else {\n    evlistener = events[type];\n    if (!evlistener) ret = [];else if (typeof evlistener === 'function') ret = [evlistener.listener || evlistener];else ret = unwrapListeners(evlistener);\n  }\n  return ret;\n};\n\nEventEmitter.listenerCount = function (emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\n\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n}; // About 1.5x faster than the two-arg version of Array#splice().\n\n\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {\n    list[i] = list[k];\n  }\n\n  list.pop();\n}\n\nfunction arrayClone(arr, i) {\n  var copy = new Array(i);\n\n  while (i--) {\n    copy[i] = arr[i];\n  }\n\n  return copy;\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n\n  return ret;\n}\n\nfunction prepareLine(prefix, args) {\n  return [\"\".concat(new Date().toISOString(), \" Conversations \").concat(prefix, \":\")].concat(Array.from(args));\n}\n\nvar log$a = loglevelLog__namespace.getLogger('twilio-conversations'); // twilio-conversations is used by Flex SDK. Please DO NOT change\n\nvar Logger = /*#__PURE__*/function () {\n  function Logger(prefix) {\n    _classCallCheck__default['default'](this, Logger);\n\n    _defineProperty__default['default'](this, \"prefix\", '');\n\n    this.prefix = prefix !== null && prefix !== undefined && prefix.length > 0 ? prefix + ' ' : '';\n  }\n\n  _createClass__default['default'](Logger, [{\n    key: \"setLevel\",\n    value: function setLevel(level) {\n      log$a.setLevel(level);\n    }\n  }, {\n    key: \"trace\",\n    value: function trace() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      log$a.trace.apply(null, prepareLine(this.prefix + 'T', args));\n    }\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      log$a.debug.apply(null, prepareLine(this.prefix + 'D', args));\n    }\n  }, {\n    key: \"info\",\n    value: function info() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      log$a.info.apply(null, prepareLine(this.prefix + 'I', args));\n    }\n  }, {\n    key: \"warn\",\n    value: function warn() {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      log$a.warn.apply(null, prepareLine(this.prefix + 'W', args));\n    }\n  }, {\n    key: \"error\",\n    value: function error() {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n\n      log$a.error.apply(null, prepareLine(this.prefix + 'E', args));\n    }\n  }], [{\n    key: \"scope\",\n    value: function scope(prefix) {\n      return new Logger(prefix);\n    }\n  }, {\n    key: \"setLevel\",\n    value: function setLevel(level) {\n      log$a.setLevel(level);\n    }\n  }, {\n    key: \"trace\",\n    value: function trace() {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n\n      log$a.trace.apply(null, prepareLine('T', args));\n    }\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n\n      log$a.debug.apply(null, prepareLine('D', args));\n    }\n  }, {\n    key: \"info\",\n    value: function info() {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n\n      log$a.info.apply(null, prepareLine('I', args));\n    }\n  }, {\n    key: \"warn\",\n    value: function warn() {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n\n      log$a.warn.apply(null, prepareLine('W', args));\n    }\n  }, {\n    key: \"error\",\n    value: function error() {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n\n      log$a.error.apply(null, prepareLine('E', args));\n    }\n  }]);\n\n  return Logger;\n}();\n\nvar TYPING_PATH = '/v1/typing';\nvar TYPING_TIMEOUT = 5;\nvar HTTP_CACHE_LIFETIME = 'PT5S';\nvar CONSUMPTION_HORIZON_SENDING_INTERVAL = 'PT5S';\nvar USER_INFOS_TO_SUBSCRIBE = 100;\nvar MINIMUM_RETRY_DELAY = 1000;\nvar MAXIMUM_RETRY_DELAY = 4000;\nvar MAXIMUM_ATTEMPTS_COUNT = 3;\nvar RETRY_WHEN_THROTTLED = true;\n\nvar Configuration = /*#__PURE__*/function () {\n  function Configuration(options) {\n    _classCallCheck__default['default'](this, Configuration);\n\n    options = options || {};\n    var constructorOptions = options.Chat || options.IPMessaging || options || {};\n    this.region = constructorOptions.region || options.region;\n    this.baseUrl = constructorOptions.apiUri || constructorOptions.typingUri || (!this.region || this.region === 'us1' ? 'https://aim.twilio.com' : \"https://aim.\".concat(this.region, \".twilio.com\"));\n    this.typingIndicatorUri = this.baseUrl + TYPING_PATH;\n    this.typingIndicatorTimeoutOverride = constructorOptions.typingIndicatorTimeoutOverride;\n    this.httpCacheIntervalOverride = constructorOptions.httpCacheIntervalOverride;\n    this.consumptionReportIntervalOverride = constructorOptions.consumptionReportIntervalOverride;\n    this.userInfosToSubscribeOverride = constructorOptions.userInfosToSubscribeOverride;\n    this.retryWhenThrottledOverride = constructorOptions.retryWhenThrottledOverride;\n    this.backoffConfigOverride = constructorOptions.backoffConfigOverride;\n    this.productId = options.productId;\n  }\n\n  _createClass__default['default'](Configuration, [{\n    key: \"typingIndicatorTimeoutDefault\",\n    get: function get() {\n      return TYPING_TIMEOUT * 1000;\n    }\n  }, {\n    key: \"httpCacheIntervalDefault\",\n    get: function get() {\n      return HTTP_CACHE_LIFETIME;\n    }\n  }, {\n    key: \"consumptionReportIntervalDefault\",\n    get: function get() {\n      return CONSUMPTION_HORIZON_SENDING_INTERVAL;\n    }\n  }, {\n    key: \"userInfosToSubscribeDefault\",\n    get: function get() {\n      return USER_INFOS_TO_SUBSCRIBE;\n    }\n  }, {\n    key: \"retryWhenThrottledDefault\",\n    get: function get() {\n      return RETRY_WHEN_THROTTLED;\n    }\n  }, {\n    key: \"backoffConfigDefault\",\n    get: function get() {\n      return {\n        min: MINIMUM_RETRY_DELAY,\n        max: MAXIMUM_RETRY_DELAY,\n        maxAttemptsCount: MAXIMUM_ATTEMPTS_COUNT\n      };\n    }\n  }]);\n\n  return Configuration;\n}();\n\nfunction _createForOfIteratorHelper$1(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray$1(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray$1(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);\n}\n\nfunction _arrayLikeToArray$1(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar Network = /*#__PURE__*/function () {\n  function Network(config, services) {\n    var _this = this;\n\n    _classCallCheck__default['default'](this, Network);\n\n    this.config = config;\n    this.services = services;\n    this.cache = new Map();\n    this.cacheLifetime = 0;\n    this.services.session.getHttpCacheInterval().then(function (seconds) {\n      _this.cacheLifetime = seconds * 1000;\n\n      _this.cleanupCache();\n    });\n  }\n\n  _createClass__default['default'](Network, [{\n    key: \"backoffConfig\",\n    value: function backoffConfig() {\n      return Object.assign(this.config.backoffConfigDefault, this.config.backoffConfigOverride);\n    }\n  }, {\n    key: \"retryWhenThrottled\",\n    value: function retryWhenThrottled() {\n      if (typeof this.config.retryWhenThrottledOverride !== 'undefined') {\n        return this.config.retryWhenThrottledOverride;\n      }\n\n      if (typeof this.config.retryWhenThrottledDefault !== 'undefined') {\n        return this.config.retryWhenThrottledDefault;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"isExpired\",\n    value: function isExpired(timestamp) {\n      return !this.cacheLifetime || Date.now() - timestamp > this.cacheLifetime;\n    }\n  }, {\n    key: \"cleanupCache\",\n    value: function cleanupCache() {\n      var _iterator = _createForOfIteratorHelper$1(this.cache),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray__default['default'](_step.value, 2),\n              k = _step$value[0],\n              v = _step$value[1];\n\n          if (this.isExpired(v.timestamp)) {\n            this.cache.delete(k);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (this.cache.size === 0) {\n        clearInterval(this.timer);\n      }\n    }\n  }, {\n    key: \"pokeTimer\",\n    value: function pokeTimer() {\n      var _this2 = this;\n\n      this.timer = this.timer || setInterval(function () {\n        return _this2.cleanupCache();\n      }, this.cacheLifetime * 2);\n    }\n  }, {\n    key: \"executeWithRetry\",\n    value: function executeWithRetry(request) {\n      var _this3 = this;\n\n      var retryWhenThrottled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return new Promise(function (resolve, reject) {\n        var codesToRetryOn = [502, 503, 504];\n\n        if (retryWhenThrottled) {\n          codesToRetryOn.push(429);\n        }\n\n        var retrier = new operationRetrier.Retrier(_this3.backoffConfig());\n        retrier.on('attempt', function () {\n          request().then(function (result) {\n            return retrier.succeeded(result);\n          }).catch(function (err) {\n            if (codesToRetryOn.indexOf(err.status) > -1) {\n              retrier.failed(err);\n            } else if (err.message === 'Twilsock disconnected') {\n              // Ugly hack. We must make a proper exceptions for twilsock\n              retrier.failed(err);\n            } else {\n              // Fatal error\n              retrier.removeAllListeners();\n              retrier.cancel();\n              reject(err);\n            }\n          });\n        });\n        retrier.on('succeeded', function (result) {\n          resolve(result);\n        });\n        retrier.on('cancelled', function (err) {\n          return reject(err);\n        });\n        retrier.on('failed', function (err) {\n          return reject(err);\n        });\n        retrier.start();\n      });\n    }\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(url) {\n        var _this4 = this;\n\n        var cacheEntry, headers, response;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                cacheEntry = this.cache.get(url);\n\n                if (!(cacheEntry && !this.isExpired(cacheEntry.timestamp))) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", cacheEntry.response);\n\n              case 3:\n                headers = {};\n                _context.next = 6;\n                return this.executeWithRetry(function () {\n                  return _this4.services.transport.get(url, headers, _this4.config.productId);\n                }, this.retryWhenThrottled());\n\n              case 6:\n                response = _context.sent;\n                this.cache.set(url, {\n                  response: response,\n                  timestamp: Date.now()\n                });\n                this.pokeTimer();\n                return _context.abrupt(\"return\", response);\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function get(_x) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n  }]);\n\n  return Network;\n}();\n\nvar NotificationTypes = function NotificationTypes() {\n  _classCallCheck__default['default'](this, NotificationTypes);\n};\n\n_defineProperty__default['default'](NotificationTypes, \"TYPING_INDICATOR\", 'twilio.ipmsg.typing_indicator');\n\n_defineProperty__default['default'](NotificationTypes, \"NEW_MESSAGE\", 'twilio.conversations.new_message');\n\n_defineProperty__default['default'](NotificationTypes, \"ADDED_TO_CONVERSATION\", 'twilio.conversations.added_to_conversation');\n\n_defineProperty__default['default'](NotificationTypes, \"REMOVED_FROM_CONVERSATION\", 'twilio.conversations.removed_from_conversation');\n\n_defineProperty__default['default'](NotificationTypes, \"CONSUMPTION_UPDATE\", 'twilio.channel.consumption_update');\n/**\n * Checks if objects are equal\n */\n\n\nfunction isDeepEqual(o1, o2) {\n  return JsonDiff__namespace.createPatch(o1, o2).length === 0;\n}\n/**\n * Deep-clone an object. Note that this does not work on object containing\n * functions.\n * @param {object} obj - the object to deep-clone\n * @returns {object}\n */\n\n\nfunction deepClone(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nfunction parseToNumber(value) {\n  if (typeof value !== 'undefined' && !isNaN(Number(value))) {\n    return Number(value);\n  }\n\n  return null;\n} // timeString cannot be typed `string` because in member.ts\n// call to parseTime(data.lastReadTimestamp) uses number not a string for timestamp.\n\n\nfunction parseTime$1(timeString) {\n  try {\n    return new Date(timeString);\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction parseAttributes(rawAttributes, warningMessage, log) {\n  var attributes = {};\n\n  if (rawAttributes) {\n    try {\n      attributes = JSON.parse(rawAttributes);\n    } catch (e) {\n      log.warn(warningMessage, e);\n    }\n  }\n\n  return attributes;\n}\n/**\n * Construct URI with query parameters\n */\n\n\nvar UriBuilder = /*#__PURE__*/function () {\n  function UriBuilder(base) {\n    _classCallCheck__default['default'](this, UriBuilder);\n\n    this.base = base.replace(/\\/$/, '');\n    this.args = [];\n    this.paths = [];\n  }\n\n  _createClass__default['default'](UriBuilder, [{\n    key: \"arg\",\n    value: function arg(name, value) {\n      if (typeof value !== 'undefined') {\n        this.args.push(encodeURIComponent(name) + '=' + encodeURIComponent(value));\n      }\n\n      return this;\n    }\n  }, {\n    key: \"path\",\n    value: function path(name) {\n      this.paths.push(encodeURIComponent(name));\n      return this;\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      var result = this.base;\n\n      if (this.paths.length) {\n        result += '/' + this.paths.join('/');\n      }\n\n      if (this.args.length) {\n        result += '?' + this.args.join('&');\n      }\n\n      return result;\n    }\n  }]);\n\n  return UriBuilder;\n}();\n\nvar RestPaginator = /*#__PURE__*/function () {\n  /*\n  * @constructor\n  * @param {Array} items Array of element for current page\n  * @param {Object} params\n  * @private\n  */\n  function RestPaginator(items, source, prevToken, nextToken) {\n    _classCallCheck__default['default'](this, RestPaginator);\n\n    this.state = {\n      prevToken: prevToken,\n      nextToken: nextToken,\n      source: source,\n      items: items\n    };\n  }\n\n  _createClass__default['default'](RestPaginator, [{\n    key: \"hasNextPage\",\n    get: function get() {\n      return !!this.state.nextToken;\n    }\n  }, {\n    key: \"hasPrevPage\",\n    get: function get() {\n      return !!this.state.prevToken;\n    }\n  }, {\n    key: \"items\",\n    get: function get() {\n      return this.state.items;\n    }\n  }, {\n    key: \"nextPage\",\n    value: function nextPage() {\n      return this.hasNextPage ? this.state.source(this.state.nextToken) : Promise.reject(new Error('No next page'));\n    }\n  }, {\n    key: \"prevPage\",\n    value: function prevPage() {\n      return this.hasPrevPage ? this.state.source(this.state.prevToken) : Promise.reject(new Error('No previous page'));\n    }\n  }]);\n\n  return RestPaginator;\n}();\n\nvar SyncListDescriptor =\n/**\n * @param {Object} descriptor - sync list descriptor data object\n * @private\n */\nfunction SyncListDescriptor(descriptor) {\n  _classCallCheck__default['default'](this, SyncListDescriptor);\n\n  this.channel_sid = descriptor.channel_sid;\n  this.status = descriptor.status;\n  this.channel = descriptor.channel;\n  this.messages = descriptor.messages;\n  this.roster = descriptor.roster;\n  this.lastConsumedMessageIndex = descriptor.last_consumed_message_index;\n  this.notificationLevel = descriptor.notification_level;\n  this.descriptor = descriptor;\n};\n/**\n * Provides async pagination interface for sync list\n *\n * @property {Network} network Network transport\n * @property {string} syncListUrl Url to the sync list endpoint\n */\n\n\nvar SyncList = /*#__PURE__*/function () {\n  /**\n   * @param {SyncListServices} services - services needed for SyncList service\n   * @private\n   */\n  function SyncList(services) {\n    _classCallCheck__default['default'](this, SyncList);\n\n    this.services = services;\n  }\n\n  _createClass__default['default'](SyncList, [{\n    key: \"getPage\",\n    value: function () {\n      var _getPage = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(args) {\n        var _this = this;\n\n        var links, url, response;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                args = args || {};\n                _context.next = 3;\n                return this.services.session.getSessionLinks();\n\n              case 3:\n                links = _context.sent;\n                url = new UriBuilder(links.syncListUrl).arg('PageToken', args.pageToken).build();\n                _context.next = 7;\n                return this.services.network.get(url);\n\n              case 7:\n                response = _context.sent;\n                return _context.abrupt(\"return\", new RestPaginator(response.body.channels.map(function (x) {\n                  return new SyncListDescriptor(x);\n                }), function (pageToken) {\n                  return _this.getPage({\n                    pageToken: pageToken\n                  });\n                }, response.body.meta.previous_token, response.body.meta.next_token));\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getPage(_x) {\n        return _getPage.apply(this, arguments);\n      }\n\n      return getPage;\n    }()\n  }]);\n\n  return SyncList;\n}();\n\nvar ResponseCodes = function ResponseCodes() {\n  _classCallCheck__default['default'](this, ResponseCodes);\n};\n\n_defineProperty__default['default'](ResponseCodes, \"HTTP_200_OK\", 200);\n\n_defineProperty__default['default'](ResponseCodes, \"HTTP_400_BAD_REQUEST\", 400);\n\n_defineProperty__default['default'](ResponseCodes, \"HTTP_404_NOT_FOUND\", 404);\n\n_defineProperty__default['default'](ResponseCodes, \"ACCESS_FORBIDDEN_FOR_IDENTITY\", 54007);\n\n_defineProperty__default['default'](ResponseCodes, \"LIST_NOT_FOUND\", 54150);\n\nfunction _createSuper$9(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$9();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$9() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * @class\n * @classdesc Exception type for service-side errors.\n *\n * @property {Number} code - Error code\n * @property {String} message - Error description\n */\n\n\nvar SessionError = /*#__PURE__*/function (_Error) {\n  _inherits__default['default'](SessionError, _Error);\n\n  var _super = _createSuper$9(SessionError);\n\n  function SessionError(message, code) {\n    var _this;\n\n    _classCallCheck__default['default'](this, SessionError);\n\n    _this = _super.call(this);\n    _this.name = _this.constructor.name;\n    _this.message = message;\n    _this.code = code;\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(_assertThisInitialized__default['default'](_this), _this.constructor);\n    } else {\n      _this.stack = new Error().stack;\n    }\n\n    return _this;\n  }\n\n  return SessionError;\n}( /*#__PURE__*/_wrapNativeSuper__default['default'](Error));\n\nvar Deferred = /*#__PURE__*/function () {\n  function Deferred() {\n    var _this = this;\n\n    _classCallCheck__default['default'](this, Deferred);\n\n    this._promise = new Promise(function (resolve, reject) {\n      _this._resolve = resolve;\n      _this._reject = reject;\n    });\n  }\n\n  _createClass__default['default'](Deferred, [{\n    key: \"promise\",\n    get: function get() {\n      return this._promise;\n    }\n  }, {\n    key: \"update\",\n    value: function update(value) {\n      this._resolve(value);\n    }\n  }, {\n    key: \"set\",\n    value: function set(value) {\n      this.current = value;\n\n      this._resolve(value);\n    }\n  }, {\n    key: \"fail\",\n    value: function fail(e) {\n      this._reject(e);\n    }\n  }]);\n\n  return Deferred;\n}();\n\nvar version = \"1.2.1\";\nvar SDK_VERSION$1 = version;\nvar SESSION_PURPOSE = 'com.twilio.rtd.ipmsg';\nvar log$9 = Logger.scope('Session');\n\nvar Command = function Command() {\n  _classCallCheck__default['default'](this, Command);\n};\n\nfunction hasAllPropertiesSet(obj, properties) {\n  return !properties.some(function (prop) {\n    return !obj.hasOwnProperty(prop);\n  });\n}\n/**\n *  Constructs the instance of Session\n *\n *  @classdesc Provides the interface to send the command to the server\n *  It is reliable, which means that it tracks the command object state\n *  and waits the answer from the server.\n */\n\n\nvar Session = /*#__PURE__*/function () {\n  function Session(services, config) {\n    _classCallCheck__default['default'](this, Session);\n\n    var platformInfo = typeof navigator !== 'undefined' ? platform__namespace.parse(navigator.userAgent) : platform__namespace;\n    this.services = services;\n    this.config = config;\n    this.sessionInfo = new Deferred();\n    this.currentContext = {};\n    this.pendingCommands = new Map();\n    this.sessionStreamPromise = null;\n    this.endpointPlatform = ['JS', SDK_VERSION$1, platformInfo.os, platformInfo.name, platformInfo.version].join('|');\n  }\n\n  _createClass__default['default'](Session, [{\n    key: \"identity\",\n    get: function get() {\n      return this.sessionInfo.current.identity;\n    }\n  }, {\n    key: \"reachabilityEnabled\",\n    get: function get() {\n      return this.currentContext.reachabilityEnabled;\n    }\n  }, {\n    key: \"handleContextUpdate\",\n    value: function handleContextUpdate(updatedContext) {\n      log$9.info('Session context updated');\n      log$9.debug('new session context:', updatedContext);\n      this.currentContext = updatedContext;\n\n      if (!hasAllPropertiesSet(updatedContext, ['identity', 'userInfo', 'links', 'myChannels', 'channels'])) {\n        return; // not enough data to proceed, wait\n      }\n\n      log$9.info('new session context accepted');\n      this.sessionInfo.set(updatedContext);\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize() {\n      var _this = this;\n\n      var context = {\n        type: 'IpMsgSession',\n        apiVersion: '4',\n        endpointPlatform: this.endpointPlatform\n      };\n      this.sessionStreamPromise = this.services.syncClient.list({\n        purpose: SESSION_PURPOSE,\n        context: context\n      }).then(function (list) {\n        log$9.info('Session created', list.sid);\n        list.on('itemAdded', function (args) {\n          return _this.processCommandResponse(args.item);\n        });\n        list.on('itemUpdated', function (args) {\n          return _this.processCommandResponse(args.item);\n        });\n        list.on('contextUpdated', function (args) {\n          return _this.handleContextUpdate(args.context);\n        });\n        return list;\n      }).catch(function (err) {\n        log$9.error('Failed to create session', err);\n        throw err;\n      });\n      return this.sessionStreamPromise;\n    }\n    /**\n     * Sends the command to the server\n     * @returns Promise the promise, which is being fulfilled only when service will reply\n     */\n\n  }, {\n    key: \"addCommand\",\n    value: function addCommand(action, params) {\n      return this.processCommand(action, params);\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"processCommand\",\n    value: function processCommand(action, params) {\n      var _this2 = this;\n\n      var createSessionIfNotFound = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var command = new Command();\n      command.request = params;\n      command.request.action = action;\n      command.commandId = uuid__namespace.v4();\n      log$9.info('Adding command: ', action, command.commandId);\n      log$9.debug('command arguments:', params, createSessionIfNotFound);\n      return new Promise(function (resolve, reject) {\n        _this2.sessionStreamPromise.then(function (list) {\n          _this2.pendingCommands.set(command.commandId, {\n            resolve: resolve,\n            reject: reject,\n            commandId: command.commandId,\n            request: command.request\n          });\n\n          return list.push(command);\n        }).then(function () {\n          return log$9.debug('Command accepted by server', command.commandId);\n        }).catch(function (err) {\n          _this2.pendingCommands.delete(command.commandId);\n\n          log$9.error('Failed to add a command to the session', err);\n\n          if ((err.code == ResponseCodes.ACCESS_FORBIDDEN_FOR_IDENTITY || err.code === ResponseCodes.LIST_NOT_FOUND) && createSessionIfNotFound) {\n            log$9.info('recreating session...');\n\n            _this2.initialize();\n\n            resolve(_this2.processCommand(action, params, false)); // second attempt\n          } else {\n            reject(new Error('Can\\'t add command: ' + err.message));\n          }\n        });\n      });\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"processCommandResponse\",\n    value: function processCommandResponse(entity) {\n      if (entity.data.hasOwnProperty('response') && entity.data.hasOwnProperty('commandId') && this.pendingCommands.has(entity.data.commandId)) {\n        var data = entity.data;\n        var commandId = data.commandId;\n\n        if (data.response.status === ResponseCodes.HTTP_200_OK) {\n          log$9.debug('Command succeeded: ', data);\n          var resolve = this.pendingCommands.get(commandId).resolve;\n          this.pendingCommands.delete(commandId);\n          resolve(data.response);\n        } else {\n          log$9.error('Command failed: ', data);\n          var reject = this.pendingCommands.get(commandId).reject;\n          this.pendingCommands.delete(commandId);\n          reject(new SessionError(data.response.statusText, data.response.status));\n        }\n      }\n    }\n  }, {\n    key: \"getSessionContext\",\n    value: function getSessionContext() {\n      return this.sessionStreamPromise.then(function (stream) {\n        return stream.getContext();\n      });\n    }\n  }, {\n    key: \"getSessionLinks\",\n    value: function () {\n      var _getSessionLinks = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {\n        var info;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.sessionInfo.promise;\n\n              case 2:\n                info = _context.sent;\n                return _context.abrupt(\"return\", {\n                  publicChannelsUrl: this.config.baseUrl + info.links.publicChannelsUrl,\n                  myChannelsUrl: this.config.baseUrl + info.links.myChannelsUrl,\n                  typingUrl: this.config.baseUrl + info.links.typingUrl,\n                  syncListUrl: this.config.baseUrl + info.links.syncListUrl,\n                  usersUrl: this.config.baseUrl + info.links.usersUrl,\n                  mediaServiceUrl: info.links.mediaServiceUrl,\n                  messagesReceiptsUrl: this.config.baseUrl + info.links.messagesReceiptsUrl\n                });\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getSessionLinks() {\n        return _getSessionLinks.apply(this, arguments);\n      }\n\n      return getSessionLinks;\n    }()\n  }, {\n    key: \"getConversationsId\",\n    value: function () {\n      var _getConversationsId = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {\n        var info;\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.sessionInfo.promise;\n\n              case 2:\n                info = _context2.sent;\n                return _context2.abrupt(\"return\", info.channels);\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getConversationsId() {\n        return _getConversationsId.apply(this, arguments);\n      }\n\n      return getConversationsId;\n    }()\n  }, {\n    key: \"getMyConversationsId\",\n    value: function () {\n      var _getMyConversationsId = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3() {\n        var info;\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.sessionInfo.promise;\n\n              case 2:\n                info = _context3.sent;\n                return _context3.abrupt(\"return\", info.myChannels);\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getMyConversationsId() {\n        return _getMyConversationsId.apply(this, arguments);\n      }\n\n      return getMyConversationsId;\n    }()\n  }, {\n    key: \"getMaxUserInfosToSubscribe\",\n    value: function () {\n      var _getMaxUserInfosToSubscribe = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4() {\n        var info;\n        return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.sessionInfo.promise;\n\n              case 2:\n                info = _context4.sent;\n                return _context4.abrupt(\"return\", this.config.userInfosToSubscribeOverride || info.userInfosToSubscribe || this.config.userInfosToSubscribeDefault);\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getMaxUserInfosToSubscribe() {\n        return _getMaxUserInfosToSubscribe.apply(this, arguments);\n      }\n\n      return getMaxUserInfosToSubscribe;\n    }()\n  }, {\n    key: \"getUsersData\",\n    value: function getUsersData() {\n      return this.sessionInfo.promise.then(function (info) {\n        return {\n          user: info.userInfo,\n          identity: info.identity\n        };\n      });\n    }\n  }, {\n    key: \"getConsumptionReportInterval\",\n    value: function () {\n      var _getConsumptionReportInterval = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee5() {\n        var context, consumptionIntervalToUse;\n        return _regeneratorRuntime__default['default'].wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.getSessionContext();\n\n              case 2:\n                context = _context5.sent;\n                consumptionIntervalToUse = this.config.consumptionReportIntervalOverride || context.consumptionReportInterval || this.config.consumptionReportIntervalDefault;\n                _context5.prev = 4;\n                return _context5.abrupt(\"return\", iso8601Duration.toSeconds(iso8601Duration.parse(consumptionIntervalToUse)));\n\n              case 8:\n                _context5.prev = 8;\n                _context5.t0 = _context5[\"catch\"](4);\n                log$9.error('Failed to parse consumption report interval', consumptionIntervalToUse, 'using default value', this.config.consumptionReportIntervalDefault);\n                return _context5.abrupt(\"return\", iso8601Duration.toSeconds(iso8601Duration.parse(this.config.consumptionReportIntervalDefault)));\n\n              case 12:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[4, 8]]);\n      }));\n\n      function getConsumptionReportInterval() {\n        return _getConsumptionReportInterval.apply(this, arguments);\n      }\n\n      return getConsumptionReportInterval;\n    }()\n  }, {\n    key: \"getHttpCacheInterval\",\n    value: function () {\n      var _getHttpCacheInterval = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee6() {\n        var context, cacheIntervalToUse;\n        return _regeneratorRuntime__default['default'].wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.getSessionContext();\n\n              case 2:\n                context = _context6.sent;\n                cacheIntervalToUse = this.config.httpCacheIntervalOverride || context.httpCacheInterval || this.config.httpCacheIntervalDefault;\n                _context6.prev = 4;\n                return _context6.abrupt(\"return\", iso8601Duration.toSeconds(iso8601Duration.parse(cacheIntervalToUse)));\n\n              case 8:\n                _context6.prev = 8;\n                _context6.t0 = _context6[\"catch\"](4);\n                log$9.error('Failed to parse cache interval', cacheIntervalToUse, 'using default value', this.config.httpCacheIntervalDefault);\n                return _context6.abrupt(\"return\", iso8601Duration.toSeconds(iso8601Duration.parse(this.config.httpCacheIntervalDefault)));\n\n              case 12:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[4, 8]]);\n      }));\n\n      function getHttpCacheInterval() {\n        return _getHttpCacheInterval.apply(this, arguments);\n      }\n\n      return getHttpCacheInterval;\n    }()\n  }]);\n\n  return Session;\n}();\n\nfunction _createSuper$8(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$8();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$8() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar log$8 = Logger.scope('Participant');\n/**\n * @classdesc A Participant represents a remote Client in a Conversation.\n * @property {any} attributes - Object with custom attributes for Participant\n * @property {Conversation} conversation - The Conversation the remote Client is a Participant of\n * @property {Date} dateCreated - The Date this Participant was created\n * @property {Date} dateUpdated - The Date this Participant was last updated\n * @property {String} identity - The identity of the remote Client\n * @property {Boolean} isTyping - Whether or not this Participant is currently typing\n   * @property {Number|null} lastReadMessageIndex - Latest read Message index by this Participant.\n * Note that just retrieving messages on a client endpoint does not mean that messages are read,\n * please consider reading about [Read Horizon feature]{@link https://www.twilio.com/docs/api/chat/guides/consumption-horizon}\n * to find out how to mark messages as read.\n * @property {Date} lastReadTimestamp - Date when Participant has updated his read horizon\n * @property {String} sid - The server-assigned unique identifier for the Participant\n * @property {Participant#Type} type - The type of Participant\n * @fires Participant#typingEnded\n * @fires Participant#typingStarted\n * @fires Participant#updated\n */\n\nvar Participant = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](Participant, _EventEmitter);\n\n  var _super = _createSuper$8(Participant);\n  /**\n   * The update reason for <code>updated</code> event emitted on Participant\n   * @typedef {('attributes' | 'dateCreated' | 'dateUpdated' | 'roleSid' |\n    'lastReadMessageIndex' | 'lastReadTimestamp')} Participant#UpdateReason\n   */\n\n  /**\n   * The type of Participant\n   * @typedef {('chat' | 'sms' | 'whatsapp')} Participant#Type\n   */\n\n\n  function Participant(services, conversation, data, sid) {\n    var _this;\n\n    _classCallCheck__default['default'](this, Participant);\n\n    _this = _super.call(this);\n    _this.conversation = conversation;\n    _this.services = services;\n    _this.state = {\n      attributes: parseAttributes(data.attributes, 'Retrieved malformed attributes from the server for participant: ' + sid, log$8),\n      dateCreated: data.dateCreated ? parseTime$1(data.dateCreated) : null,\n      dateUpdated: data.dateCreated ? parseTime$1(data.dateUpdated) : null,\n      sid: sid,\n      typingTimeout: null,\n      isTyping: false,\n      identity: data.identity || null,\n      roleSid: data.roleSid || null,\n      lastReadMessageIndex: Number.isInteger(data.lastConsumedMessageIndex) ? data.lastConsumedMessageIndex : null,\n      lastReadTimestamp: data.lastConsumptionTimestamp ? parseTime$1(data.lastConsumptionTimestamp) : null,\n      type: data.type || 'chat',\n      userInfo: data.userInfo\n    };\n\n    if (!data.identity && !data.type) {\n      throw new Error('Received invalid Participant object from server: Missing identity or type of Participant.');\n    }\n\n    return _this;\n  }\n  /**\n   * Private method used to start or reset the typing indicator timeout (with event emitting)\n   * @private\n   */\n\n\n  _createClass__default['default'](Participant, [{\n    key: \"sid\",\n    get: function get() {\n      return this.state.sid;\n    }\n  }, {\n    key: \"attributes\",\n    get: function get() {\n      return this.state.attributes;\n    }\n  }, {\n    key: \"dateCreated\",\n    get: function get() {\n      return this.state.dateCreated;\n    }\n  }, {\n    key: \"dateUpdated\",\n    get: function get() {\n      return this.state.dateUpdated;\n    }\n  }, {\n    key: \"identity\",\n    get: function get() {\n      return this.state.identity;\n    }\n  }, {\n    key: \"isTyping\",\n    get: function get() {\n      return this.state.isTyping;\n    }\n  }, {\n    key: \"lastReadMessageIndex\",\n    get: function get() {\n      return this.state.lastReadMessageIndex;\n    }\n  }, {\n    key: \"lastReadTimestamp\",\n    get: function get() {\n      return this.state.lastReadTimestamp;\n    }\n  }, {\n    key: \"roleSid\",\n    get: function get() {\n      return this.state.roleSid;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this.state.type;\n    }\n  }, {\n    key: \"_startTyping\",\n    value: function _startTyping(timeout) {\n      var _this2 = this;\n\n      clearTimeout(this.state.typingTimeout);\n      this.state.isTyping = true;\n      this.emit('typingStarted', this);\n      this.conversation.emit('typingStarted', this);\n      this.state.typingTimeout = setTimeout(function () {\n        return _this2._endTyping();\n      }, timeout);\n      return this;\n    }\n    /**\n     * Private method function used to stop typing indicator (with event emitting)\n     * @private\n     */\n\n  }, {\n    key: \"_endTyping\",\n    value: function _endTyping() {\n      if (!this.state.typingTimeout) {\n        return;\n      }\n\n      this.state.isTyping = false;\n      this.emit('typingEnded', this);\n      this.conversation.emit('typingEnded', this);\n      clearInterval(this.state.typingTimeout);\n      this.state.typingTimeout = null;\n    }\n    /**\n     * Private method function used update local object's property roleSid with new value\n     * @private\n     */\n\n  }, {\n    key: \"_update\",\n    value: function _update(data) {\n      var updateReasons = [];\n      var updateAttributes = parseAttributes(data.attributes, 'Retrieved malformed attributes from the server for participant: ' + this.state.sid, log$8);\n\n      if (data.attributes && !isDeepEqual(this.state.attributes, updateAttributes)) {\n        this.state.attributes = updateAttributes;\n        updateReasons.push('attributes');\n      }\n\n      var updatedDateUpdated = parseTime$1(data.dateUpdated);\n\n      if (data.dateUpdated && updatedDateUpdated.getTime() !== (this.state.dateUpdated && this.state.dateUpdated.getTime())) {\n        this.state.dateUpdated = updatedDateUpdated;\n        updateReasons.push('dateUpdated');\n      }\n\n      var updatedDateCreated = parseTime$1(data.dateCreated);\n\n      if (data.dateCreated && updatedDateCreated.getTime() !== (this.state.dateCreated && this.state.dateCreated.getTime())) {\n        this.state.dateCreated = updatedDateCreated;\n        updateReasons.push('dateCreated');\n      }\n\n      if (data.roleSid && this.state.roleSid !== data.roleSid) {\n        this.state.roleSid = data.roleSid;\n        updateReasons.push('roleSid');\n      }\n\n      if ((Number.isInteger(data.lastConsumedMessageIndex) || data.lastConsumedMessageIndex === null) && this.state.lastReadMessageIndex !== data.lastConsumedMessageIndex) {\n        this.state.lastReadMessageIndex = data.lastConsumedMessageIndex;\n        updateReasons.push('lastReadMessageIndex');\n      }\n\n      if (data.lastConsumptionTimestamp) {\n        var lastReadTimestamp = new Date(data.lastConsumptionTimestamp);\n\n        if (!this.state.lastReadTimestamp || this.state.lastReadTimestamp.getTime() !== lastReadTimestamp.getTime()) {\n          this.state.lastReadTimestamp = lastReadTimestamp;\n          updateReasons.push('lastReadTimestamp');\n        }\n      }\n\n      if (updateReasons.length > 0) {\n        this.emit('updated', {\n          participant: this,\n          updateReasons: updateReasons\n        });\n      }\n\n      return this;\n    }\n    /**\n     * Gets User for this participant and subscribes to it. Supported only for <code>chat</code> type of Participants\n     * @returns {Promise<User>}\n     */\n\n  }, {\n    key: \"getUser\",\n    value: function () {\n      var _getUser = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this.type != 'chat')) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error('Getting User is not supported for this Participant type: ' + this.type);\n\n              case 2:\n                return _context.abrupt(\"return\", this.services.users.getUser(this.state.identity, this.state.userInfo));\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getUser() {\n        return _getUser.apply(this, arguments);\n      }\n\n      return getUser;\n    }()\n    /**\n     * Remove Participant from the Conversation.\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function () {\n      var _remove = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", this.conversation.removeParticipant(this));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function remove() {\n        return _remove.apply(this, arguments);\n      }\n\n      return remove;\n    }()\n    /**\n     * Edit participant attributes.\n     * @param {any} attributes new attributes for Participant.\n     * @returns {Promise<Participant>}\n     */\n\n  }, {\n    key: \"updateAttributes\",\n    value: function () {\n      var _updateAttributes = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(attributes) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.services.session.addCommand('editMemberAttributes', {\n                  channelSid: this.conversation.sid,\n                  memberSid: this.sid,\n                  attributes: JSON.stringify(attributes)\n                });\n\n              case 2:\n                return _context3.abrupt(\"return\", this);\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function updateAttributes(_x) {\n        return _updateAttributes.apply(this, arguments);\n      }\n\n      return updateAttributes;\n    }()\n  }]);\n\n  return Participant;\n}(EventEmitter);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(['string', 'number', 'boolean', 'object', twilioSdkTypeValidator.literal(null)]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Promise)], Participant.prototype, \"updateAttributes\", null);\n/**\n * Fired when Participant started to type.\n * @event Participant#typingStarted\n * @type {Participant}\n */\n\n/**\n * Fired when Participant ended to type.\n * @event Participant#typingEnded\n * @type {Participant}\n */\n\n/**\n * Fired when Participant's fields has been updated.\n * @event Participant#updated\n * @type {Object}\n * @property {Participant} participant - Updated Participant\n * @property {Participant#UpdateReason[]} updateReasons - Array of Participant's updated event reasons\n */\n\n\nfunction _createSuper$7(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$7();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$7() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar log$7 = Logger.scope('Participants');\n/**\n * @classdesc Represents the collection of participants for the conversation\n * @fires Participants#participantJoined\n * @fires Participants#participantLeft\n * @fires Participants#participantUpdated\n */\n\nvar Participants = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](Participants, _EventEmitter);\n\n  var _super = _createSuper$7(Participants);\n\n  function Participants(conversation, services, participants) {\n    var _this;\n\n    _classCallCheck__default['default'](this, Participants);\n\n    _this = _super.call(this);\n    _this.services = services;\n    _this.conversation = conversation;\n    _this.participants = participants;\n    return _this;\n  }\n\n  _createClass__default['default'](Participants, [{\n    key: \"unsubscribe\",\n    value: function () {\n      var _unsubscribe = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {\n        var entity;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.rosterEntityPromise) {\n                  _context.next = 6;\n                  break;\n                }\n\n                _context.next = 3;\n                return this.rosterEntityPromise;\n\n              case 3:\n                entity = _context.sent;\n                entity.close();\n                this.rosterEntityPromise = null;\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function unsubscribe() {\n        return _unsubscribe.apply(this, arguments);\n      }\n\n      return unsubscribe;\n    }()\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(rosterObjectName) {\n      var _this2 = this;\n\n      return this.rosterEntityPromise = this.rosterEntityPromise || this.services.syncClient.map({\n        id: rosterObjectName,\n        mode: 'open_existing'\n      }).then(function (rosterMap) {\n        rosterMap.on('itemAdded', function (args) {\n          log$7.debug(_this2.conversation.sid + ' itemAdded: ' + args.item.key);\n\n          _this2.upsertParticipant(args.item.key, args.item.data).then(function (participant) {\n            _this2.emit('participantJoined', participant);\n          });\n        });\n        rosterMap.on('itemRemoved', function (args) {\n          log$7.debug(_this2.conversation.sid + ' itemRemoved: ' + args.key);\n          var participantSid = args.key;\n\n          if (!_this2.participants.has(participantSid)) {\n            return;\n          }\n\n          var leftParticipant = _this2.participants.get(participantSid);\n\n          _this2.participants.delete(participantSid);\n\n          _this2.emit('participantLeft', leftParticipant);\n        });\n        rosterMap.on('itemUpdated', function (args) {\n          log$7.debug(_this2.conversation.sid + ' itemUpdated: ' + args.item.key);\n\n          _this2.upsertParticipant(args.item.key, args.item.data);\n        });\n        var participantsPromises = [];\n        var that = _this2;\n\n        var rosterMapHandler = function rosterMapHandler(paginator) {\n          paginator.items.forEach(function (item) {\n            participantsPromises.push(that.upsertParticipant(item.key, item.data));\n          });\n          return paginator.hasNextPage ? paginator.nextPage().then(rosterMapHandler) : null;\n        };\n\n        return rosterMap.getItems().then(rosterMapHandler).then(function () {\n          return Promise.all(participantsPromises);\n        }).then(function () {\n          return rosterMap;\n        });\n      }).catch(function (err) {\n        _this2.rosterEntityPromise = null;\n\n        if (_this2.services.syncClient.connectionState != 'disconnected') {\n          log$7.error('Failed to get roster object for conversation', _this2.conversation.sid, err);\n        }\n\n        log$7.debug('ERROR: Failed to get roster object for conversation', _this2.conversation.sid, err);\n        throw err;\n      });\n    }\n  }, {\n    key: \"upsertParticipant\",\n    value: function () {\n      var _upsertParticipant = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(participantSid, data) {\n        var _this3 = this;\n\n        var participant;\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                participant = this.participants.get(participantSid);\n\n                if (!participant) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", participant._update(data));\n\n              case 3:\n                participant = new Participant(this.services, this.conversation, data, participantSid);\n                this.participants.set(participantSid, participant);\n                participant.on('updated', function (args) {\n                  return _this3.emit('participantUpdated', args);\n                });\n                return _context2.abrupt(\"return\", participant);\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function upsertParticipant(_x, _x2) {\n        return _upsertParticipant.apply(this, arguments);\n      }\n\n      return upsertParticipant;\n    }()\n    /**\n     * @returns {Promise<Array<Participant>>} returns list of participants {@see Participant}\n     */\n\n  }, {\n    key: \"getParticipants\",\n    value: function getParticipants() {\n      var _this4 = this;\n\n      return this.rosterEntityPromise.then(function () {\n        var participants = [];\n\n        _this4.participants.forEach(function (participant) {\n          return participants.push(participant);\n        });\n\n        return participants;\n      });\n    }\n    /**\n     * Get participant by SID from conversation\n     * @returns {Promise<Participant>}\n     */\n\n  }, {\n    key: \"getParticipantBySid\",\n    value: function () {\n      var _getParticipantBySid = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(participantSid) {\n        var _this5 = this;\n\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", this.rosterEntityPromise.then(function () {\n                  var participant = _this5.participants.get(participantSid);\n\n                  if (!participant) {\n                    throw new Error('Participant with SID ' + participantSid + ' was not found');\n                  }\n\n                  return participant;\n                }));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getParticipantBySid(_x3) {\n        return _getParticipantBySid.apply(this, arguments);\n      }\n\n      return getParticipantBySid;\n    }()\n    /**\n     * Get participant by identity from conversation\n     * @returns {Promise<Participant>}\n     */\n\n  }, {\n    key: \"getParticipantByIdentity\",\n    value: function () {\n      var _getParticipantByIdentity = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4(identity) {\n        var _this6 = this;\n\n        var foundParticipant;\n        return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                foundParticipant = null;\n                return _context4.abrupt(\"return\", this.rosterEntityPromise.then(function () {\n                  _this6.participants.forEach(function (participant) {\n                    if (participant.identity === identity) {\n                      foundParticipant = participant;\n                    }\n                  });\n\n                  if (!foundParticipant) {\n                    throw new Error('Participant with identity ' + identity + ' was not found');\n                  }\n\n                  return foundParticipant;\n                }));\n\n              case 2:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getParticipantByIdentity(_x4) {\n        return _getParticipantByIdentity.apply(this, arguments);\n      }\n\n      return getParticipantByIdentity;\n    }()\n    /**\n     * Add a chat participant to the conversation\n     * @returns {Promise<any>}\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(identity, attributes) {\n      return this.services.session.addCommand('addMemberV2', {\n        channelSid: this.conversation.sid,\n        attributes: JSON.stringify(attributes),\n        username: identity\n      });\n    }\n    /**\n     * Add a non-chat participant to the conversation.\n     *\n     * @param proxyAddress\n     * @param address\n     * @param attributes\n     * @returns {Promise<any>}\n     */\n\n  }, {\n    key: \"addNonChatParticipant\",\n    value: function addNonChatParticipant(proxyAddress, address) {\n      var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this.services.session.addCommand('addNonChatParticipant', {\n        conversationSid: this.conversation.sid,\n        proxyAddress: proxyAddress,\n        attributes: JSON.stringify(attributes),\n        address: address\n      });\n    }\n    /**\n     * Invites user to the conversation\n     * User can choose either to join or not\n     * @returns {Promise<any>}\n     */\n\n  }, {\n    key: \"invite\",\n    value: function invite(identity) {\n      return this.services.session.addCommand('inviteMember', {\n        channelSid: this.conversation.sid,\n        username: identity\n      });\n    }\n    /**\n     * Remove participant from conversation by Identity\n     * @returns {Promise<any>}\n     */\n\n  }, {\n    key: \"removeByIdentity\",\n    value: function removeByIdentity(identity) {\n      return this.services.session.addCommand('removeMember', {\n        channelSid: this.conversation.sid,\n        username: identity\n      });\n    }\n    /**\n     * Remove participant from conversation by sid\n     * @returns {Promise<any>}\n     */\n\n  }, {\n    key: \"removeBySid\",\n    value: function removeBySid(sid) {\n      return this.services.session.addCommand('removeMember', {\n        channelSid: this.conversation.sid,\n        memberSid: sid\n      });\n    }\n  }]);\n\n  return Participants;\n}(EventEmitter);\n/**\n * Fired when participant joined conversation\n * @event Participants#participantJoined\n * @type {Participant}\n */\n\n/**\n * Fired when participant left conversation\n * @event Participants#participantLeft\n * @type {Participant}\n */\n\n/**\n * Fired when participant updated\n * @event Participants#participantUpdated\n * @type {Object}\n * @property {Participant} participant - Updated Participant\n * @property {Participant#UpdateReason[]} updateReasons - Array of Participant's updated event reasons\n */\n\n/**\n * @classdesc A Media represents a media information for Message in a Conversation.\n * @property {String} contentType - content type of media\n * @property {String} sid - The server-assigned unique identifier for Media\n * @property {Number} size - Size of media, bytes\n * @property {String} [filename] - file name if present, null otherwise\n */\n\n\nvar Media = /*#__PURE__*/function () {\n  function Media(data, services) {\n    _classCallCheck__default['default'](this, Media);\n\n    _defineProperty__default['default'](this, \"mcsMedia\", null);\n\n    this.services = services;\n    this.state = {\n      sid: data.sid,\n      filename: data.filename,\n      contentType: data.contentType,\n      size: data.size\n    };\n  }\n\n  _createClass__default['default'](Media, [{\n    key: \"sid\",\n    get: function get() {\n      return this.state.sid;\n    }\n  }, {\n    key: \"filename\",\n    get: function get() {\n      return this.state.filename;\n    }\n  }, {\n    key: \"contentType\",\n    get: function get() {\n      return this.state.contentType;\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.state.size;\n    }\n    /**\n     * Returns direct content URL for the media.\n     *\n     * This URL is impermanent, it will expire in several minutes and cannot be cached.\n     * If the URL becomes expired, you need to request a new one.\n     * Each call to this function produces a new temporary URL.\n     *\n     * @returns {Promise<String>}\n     */\n\n  }, {\n    key: \"getContentTemporaryUrl\",\n    value: function () {\n      var _getContentTemporaryUrl = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.mcsMedia) {\n                  _context.next = 8;\n                  break;\n                }\n\n                if (!this.services.mcsClient) {\n                  _context.next = 7;\n                  break;\n                }\n\n                _context.next = 4;\n                return this.services.mcsClient.get(this.state.sid);\n\n              case 4:\n                this.mcsMedia = _context.sent;\n                _context.next = 8;\n                break;\n\n              case 7:\n                throw new Error('Media Content Service is unavailable');\n\n              case 8:\n                return _context.abrupt(\"return\", this.mcsMedia.getContentUrl());\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getContentTemporaryUrl() {\n        return _getContentTemporaryUrl.apply(this, arguments);\n      }\n\n      return getContentTemporaryUrl;\n    }()\n  }]);\n\n  return Media;\n}();\n/**\n * @classdesc Contains aggregated information about a {@link Message}'s delivery statuses across all {@link Participant}s\n * of a {@link Conversation}.\n *\n * At any moment during delivering message to a {@link Participant} the message can have zero or more of following\n * delivery statuses:\n *\n * <ul><li>\n * Message considered as <b>sent</b> to a participant, if the nearest upstream carrier accepted the message.\n * </li><li>\n * Message considered as <b>delivered</b> to a participant, if Twilio has received confirmation of message\n * delivery from the upstream carrier, and, where available, the destination handset.\n * </li><li>\n * Message considered as <b>undelivered</b> to a participant, if Twilio has received a delivery receipt\n * indicating that the message was not delivered. This can happen for many reasons including carrier content\n * filtering and the availability of the destination handset.\n * </li><li>\n * Message considered as <b>read</b> by a participant, if the message has been delivered and opened by the\n * recipient in the conversation. The recipient must have enabled read receipts.\n * </li><li>\n * Message considered as <b>failed</b> to be delivered to a participant if the message could not be sent.\n * This can happen for various reasons including queue overflows, account suspensions and media\n * errors (in the case of MMS for instance).\n *</li></ul>\n *\n * {@link AggregatedDeliveryReceipt} class contains aggregated value {@link AggregatedDeliveryReceipt#DeliveryAmount} for each delivery status.\n *\n * @property {number} total - Maximum number of delivery events expected for the message\n * @property {AggregatedDeliveryReceipt#DeliveryAmount} sent - Amount of participants that have <b>sent</b> delivery status for the message.\n * @property {AggregatedDeliveryReceipt#DeliveryAmount} delivered - Amount of participants that have <b>delivered</b> delivery status\n *   for the message.\n * @property {AggregatedDeliveryReceipt#DeliveryAmount} read - Amount of participants that have <b>read</b> delivery status for the message.\n * @property {AggregatedDeliveryReceipt#DeliveryAmount} undelivered - Amount of participants that have <b>undelivered</b> delivery status\n *   for the message.\n * @property {AggregatedDeliveryReceipt#DeliveryAmount} failed - Amount of participants that have <b>failed</b> delivery status for the message.\n */\n\n\nvar AggregatedDeliveryReceipt = /*#__PURE__*/function () {\n  /**\n   * Signifies amount of participants which have the status for the message.\n   * @typedef {('none'|'some'|'all')} AggregatedDeliveryReceipt#DeliveryAmount\n   */\n  function AggregatedDeliveryReceipt(data) {\n    _classCallCheck__default['default'](this, AggregatedDeliveryReceipt);\n\n    this.state = data;\n  }\n  /**\n   * @return Maximum number of delivery events expected for the message.\n   */\n\n\n  _createClass__default['default'](AggregatedDeliveryReceipt, [{\n    key: \"total\",\n    get: function get() {\n      return this.state.total;\n    }\n    /**\n     * Message considered as <b>sent</b> to a participant, if the nearest upstream carrier accepted the message.\n     *\n     * @return {@link DeliveryAmount} of participants that have <b>sent</b> delivery status for the message.\n     */\n\n  }, {\n    key: \"sent\",\n    get: function get() {\n      return this.state.sent;\n    }\n    /**\n     * Message considered as <b>delivered</b> to a participant, if Twilio has received confirmation of message\n     * delivery from the upstream carrier, and, where available, the destination handset.\n     *\n     * @return {@link DeliveryAmount} of participants that have <b>delivered</b> delivery status for the message.\n     */\n\n  }, {\n    key: \"delivered\",\n    get: function get() {\n      return this.state.delivered;\n    }\n    /**\n     * Message considered as <b>read</b> by a participant, if the message has been delivered and opened by the\n     * recipient in the conversation. The recipient must have enabled read receipts.\n     *\n     * @return {@link DeliveryAmount} of participants that have <b>read</b> delivery status for the message.\n     */\n\n  }, {\n    key: \"read\",\n    get: function get() {\n      return this.state.read;\n    }\n    /**\n     * Message considered as <b>undelivered</b> to a participant, if Twilio has received a delivery receipt\n     * indicating that the message was not delivered. This can happen for many reasons including carrier content\n     * filtering and the availability of the destination handset.\n     *\n     * @return {@link DeliveryAmount} of participants that have <b>undelivered</b> delivery status for the message.\n     */\n\n  }, {\n    key: \"undelivered\",\n    get: function get() {\n      return this.state.undelivered;\n    }\n    /**\n     * Message considered as <b>failed</b> to be delivered to a participant if the message could not be sent.\n     * This can happen for various reasons including queue overflows, account suspensions and media\n     * errors (in the case of MMS for instance). Twilio does not charge you for failed messages.\n     *\n     * @return {@link DeliveryAmount} of participants that have <b>failed</b> delivery status for the message.\n     */\n\n  }, {\n    key: \"failed\",\n    get: function get() {\n      return this.state.failed;\n    }\n  }, {\n    key: \"_update\",\n    value: function _update(data) {\n      this.state = data;\n    }\n  }, {\n    key: \"_isEquals\",\n    value: function _isEquals(data) {\n      var isTotalSame = this.total === data.total;\n      var isSentSame = this.sent === data.sent;\n      var isDeliveredSame = this.delivered === data.delivered;\n      var isReadSame = this.read === data.read;\n      var isUndeliveredSame = this.undelivered === data.undelivered;\n      var isFailedSame = this.failed === data.failed;\n      return isTotalSame && isSentSame && isDeliveredSame && isReadSame && isUndeliveredSame && isFailedSame;\n    }\n  }]);\n\n  return AggregatedDeliveryReceipt;\n}();\n/**\n * @classdesc Represents a delivery receipt of a {@link Message}.\n *\n * @property {String} sid - The unique identifier for Delivery Receipt\n * @property {String} messageSid - The unique identifier for Conversation Message\n * @property {String} conversationSid - The unique identifier for Conversation\n * @property {String} channelMessageSid - The unique identifier for the â€˜channelâ€™ message e.g WAxx for Whatsapp, SMxx for SMS\n * @property {String} participantSid - Participant's unique identifier\n * @property {DetailedDeliveryReceipt#Status} status - Message delivery status\n * @property {number | null} errorCode - Numeric error code mapped from Status callback code. Information about the error codes can be found\n * <a href=\"https://www.twilio.com/docs/sms/api/message-resource#delivery-related-errors\">here</a>.\n * @property {String} dateCreated - When Delivery Receipt was created\n * @property {String} dateUpdated - When Delivery Receipt was updated\n */\n\n\nvar DetailedDeliveryReceipt =\n/**\n * Signifies the message delivery status.\n * @typedef {('sent'|'delivered'|'failed'|'read'|'undelivered'|'queued')} DetailedDeliveryReceipt#Status\n */\nfunction DetailedDeliveryReceipt(descriptor) {\n  _classCallCheck__default['default'](this, DetailedDeliveryReceipt);\n\n  this.sid = descriptor.sid;\n  this.messageSid = descriptor.message_sid;\n  this.conversationSid = descriptor.conversation_sid;\n  this.channelMessageSid = descriptor.channel_message_sid;\n  this.participantSid = descriptor.participant_sid;\n  this.status = descriptor.status || 'queued';\n  this.errorCode = descriptor.error_code || 0;\n  this.dateCreated = descriptor.date_created;\n  this.dateUpdated = descriptor.date_updated;\n};\n\nfunction _createSuper$6(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$6() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar log$6 = Logger.scope('Message');\n/**\n * @classdesc A Message represents a Message in a Conversation.\n * @property {String} author - The name of the user that sent Message\n * @property {String|null} subject - Message subject. Used only in email conversations\n * @property {String} body - The body of the Message. Is null if Message is Media Message\n * @property {any} attributes - Message custom attributes\n * @property {Conversation} conversation - Conversation Message belongs to\n * @property {Date} dateCreated - When Message was created\n * @property {Date} dateUpdated - When Message was updated\n * @property {Number} index - Index of Message in the Conversation's messages list\n *  By design of the conversations system the message indices may have arbitrary gaps between them,\n *  that does not necessarily mean they were deleted or otherwise modified - just that\n *  messages may have non-contiguous indices even if they are sent immediately one after another.\n *\n *  Trying to use indices for some calculations is going to be unreliable.\n *\n *  To calculate the number of unread messages it is better to use the read horizon API.\n *  See {@link Conversation#getUnreadMessagesCount} for details.\n *\n * @property {String} lastUpdatedBy - Identity of the last user that updated Message\n * @property {Media} media - Contains Media information (if present)\n * @property {String} participantSid - Authoring Participant's server-assigned unique identifier\n * @property {String} sid - The server-assigned unique identifier for Message\n * @property {'text' | 'media'} type - Type of message: 'text' or 'media'\n * @property {AggregatedDeliveryReceipt | null} aggregatedDeliveryReceipt - Aggregated information about\n *   Message delivery statuses across all {@link Participant}s of a {@link Conversation}.\n * @fires Message#updated\n */\n\nvar Message = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](Message, _EventEmitter);\n\n  var _super = _createSuper$6(Message);\n  /**\n   * The update reason for <code>updated</code> event emitted on Message\n   * @typedef {('body' | 'lastUpdatedBy' | 'dateCreated' | 'dateUpdated' | 'attributes' | 'author' |\n   *   'deliveryReceipt' | 'subject')} Message#UpdateReason\n   */\n\n\n  function Message(conversation, services, index, data) {\n    var _this;\n\n    _classCallCheck__default['default'](this, Message);\n\n    _this = _super.call(this);\n    _this.conversation = conversation;\n    _this.services = services;\n    _this.state = {\n      sid: data.sid,\n      index: index,\n      author: data.author == null ? null : data.author,\n      subject: data.subject == null ? null : data.subject,\n      body: data.text,\n      timestamp: data.timestamp ? new Date(data.timestamp) : null,\n      dateUpdated: data.dateUpdated ? new Date(data.dateUpdated) : null,\n      lastUpdatedBy: data.lastUpdatedBy ? data.lastUpdatedBy : null,\n      attributes: parseAttributes(data.attributes, \"Got malformed attributes for the message \".concat(data.sid), log$6),\n      type: data.type ? data.type : 'text',\n      media: data.type && data.type === 'media' && data.media ? new Media(data.media, _this.services) : null,\n      participantSid: data.memberSid == null ? null : data.memberSid,\n      aggregatedDeliveryReceipt: data.delivery ? new AggregatedDeliveryReceipt(data.delivery) : null\n    };\n    return _this;\n  }\n\n  _createClass__default['default'](Message, [{\n    key: \"sid\",\n    get: function get() {\n      return this.state.sid;\n    }\n  }, {\n    key: \"author\",\n    get: function get() {\n      return this.state.author;\n    }\n  }, {\n    key: \"subject\",\n    get: function get() {\n      return this.state.subject;\n    }\n  }, {\n    key: \"body\",\n    get: function get() {\n      if (this.type === 'media') {\n        return null;\n      }\n\n      return this.state.body;\n    }\n  }, {\n    key: \"dateUpdated\",\n    get: function get() {\n      return this.state.dateUpdated;\n    }\n  }, {\n    key: \"index\",\n    get: function get() {\n      return this.state.index;\n    }\n  }, {\n    key: \"lastUpdatedBy\",\n    get: function get() {\n      return this.state.lastUpdatedBy;\n    }\n  }, {\n    key: \"dateCreated\",\n    get: function get() {\n      return this.state.timestamp;\n    }\n  }, {\n    key: \"attributes\",\n    get: function get() {\n      return this.state.attributes;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this.state.type;\n    }\n  }, {\n    key: \"media\",\n    get: function get() {\n      return this.state.media;\n    }\n  }, {\n    key: \"participantSid\",\n    get: function get() {\n      return this.state.participantSid;\n    }\n  }, {\n    key: \"aggregatedDeliveryReceipt\",\n    get: function get() {\n      return this.state.aggregatedDeliveryReceipt;\n    }\n  }, {\n    key: \"_update\",\n    value: function _update(data) {\n      var updateReasons = [];\n\n      if ((data.text || typeof data.text === 'string') && data.text !== this.state.body) {\n        this.state.body = data.text;\n        updateReasons.push('body');\n      }\n\n      if (data.subject && data.subject !== this.state.subject) {\n        this.state.subject = data.subject;\n        updateReasons.push('subject');\n      }\n\n      if (data.lastUpdatedBy && data.lastUpdatedBy !== this.state.lastUpdatedBy) {\n        this.state.lastUpdatedBy = data.lastUpdatedBy;\n        updateReasons.push('lastUpdatedBy');\n      }\n\n      if (data.author && data.author !== this.state.author) {\n        this.state.author = data.author;\n        updateReasons.push('author');\n      }\n\n      if (data.dateUpdated && new Date(data.dateUpdated).getTime() !== (this.state.dateUpdated && this.state.dateUpdated.getTime())) {\n        this.state.dateUpdated = new Date(data.dateUpdated);\n        updateReasons.push('dateUpdated');\n      }\n\n      if (data.timestamp && new Date(data.timestamp).getTime() !== (this.state.timestamp && this.state.timestamp.getTime())) {\n        this.state.timestamp = new Date(data.timestamp);\n        updateReasons.push('dateCreated');\n      }\n\n      var updatedAttributes = parseAttributes(data.attributes, \"Got malformed attributes for the message \".concat(this.sid), log$6);\n\n      if (!isDeepEqual(this.state.attributes, updatedAttributes)) {\n        this.state.attributes = updatedAttributes;\n        updateReasons.push('attributes');\n      }\n\n      var updatedAggregatedDelivery = data.delivery;\n      var currentAggregatedDelivery = this.state.aggregatedDeliveryReceipt;\n      var isUpdatedAggregateDeliveryValid = !!updatedAggregatedDelivery && !!updatedAggregatedDelivery.total && !!updatedAggregatedDelivery.delivered && !!updatedAggregatedDelivery.failed && !!updatedAggregatedDelivery.read && !!updatedAggregatedDelivery.sent && !!updatedAggregatedDelivery.undelivered;\n\n      if (isUpdatedAggregateDeliveryValid) {\n        if (!currentAggregatedDelivery) {\n          this.state.aggregatedDeliveryReceipt = new AggregatedDeliveryReceipt(updatedAggregatedDelivery);\n          updateReasons.push('deliveryReceipt');\n        } else if (!currentAggregatedDelivery._isEquals(updatedAggregatedDelivery)) {\n          currentAggregatedDelivery._update(updatedAggregatedDelivery);\n\n          updateReasons.push('deliveryReceipt');\n        }\n      }\n\n      if (updateReasons.length > 0) {\n        this.emit('updated', {\n          message: this,\n          updateReasons: updateReasons\n        });\n      }\n    }\n    /**\n     * Get Participant who is author of the Message\n     * @returns {Promise<Participant>}\n     */\n\n  }, {\n    key: \"getParticipant\",\n    value: function () {\n      var _getParticipant = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {\n        var _this2 = this;\n\n        var participant, errorMesage;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                participant = null;\n\n                if (!this.state.participantSid) {\n                  _context.next = 5;\n                  break;\n                }\n\n                _context.next = 4;\n                return this.conversation.getParticipantBySid(this.participantSid).catch(function () {\n                  log$6.debug('Participant with sid \"' + _this2.participantSid + '\" not found for message ' + _this2.sid);\n                  return null;\n                });\n\n              case 4:\n                participant = _context.sent;\n\n              case 5:\n                if (!(!participant && this.state.author)) {\n                  _context.next = 9;\n                  break;\n                }\n\n                _context.next = 8;\n                return this.conversation.getParticipantByIdentity(this.state.author).catch(function () {\n                  log$6.debug('Participant with identity \"' + _this2.author + '\" not found for message ' + _this2.sid);\n                  return null;\n                });\n\n              case 8:\n                participant = _context.sent;\n\n              case 9:\n                if (!participant) {\n                  _context.next = 11;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", participant);\n\n              case 11:\n                errorMesage = 'Participant with ';\n\n                if (this.state.participantSid) {\n                  errorMesage += 'SID \\'' + this.state.participantSid + '\\' ';\n                }\n\n                if (this.state.author) {\n                  if (this.state.participantSid) {\n                    errorMesage += 'or ';\n                  }\n\n                  errorMesage += 'identity \\'' + this.state.author + '\\' ';\n                }\n\n                if (errorMesage === 'Participant with ') {\n                  errorMesage = 'Participant ';\n                }\n\n                errorMesage += 'was not found';\n                throw new Error(errorMesage);\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getParticipant() {\n        return _getParticipant.apply(this, arguments);\n      }\n\n      return getParticipant;\n    }()\n    /**\n     * Get delivery receipts of the message\n     * @returns {Promise<DetailedDeliveryReceipt[]>}\n     */\n\n  }, {\n    key: \"getDetailedDeliveryReceipts\",\n    value: function () {\n      var _getDetailedDeliveryReceipts = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {\n        var paginator, detailedDeliveryReceipts;\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this._getDetailedDeliveryReceiptsPaginator();\n\n              case 2:\n                paginator = _context2.sent;\n                detailedDeliveryReceipts = [];\n\n              case 4:\n                detailedDeliveryReceipts = [].concat(_toConsumableArray__default['default'](detailedDeliveryReceipts), _toConsumableArray__default['default'](paginator.items));\n\n                if (paginator.hasNextPage) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                return _context2.abrupt(\"break\", 13);\n\n              case 8:\n                _context2.next = 10;\n                return paginator.nextPage();\n\n              case 10:\n                paginator = _context2.sent;\n                _context2.next = 4;\n                break;\n\n              case 13:\n                return _context2.abrupt(\"return\", detailedDeliveryReceipts);\n\n              case 14:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getDetailedDeliveryReceipts() {\n        return _getDetailedDeliveryReceipts.apply(this, arguments);\n      }\n\n      return getDetailedDeliveryReceipts;\n    }()\n    /**\n     * Remove the Message.\n     * @returns {Promise<Message>}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function () {\n      var _remove = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.services.session.addCommand('deleteMessage', {\n                  channelSid: this.conversation.sid,\n                  messageIdx: this.index.toString()\n                });\n\n              case 2:\n                return _context3.abrupt(\"return\", this);\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function remove() {\n        return _remove.apply(this, arguments);\n      }\n\n      return remove;\n    }()\n    /**\n     * Edit message body.\n     * @param {String} body - new body of Message.\n     * @returns {Promise<Message>}\n     */\n\n  }, {\n    key: \"updateBody\",\n    value: function () {\n      var _updateBody = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4(body) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.services.session.addCommand('editMessage', {\n                  channelSid: this.conversation.sid,\n                  messageIdx: this.index.toString(),\n                  text: body\n                });\n\n              case 2:\n                return _context4.abrupt(\"return\", this);\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function updateBody(_x) {\n        return _updateBody.apply(this, arguments);\n      }\n\n      return updateBody;\n    }()\n    /**\n     * Edit message attributes.\n     * @param {any} attributes new attributes for Message.\n     * @returns {Promise<Message>}\n     */\n\n  }, {\n    key: \"updateAttributes\",\n    value: function () {\n      var _updateAttributes = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee5(attributes) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.services.session.addCommand('editMessageAttributes', {\n                  channelSid: this.conversation.sid,\n                  messageIdx: this.index,\n                  attributes: JSON.stringify(attributes)\n                });\n\n              case 2:\n                return _context5.abrupt(\"return\", this);\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function updateAttributes(_x2) {\n        return _updateAttributes.apply(this, arguments);\n      }\n\n      return updateAttributes;\n    }()\n  }, {\n    key: \"_getDetailedDeliveryReceiptsPaginator\",\n    value: function () {\n      var _getDetailedDeliveryReceiptsPaginator2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee6(options) {\n        var _this3 = this;\n\n        var links, messagesReceiptsUrl, url, response;\n        return _regeneratorRuntime__default['default'].wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.services.session.getSessionLinks();\n\n              case 2:\n                links = _context6.sent;\n                messagesReceiptsUrl = links.messagesReceiptsUrl.replace('%s', this.conversation.sid).replace('%s', this.sid);\n                url = new UriBuilder(messagesReceiptsUrl).arg('PageToken', options === null || options === void 0 ? void 0 : options.pageToken).arg('PageSize', options === null || options === void 0 ? void 0 : options.pageSize).build();\n                _context6.next = 7;\n                return this.services.network.get(url);\n\n              case 7:\n                response = _context6.sent;\n                return _context6.abrupt(\"return\", new RestPaginator(response.body.delivery_receipts.map(function (x) {\n                  return new DetailedDeliveryReceipt(x);\n                }), function (pageToken, pageSize) {\n                  return _this3._getDetailedDeliveryReceiptsPaginator({\n                    pageToken: pageToken,\n                    pageSize: pageSize\n                  });\n                }, response.body.meta.previous_token, response.body.meta.next_token));\n\n              case 9:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _getDetailedDeliveryReceiptsPaginator(_x3) {\n        return _getDetailedDeliveryReceiptsPaginator2.apply(this, arguments);\n      }\n\n      return _getDetailedDeliveryReceiptsPaginator;\n    }()\n  }]);\n\n  return Message;\n}(EventEmitter);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync('string'), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Message.prototype, \"updateBody\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(['string', 'number', 'boolean', 'object', twilioSdkTypeValidator.literal(null)]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Promise)], Message.prototype, \"updateAttributes\", null);\n/**\n * Fired when the Message's properties or body has been updated.\n * @event Message#updated\n * @type {Object}\n * @property {Message} message - Updated Message\n * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons\n */\n\n\nfunction _createSuper$5(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$5() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar log$5 = Logger.scope('Messages');\n/**\n * Represents the collection of messages in a conversation\n */\n\nvar Messages = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](Messages, _EventEmitter);\n\n  var _super = _createSuper$5(Messages);\n\n  function Messages(conversation, services) {\n    var _this;\n\n    _classCallCheck__default['default'](this, Messages);\n\n    _this = _super.call(this);\n    _this.conversation = conversation;\n    _this.services = services;\n    _this.messagesByIndex = new Map();\n    _this.messagesListPromise = null;\n    return _this;\n  }\n  /**\n   * Subscribe to the Messages Event Stream\n   * @param {String} name - The name of Sync object for the Messages resource.\n   * @returns {Promise}\n   */\n\n\n  _createClass__default['default'](Messages, [{\n    key: \"subscribe\",\n    value: function subscribe(name) {\n      var _this2 = this;\n\n      return this.messagesListPromise = this.messagesListPromise || this.services.syncClient.list({\n        id: name,\n        mode: 'open_existing'\n      }).then(function (list) {\n        list.on('itemAdded', function (args) {\n          log$5.debug(_this2.conversation.sid + ' itemAdded: ' + args.item.index);\n          var message = new Message(_this2.conversation, _this2.services, args.item.index, args.item.data);\n\n          if (_this2.messagesByIndex.has(message.index)) {\n            log$5.debug('Message arrived, but already known and ignored', _this2.conversation.sid, message.index);\n            return;\n          }\n\n          _this2.messagesByIndex.set(message.index, message);\n\n          message.on('updated', function (args) {\n            return _this2.emit('messageUpdated', args);\n          });\n\n          _this2.emit('messageAdded', message);\n        });\n        list.on('itemRemoved', function (args) {\n          log$5.debug(_this2.conversation.sid + ' itemRemoved: ' + args.index);\n          var index = args.index;\n\n          if (_this2.messagesByIndex.has(index)) {\n            var message = _this2.messagesByIndex.get(index);\n\n            _this2.messagesByIndex.delete(message.index);\n\n            message.removeAllListeners('updated');\n\n            _this2.emit('messageRemoved', message);\n          }\n        });\n        list.on('itemUpdated', function (args) {\n          log$5.debug(_this2.conversation.sid + ' itemUpdated: ' + args.item.index);\n\n          var message = _this2.messagesByIndex.get(args.item.index);\n\n          if (message) {\n            message._update(args.item.data);\n          }\n        });\n        return list;\n      }).catch(function (err) {\n        _this2.messagesListPromise = null;\n\n        if (_this2.services.syncClient.connectionState != 'disconnected') {\n          log$5.error('Failed to get messages object for conversation', _this2.conversation.sid, err);\n        }\n\n        log$5.debug('ERROR: Failed to get messages object for conversation', _this2.conversation.sid, err);\n        throw err;\n      });\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function () {\n      var _unsubscribe = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {\n        var entity;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.messagesListPromise) {\n                  _context.next = 6;\n                  break;\n                }\n\n                _context.next = 3;\n                return this.messagesListPromise;\n\n              case 3:\n                entity = _context.sent;\n                entity.close();\n                this.messagesListPromise = null;\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function unsubscribe() {\n        return _unsubscribe.apply(this, arguments);\n      }\n\n      return unsubscribe;\n    }()\n    /**\n     * Send Message to the conversation\n     * @param {String} message - Message to post\n     * @param {any} attributes Message attributes\n     * @param {Conversation.SendEmailOptions} emailOptions Options that modify E-mail integration behaviors.\n     * @returns Returns promise which can fail\n     */\n\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(message) {\n        var attributes,\n            emailOptions,\n            _args2 = arguments;\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                attributes = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n                emailOptions = _args2.length > 2 ? _args2[2] : undefined;\n                log$5.debug('Sending text message', message, attributes, emailOptions);\n                return _context2.abrupt(\"return\", this.services.session.addCommand('sendMessage', {\n                  channelSid: this.conversation.sid,\n                  text: message,\n                  attributes: JSON.stringify(attributes),\n                  subject: emailOptions === null || emailOptions === void 0 ? void 0 : emailOptions.subject\n                }));\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function send(_x) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n    /**\n     * Send Media Message to the conversation\n     * @param {FormData | Conversation#SendMediaOptions} mediaContent - Media content to post\n     * @param {any} attributes Message attributes\n     * @returns Returns promise which can fail\n     */\n\n  }, {\n    key: \"sendMedia\",\n    value: function () {\n      var _sendMedia = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(mediaContent) {\n        var attributes,\n            emailOptions,\n            media,\n            mediaOptions,\n            _args3 = arguments;\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                attributes = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n                emailOptions = _args3.length > 2 ? _args3[2] : undefined;\n                log$5.debug('Sending media message', mediaContent, attributes, emailOptions);\n\n                if (!(typeof FormData !== 'undefined' && mediaContent instanceof FormData)) {\n                  _context3.next = 10;\n                  break;\n                }\n\n                log$5.debug('Sending media message as FormData', mediaContent, attributes);\n                _context3.next = 7;\n                return this.services.mcsClient.postFormData(mediaContent);\n\n              case 7:\n                media = _context3.sent;\n                _context3.next = 17;\n                break;\n\n              case 10:\n                log$5.debug('Sending media message as SendMediaOptions', mediaContent, attributes);\n                mediaOptions = mediaContent;\n\n                if (!(!mediaOptions.contentType || !mediaOptions.media)) {\n                  _context3.next = 14;\n                  break;\n                }\n\n                throw new Error('Media content <Conversation#SendMediaOptions> must contain non-empty contentType and media');\n\n              case 14:\n                _context3.next = 16;\n                return this.services.mcsClient.post(mediaOptions.contentType, mediaOptions.media);\n\n              case 16:\n                media = _context3.sent;\n\n              case 17:\n                return _context3.abrupt(\"return\", this.services.session.addCommand('sendMediaMessage', {\n                  channelSid: this.conversation.sid,\n                  mediaSid: media.sid,\n                  attributes: JSON.stringify(attributes)\n                }));\n\n              case 18:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function sendMedia(_x2) {\n        return _sendMedia.apply(this, arguments);\n      }\n\n      return sendMedia;\n    }()\n    /**\n     * Returns messages from conversation using paginator interface\n     * @param {Number} [pageSize] Number of messages to return in single chunk. By default it's 30.\n     * @param {String} [anchor] Most early message id which is already known, or 'end' by default\n     * @param {String} [direction] Pagination order 'backwards' or 'forward', or 'forward' by default\n     * @returns {Promise<Paginator<Message>>} last page of messages by default\n     */\n\n  }, {\n    key: \"getMessages\",\n    value: function getMessages(pageSize, anchor, direction) {\n      anchor = typeof anchor !== 'undefined' ? anchor : 'end';\n      direction = direction || 'backwards';\n      return this._getMessages(pageSize, anchor, direction);\n    }\n  }, {\n    key: \"wrapPaginator\",\n    value: function wrapPaginator(order, page, op) {\n      var _this3 = this; // We should swap next and prev page here, because of misfit of Sync and Chat paging conceptions\n\n\n      var shouldReverse = order === 'desc';\n\n      var np = function np() {\n        return page.nextPage().then(function (x) {\n          return _this3.wrapPaginator(order, x, op);\n        });\n      };\n\n      var pp = function pp() {\n        return page.prevPage().then(function (x) {\n          return _this3.wrapPaginator(order, x, op);\n        });\n      };\n\n      return op(page.items).then(function (items) {\n        return {\n          items: items.sort(function (x, y) {\n            return x.index - y.index;\n          }),\n          hasPrevPage: shouldReverse ? page.hasNextPage : page.hasPrevPage,\n          hasNextPage: shouldReverse ? page.hasPrevPage : page.hasNextPage,\n          prevPage: shouldReverse ? np : pp,\n          nextPage: shouldReverse ? pp : np\n        };\n      });\n    }\n  }, {\n    key: \"_upsertMessage\",\n    value: function _upsertMessage(index, value) {\n      var _this4 = this;\n\n      var cachedMessage = this.messagesByIndex.get(index);\n\n      if (cachedMessage) {\n        return cachedMessage;\n      }\n\n      var message = new Message(this.conversation, this.services, index, value);\n      this.messagesByIndex.set(message.index, message);\n      message.on('updated', function (args) {\n        return _this4.emit('messageUpdated', args);\n      });\n      return message;\n    }\n    /**\n     * Returns last messages from conversation\n     * @param {Number} [pageSize] Number of messages to return in single chunk. By default it's 30.\n     * @param {String} [anchor] Most early message id which is already known, or 'end' by default\n     * @param {String} [direction] Pagination order 'backwards' or 'forward', or 'forward' by default\n     * @returns {Promise<SyncPaginator<Message>>} last page of messages by default\n     * @private\n     */\n\n  }, {\n    key: \"_getMessages\",\n    value: function _getMessages(pageSize, anchor, direction) {\n      var _this5 = this;\n\n      anchor = typeof anchor !== 'undefined' ? anchor : 'end';\n      pageSize = pageSize || 30;\n      var order = direction === 'backwards' ? 'desc' : 'asc';\n      return this.messagesListPromise.then(function (messagesList) {\n        return messagesList.getItems({\n          from: anchor !== 'end' ? anchor : void 0,\n          pageSize: pageSize,\n          order: order\n        });\n      }).then(function (page) {\n        return _this5.wrapPaginator(order, page, function (items) {\n          return Promise.all(items.map(function (item) {\n            return _this5._upsertMessage(item.index, item.data);\n          }));\n        });\n      });\n    }\n  }]);\n\n  return Messages;\n}(EventEmitter);\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _createSuper$4(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$4() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar log$4 = Logger.scope('Conversation');\nvar fieldMappings = {\n  lastMessage: 'lastMessage',\n  attributes: 'attributes',\n  createdBy: 'createdBy',\n  dateCreated: 'dateCreated',\n  dateUpdated: 'dateUpdated',\n  friendlyName: 'friendlyName',\n  lastConsumedMessageIndex: 'lastConsumedMessageIndex',\n  notificationLevel: 'notificationLevel',\n  sid: 'sid',\n  status: 'status',\n  uniqueName: 'uniqueName',\n  state: 'state'\n};\n\nfunction parseTime(timeString) {\n  try {\n    return new Date(timeString);\n  } catch (e) {\n    return null;\n  }\n}\n/**\n * @classdesc A Conversation represents communication between multiple Conversations Clients\n * @property {any} attributes - The Conversation's custom attributes\n * @property {String} createdBy - The identity of the User that created this Conversation\n * @property {Date} dateCreated - The Date this Conversation was created\n * @property {Date} dateUpdated - The Date this Conversation was last updated\n * @property {String} [friendlyName] - The Conversation's name\n * @property {Number|null} lastReadMessageIndex - Index of the last Message the User has read in this Conversation\n * @property {Conversation#LastMessage} lastMessage - Last Message sent to this Conversation\n * @property {Conversation#NotificationLevel} notificationLevel - User Notification level for this Conversation\n * @property {String} sid - The Conversation's unique system identifier\n * @property {Conversation#Status} status - The Conversation's status\n * @property {Conversation#State} state - The Conversation's state\n * @property {String} uniqueName - The Conversation's unique name\n * @fires Conversation#participantJoined\n * @fires Conversation#participantLeft\n * @fires Conversation#participantUpdated\n * @fires Conversation#messageAdded\n * @fires Conversation#messageRemoved\n * @fires Conversation#messageUpdated\n * @fires Conversation#typingEnded\n * @fires Conversation#typingStarted\n * @fires Conversation#updated\n * @fires Conversation#removed\n */\n\n\nvar Conversation = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](Conversation, _EventEmitter);\n\n  var _super = _createSuper$4(Conversation);\n  /**\n   * These options can be passed to {@link Conversation#sendMessage}.\n   * @typedef {Object} Conversation#SendMediaOptions\n   * @property {String} contentType - content type of media\n   * @property {String | Buffer} media - content to post\n   */\n\n  /**\n   * These options can be passed to {@link Conversation#sendMessage}.\n   * @typedef {Object} Conversation#SendEmailOptions\n   * @property {String} subject - subject for the message. Ignored for media messages.\n   */\n\n  /**\n   * The update reason for <code>updated</code> event emitted on Conversation\n   * @typedef {('attributes' | 'createdBy' | 'dateCreated' | 'dateUpdated' |\n    'friendlyName' | 'lastReadMessageIndex' | 'state' | 'status' | 'uniqueName' | 'lastMessage' |\n    'notificationLevel' )} Conversation#UpdateReason\n   */\n\n  /**\n   * The status of the Conversation, relative to the Client: whether the Conversation has been <code>joined</code> or the Client is\n   * <code>notParticipating</code> in the Conversation.\n   * @typedef {('notParticipating' | 'joined')} Conversation#Status\n   */\n\n  /**\n   * The User's Notification level for Conversation, determines whether the currently logged-in User will receive\n   * pushes for events in this Conversation. Can be either <code>muted</code> or <code>default</code>,\n   * where <code>default</code> defers to global Service push configuration.\n   * @typedef {('default' | 'muted')} Conversation#NotificationLevel\n   */\n\n  /**\n   * The Conversation's state.\n   * @typedef {Object} Conversation#State\n   * @property {('active' | 'inactive' | 'closed')} current - the current state\n   * @property {Date} dateUpdated - date at which the latest conversation state update happened\n   */\n\n\n  function Conversation(services, descriptor, sid) {\n    var _this;\n\n    _classCallCheck__default['default'](this, Conversation);\n\n    _this = _super.call(this);\n    var attributes = descriptor.attributes || {};\n    var createdBy = descriptor.createdBy;\n    var dateCreated = parseTime(descriptor.dateCreated);\n    var dateUpdated = parseTime(descriptor.dateUpdated);\n    var friendlyName = descriptor.friendlyName || null;\n    var lastReadMessageIndex = Number.isInteger(descriptor.lastConsumedMessageIndex) ? descriptor.lastConsumedMessageIndex : null;\n    var uniqueName = descriptor.uniqueName || null;\n\n    try {\n      JSON.stringify(attributes);\n    } catch (e) {\n      throw new Error('Attributes must be a valid JSON object.');\n    }\n\n    _this.services = services;\n    _this.sid = sid;\n    _this.entityName = descriptor.channel;\n    _this.channelState = {\n      uniqueName: uniqueName,\n      status: 'notParticipating',\n      attributes: attributes,\n      createdBy: createdBy,\n      dateCreated: dateCreated,\n      dateUpdated: dateUpdated,\n      friendlyName: friendlyName,\n      lastReadMessageIndex: lastReadMessageIndex\n    };\n\n    if (descriptor.notificationLevel) {\n      _this.channelState.notificationLevel = descriptor.notificationLevel;\n    }\n\n    _this.participants = new Map();\n    _this.participantsEntity = new Participants(_assertThisInitialized__default['default'](_this), _this.services, _this.participants);\n\n    _this.participantsEntity.on('participantJoined', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'participantJoined'));\n\n    _this.participantsEntity.on('participantLeft', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'participantLeft'));\n\n    _this.participantsEntity.on('participantUpdated', function (args) {\n      return _this.emit('participantUpdated', args);\n    });\n\n    _this.messagesEntity = new Messages(_assertThisInitialized__default['default'](_this), services);\n\n    _this.messagesEntity.on('messageAdded', function (message) {\n      return _this._onMessageAdded(message);\n    });\n\n    _this.messagesEntity.on('messageUpdated', function (args) {\n      return _this.emit('messageUpdated', args);\n    });\n\n    _this.messagesEntity.on('messageRemoved', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'messageRemoved'));\n\n    return _this;\n  }\n\n  _createClass__default['default'](Conversation, [{\n    key: \"uniqueName\",\n    get: function get() {\n      return this.channelState.uniqueName;\n    }\n  }, {\n    key: \"status\",\n    get: function get() {\n      return this.channelState.status;\n    }\n  }, {\n    key: \"friendlyName\",\n    get: function get() {\n      return this.channelState.friendlyName;\n    }\n  }, {\n    key: \"dateUpdated\",\n    get: function get() {\n      return this.channelState.dateUpdated;\n    }\n  }, {\n    key: \"dateCreated\",\n    get: function get() {\n      return this.channelState.dateCreated;\n    }\n  }, {\n    key: \"createdBy\",\n    get: function get() {\n      return this.channelState.createdBy;\n    }\n  }, {\n    key: \"attributes\",\n    get: function get() {\n      return this.channelState.attributes;\n    }\n  }, {\n    key: \"lastReadMessageIndex\",\n    get: function get() {\n      return this.channelState.lastReadMessageIndex;\n    }\n  }, {\n    key: \"lastMessage\",\n    get: function get() {\n      return this.channelState.lastMessage;\n    }\n  }, {\n    key: \"notificationLevel\",\n    get: function get() {\n      return this.channelState.notificationLevel;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this.channelState.state;\n    }\n    /**\n     * The Conversation's last message's information.\n     * @typedef {Object} Conversation#LastMessage\n     * @property {Number} index - Message's index\n     * @property {Date} dateCreated - Message's creation date\n     */\n\n    /**\n     * Load and Subscribe to this Conversation and do not subscribe to its Participants and Messages.\n     * This or _subscribeStreams will need to be called before any events on Conversation will fire.\n     * @returns {Promise}\n     * @private\n     */\n\n  }, {\n    key: \"_subscribe\",\n    value: function _subscribe() {\n      var _this2 = this;\n\n      if (this.entityPromise) {\n        return this.entityPromise;\n      }\n\n      return this.entityPromise = this.entityPromise || this.services.syncClient.document({\n        id: this.entityName,\n        mode: 'open_existing'\n      }).then(function (entity) {\n        _this2.entity = entity;\n\n        _this2.entity.on('updated', function (args) {\n          _this2._update(args.data);\n        });\n\n        _this2.entity.on('removed', function () {\n          return _this2.emit('removed', _this2);\n        });\n\n        _this2._update(_this2.entity.data);\n\n        return entity;\n      }).catch(function (err) {\n        _this2.entity = null;\n        _this2.entityPromise = null;\n\n        if (_this2.services.syncClient.connectionState != 'disconnected') {\n          log$4.error('Failed to get conversation object', err);\n        }\n\n        log$4.debug('ERROR: Failed to get conversation object', err);\n        throw err;\n      });\n    }\n    /**\n     * Load the attributes of this Conversation and instantiate its Participants and Messages.\n     * This or _subscribe will need to be called before any events on Conversation will fire.\n     * This will need to be called before any events on Participants or Messages will fire\n     * @returns {Promise}\n     * @private\n     */\n\n  }, {\n    key: \"_subscribeStreams\",\n    value: function () {\n      var _subscribeStreams2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {\n        var messagesObjectName, rosterObjectName;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return this._subscribe();\n\n              case 3:\n                log$4.trace('_subscribeStreams, this.entity.data=', this.entity.data);\n                messagesObjectName = this.entity.data.messages;\n                rosterObjectName = this.entity.data.roster;\n                _context.next = 8;\n                return Promise.all([this.messagesEntity.subscribe(messagesObjectName), this.participantsEntity.subscribe(rosterObjectName)]);\n\n              case 8:\n                _context.next = 15;\n                break;\n\n              case 10:\n                _context.prev = 10;\n                _context.t0 = _context[\"catch\"](0);\n\n                if (this.services.syncClient.connectionState !== 'disconnected') {\n                  log$4.error('Failed to subscribe on conversation objects', this.sid, _context.t0);\n                }\n\n                log$4.debug('ERROR: Failed to subscribe on conversation objects', this.sid, _context.t0);\n                throw _context.t0;\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 10]]);\n      }));\n\n      function _subscribeStreams() {\n        return _subscribeStreams2.apply(this, arguments);\n      }\n\n      return _subscribeStreams;\n    }()\n    /**\n     * Stop listening for and firing events on this Conversation.\n     * @returns {Promise}\n     * @private\n     */\n\n  }, {\n    key: \"_unsubscribe\",\n    value: function () {\n      var _unsubscribe2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this.entity) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                _context2.next = 3;\n                return this.entity.close();\n\n              case 3:\n                this.entity = null;\n                this.entityPromise = null;\n\n              case 5:\n                return _context2.abrupt(\"return\", Promise.all([this.participantsEntity.unsubscribe(), this.messagesEntity.unsubscribe()]));\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _unsubscribe() {\n        return _unsubscribe2.apply(this, arguments);\n      }\n\n      return _unsubscribe;\n    }()\n    /**\n     * Set conversation status\n     * @private\n     */\n\n  }, {\n    key: \"_setStatus\",\n    value: function _setStatus(status, source) {\n      var _this3 = this;\n\n      this.statusSource = source;\n\n      if (this.channelState.status === status) {\n        return;\n      }\n\n      this.channelState.status = status;\n\n      if (status === 'joined') {\n        this._subscribeStreams().catch(function (err) {\n          log$4.debug('ERROR while setting conversation status ' + status, err);\n\n          if (_this3.services.syncClient.connectionState !== 'disconnected') {\n            throw err;\n          }\n        });\n      } else if (this.entityPromise) {\n        this._unsubscribe().catch(function (err) {\n          log$4.debug('ERROR while setting conversation status ' + status, err);\n\n          if (_this3.services.syncClient.connectionState !== 'disconnected') {\n            throw err;\n          }\n        });\n      }\n    }\n    /**\n     * If conversation's status update source\n     * @private\n     * @return {Conversations.DataSource}\n     */\n\n  }, {\n    key: \"_statusSource\",\n    value: function _statusSource() {\n      return this.statusSource;\n    }\n  }, {\n    key: \"_update\",\n    value:\n    /**\n     * Updates local conversation object with new values\n     * @private\n     */\n    function _update(update) {\n      var _update$lastMessage, _update$lastMessage2, _this$channelState$la, _this$channelState$la2, _this$channelState$lo;\n\n      log$4.trace('_update', update);\n      Conversation.preprocessUpdate(update, this.sid);\n      var updateReasons = new Set();\n\n      for (var _i = 0, _Object$keys = Object.keys(update); _i < _Object$keys.length; _i++) {\n        var key = _Object$keys[_i];\n        var localKey = fieldMappings[key];\n\n        if (!localKey) {\n          continue;\n        }\n\n        switch (localKey) {\n          case fieldMappings.status:\n            if (!update.status || update.status === 'unknown' || this.channelState.status === update.status) {\n              break;\n            }\n\n            this.channelState.status = update.status;\n            updateReasons.add(localKey);\n            break;\n\n          case fieldMappings.attributes:\n            if (isDeepEqual(this.channelState.attributes, update.attributes)) {\n              break;\n            }\n\n            this.channelState.attributes = update.attributes;\n            updateReasons.add(localKey);\n            break;\n\n          case fieldMappings.lastConsumedMessageIndex:\n            if (update.lastConsumedMessageIndex === undefined || update.lastConsumedMessageIndex === this.channelState.lastReadMessageIndex) {\n              break;\n            }\n\n            this.channelState.lastReadMessageIndex = update.lastConsumedMessageIndex;\n            updateReasons.add('lastReadMessageIndex');\n            break;\n\n          case fieldMappings.lastMessage:\n            if (this.channelState.lastMessage && !update.lastMessage) {\n              delete this.channelState.lastMessage;\n              updateReasons.add(localKey);\n              break;\n            }\n\n            this.channelState.lastMessage = this.channelState.lastMessage || {};\n\n            if (((_update$lastMessage = update.lastMessage) === null || _update$lastMessage === void 0 ? void 0 : _update$lastMessage.index) !== undefined && update.lastMessage.index !== this.channelState.lastMessage.index) {\n              this.channelState.lastMessage.index = update.lastMessage.index;\n              updateReasons.add(localKey);\n            }\n\n            if (((_update$lastMessage2 = update.lastMessage) === null || _update$lastMessage2 === void 0 ? void 0 : _update$lastMessage2.timestamp) !== undefined && ((_this$channelState$la = this.channelState.lastMessage) === null || _this$channelState$la === void 0 ? void 0 : (_this$channelState$la2 = _this$channelState$la.dateCreated) === null || _this$channelState$la2 === void 0 ? void 0 : _this$channelState$la2.getTime()) !== update.lastMessage.timestamp.getTime()) {\n              this.channelState.lastMessage.dateCreated = update.lastMessage.timestamp;\n              updateReasons.add(localKey);\n            }\n\n            if (isDeepEqual(this.channelState.lastMessage, {})) {\n              delete this.channelState.lastMessage;\n            }\n\n            break;\n\n          case fieldMappings.state:\n            var state = update.state || undefined;\n\n            if (state !== undefined) {\n              state.dateUpdated = new Date(state.dateUpdated);\n            }\n\n            if (isDeepEqual(this.channelState.state, state)) {\n              break;\n            }\n\n            this.channelState.state = state;\n            updateReasons.add(localKey);\n            break;\n\n          default:\n            var isDate = update[key] instanceof Date;\n            var keysMatchAsDates = isDate && ((_this$channelState$lo = this.channelState[localKey]) === null || _this$channelState$lo === void 0 ? void 0 : _this$channelState$lo.getTime()) === update[key].getTime();\n            var keysMatchAsNonDates = !isDate && this[localKey] === update[key];\n\n            if (keysMatchAsDates || keysMatchAsNonDates) {\n              break;\n            }\n\n            this.channelState[localKey] = update[key];\n            updateReasons.add(localKey);\n        }\n      }\n\n      if (updateReasons.size > 0) {\n        this.emit('updated', {\n          conversation: this,\n          updateReasons: _toConsumableArray__default['default'](updateReasons)\n        });\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_onMessageAdded\",\n    value: function _onMessageAdded(message) {\n      var _iterator = _createForOfIteratorHelper(this.participants.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var participant = _step.value;\n\n          if (participant.identity === message.author) {\n            participant._endTyping();\n\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.emit('messageAdded', message);\n    }\n    /**\n     * Add a participant to the Conversation by its Identity.\n     * @param {String} identity - Identity of the Client to add\n     * @param {any} [attributes] Attributes to be attached to the participant\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"add\",\n    value: function () {\n      var _add = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(identity, attributes) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", this.participantsEntity.add(identity, attributes));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function add(_x, _x2) {\n        return _add.apply(this, arguments);\n      }\n\n      return add;\n    }()\n    /**\n     * Add a non-chat participant to the Conversation.\n     *\n     * @param {String} proxyAddress Proxy (Twilio) address of the participant\n     * @param {String} address User address of the participant\n     * @param {any} [attributes] Attributes to be attached to the participant\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"addNonChatParticipant\",\n    value: function () {\n      var _addNonChatParticipant = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4(proxyAddress, address) {\n        var attributes,\n            _args4 = arguments;\n        return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                attributes = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};\n                return _context4.abrupt(\"return\", this.participantsEntity.addNonChatParticipant(proxyAddress, address, attributes));\n\n              case 2:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function addNonChatParticipant(_x3, _x4) {\n        return _addNonChatParticipant.apply(this, arguments);\n      }\n\n      return addNonChatParticipant;\n    }()\n    /**\n     * Advance Conversation's last read Message index to current read horizon.\n     * Rejects if User is not Participant of Conversation.\n     * Last read Message index is updated only if new index value is higher than previous.\n     * @param {Number} index - Message index to advance to as last read\n     * @returns {Promise<number>} resulting unread messages count in the conversation\n     */\n\n  }, {\n    key: \"advanceLastReadMessageIndex\",\n    value: function () {\n      var _advanceLastReadMessageIndex = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee5(index) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this._subscribeStreams();\n\n              case 2:\n                return _context5.abrupt(\"return\", this.services.readHorizon.advanceLastReadMessageIndexForConversation(this.sid, index, this.lastReadMessageIndex));\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function advanceLastReadMessageIndex(_x5) {\n        return _advanceLastReadMessageIndex.apply(this, arguments);\n      }\n\n      return advanceLastReadMessageIndex;\n    }()\n    /**\n     * Delete the Conversation and unsubscribe from its events.\n     * @returns {Promise<Conversation>}\n     */\n\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee6() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.services.session.addCommand('destroyChannel', {\n                  channelSid: this.sid\n                });\n\n              case 2:\n                return _context6.abrupt(\"return\", this);\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _delete() {\n        return _delete2.apply(this, arguments);\n      }\n\n      return _delete;\n    }()\n    /**\n     * Get the custom attributes of this Conversation.\n     * @returns {Promise<any>} attributes of this Conversation\n     */\n\n  }, {\n    key: \"getAttributes\",\n    value: function () {\n      var _getAttributes = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee7() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this._subscribe();\n\n              case 2:\n                return _context7.abrupt(\"return\", this.attributes);\n\n              case 3:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function getAttributes() {\n        return _getAttributes.apply(this, arguments);\n      }\n\n      return getAttributes;\n    }()\n    /**\n     * Returns messages from conversation using paginator interface.\n     * @param {Number} [pageSize=30] Number of messages to return in single chunk\n     * @param {Number} [anchor] - Index of newest Message to fetch. From the end by default\n     * @param {('backwards'|'forward')} [direction=backwards] - Query direction. By default it query backwards\n     *                                                          from newer to older. 'forward' will query in opposite direction\n     * @returns {Promise<Paginator<Message>>} page of messages\n     */\n\n  }, {\n    key: \"getMessages\",\n    value: function () {\n      var _getMessages = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee8(pageSize, anchor, direction) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this._subscribeStreams();\n\n              case 2:\n                return _context8.abrupt(\"return\", this.messagesEntity.getMessages(pageSize, anchor, direction));\n\n              case 3:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function getMessages(_x6, _x7, _x8) {\n        return _getMessages.apply(this, arguments);\n      }\n\n      return getMessages;\n    }()\n    /**\n     * Get a list of all Participants joined to this Conversation.\n     * @returns {Promise<Participant[]>}\n     */\n\n  }, {\n    key: \"getParticipants\",\n    value: function () {\n      var _getParticipants = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee9() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this._subscribeStreams();\n\n              case 2:\n                return _context9.abrupt(\"return\", this.participantsEntity.getParticipants());\n\n              case 3:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function getParticipants() {\n        return _getParticipants.apply(this, arguments);\n      }\n\n      return getParticipants;\n    }()\n    /**\n     * Get conversation participants count.\n     * <br/>\n     * This method is semi-realtime. This means that this data will be eventually correct,\n     * but will also possibly be incorrect for a few seconds. The Conversation system does not\n     * provide real time events for counter values changes.\n     * <br/>\n     * So this is quite useful for any UI badges, but is not recommended\n     * to build any core application logic based on these counters being accurate in real time.\n     * @returns {Promise<number>}\n     */\n\n  }, {\n    key: \"getParticipantsCount\",\n    value: function () {\n      var _getParticipantsCount = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee10() {\n        var links, url, response;\n        return _regeneratorRuntime__default['default'].wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this.services.session.getSessionLinks();\n\n              case 2:\n                links = _context10.sent;\n                url = new UriBuilder(links.publicChannelsUrl).path(this.sid).build();\n                _context10.next = 6;\n                return this.services.network.get(url);\n\n              case 6:\n                response = _context10.sent;\n                return _context10.abrupt(\"return\", response.body.members_count);\n\n              case 8:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function getParticipantsCount() {\n        return _getParticipantsCount.apply(this, arguments);\n      }\n\n      return getParticipantsCount;\n    }()\n    /**\n     * Get a Participant by its SID.\n     * @param {String} participantSid - Participant sid\n     * @returns {Promise<Participant>}\n     */\n\n  }, {\n    key: \"getParticipantBySid\",\n    value: function () {\n      var _getParticipantBySid = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee11(participantSid) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                return _context11.abrupt(\"return\", this.participantsEntity.getParticipantBySid(participantSid));\n\n              case 1:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function getParticipantBySid(_x9) {\n        return _getParticipantBySid.apply(this, arguments);\n      }\n\n      return getParticipantBySid;\n    }()\n    /**\n     * Get a Participant by its identity.\n     * @param {String} identity - Participant identity\n     * @returns {Promise<Participant>}\n     */\n\n  }, {\n    key: \"getParticipantByIdentity\",\n    value: function () {\n      var _getParticipantByIdentity = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee12(identity) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                return _context12.abrupt(\"return\", this.participantsEntity.getParticipantByIdentity(identity));\n\n              case 1:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function getParticipantByIdentity(_x10) {\n        return _getParticipantByIdentity.apply(this, arguments);\n      }\n\n      return getParticipantByIdentity;\n    }()\n    /**\n     * Get total message count in a conversation.\n     * <br/>\n     * This method is semi-realtime. This means that this data will be eventually correct,\n     * but will also possibly be incorrect for a few seconds. The Conversations system does not\n     * provide real time events for counter values changes.\n     * <br/>\n     * So this is quite useful for any UI badges, but is not recommended\n     * to build any core application logic based on these counters being accurate in real time.\n     * @returns {Promise<number>}\n     */\n\n  }, {\n    key: \"getMessagesCount\",\n    value: function () {\n      var _getMessagesCount = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee13() {\n        var links, url, response;\n        return _regeneratorRuntime__default['default'].wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.next = 2;\n                return this.services.session.getSessionLinks();\n\n              case 2:\n                links = _context13.sent;\n                url = new UriBuilder(links.publicChannelsUrl).path(this.sid).build();\n                _context13.next = 6;\n                return this.services.network.get(url);\n\n              case 6:\n                response = _context13.sent;\n                return _context13.abrupt(\"return\", response.body.messages_count);\n\n              case 8:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function getMessagesCount() {\n        return _getMessagesCount.apply(this, arguments);\n      }\n\n      return getMessagesCount;\n    }()\n    /**\n     * Get unread messages count for the User if they are a Participant of this Conversation.\n     * Rejects if the User is not a Participant of the Conversation.\n     * <br/>\n     * Use this method to obtain the number of unread messages together with\n     * updateLastReadMessageIndex() instead of relying on the\n     * Message indices which may have gaps. See Message.index for details.\n     * <br/>\n     * This method is semi-realtime. This means that this data will be eventually correct,\n     * but will also possibly be incorrect for a few seconds. The Chat system does not\n     * provide real time events for counter values changes.\n     * <br/>\n     * This is quite useful for any â€œunread messages countâ€ badges, but is not recommended\n     * to build any core application logic based on these counters being accurate in real time.\n     * @returns {Promise<number|null>}\n     */\n\n  }, {\n    key: \"getUnreadMessagesCount\",\n    value: function () {\n      var _getUnreadMessagesCount = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee14() {\n        var links, url, response;\n        return _regeneratorRuntime__default['default'].wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.next = 2;\n                return this.services.session.getSessionLinks();\n\n              case 2:\n                links = _context14.sent;\n                url = new UriBuilder(links.myChannelsUrl).arg('ChannelSid', this.sid).build();\n                _context14.next = 6;\n                return this.services.network.get(url);\n\n              case 6:\n                response = _context14.sent;\n\n                if (!(response.body.channels.length && response.body.channels[0].channel_sid == this.sid)) {\n                  _context14.next = 11;\n                  break;\n                }\n\n                if (!(typeof response.body.channels[0].unread_messages_count !== 'undefined' && response.body.channels[0].unread_messages_count != null)) {\n                  _context14.next = 10;\n                  break;\n                }\n\n                return _context14.abrupt(\"return\", response.body.channels[0].unread_messages_count);\n\n              case 10:\n                return _context14.abrupt(\"return\", null);\n\n              case 11:\n                throw new Error('Conversation is not in user conversations list');\n\n              case 12:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function getUnreadMessagesCount() {\n        return _getUnreadMessagesCount.apply(this, arguments);\n      }\n\n      return getUnreadMessagesCount;\n    }()\n    /**\n     * Join the Conversation and subscribe to its events.\n     * @returns {Promise<Conversation>}\n     */\n\n  }, {\n    key: \"join\",\n    value: function () {\n      var _join = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee15() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                _context15.next = 2;\n                return this.services.session.addCommand('joinChannelV2', {\n                  channelSid: this.sid\n                });\n\n              case 2:\n                return _context15.abrupt(\"return\", this);\n\n              case 3:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function join() {\n        return _join.apply(this, arguments);\n      }\n\n      return join;\n    }()\n    /**\n     * Leave the Conversation.\n     * @returns {Promise<Conversation>}\n     */\n\n  }, {\n    key: \"leave\",\n    value: function () {\n      var _leave = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee16() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                if (!(this.channelState.status === 'joined')) {\n                  _context16.next = 3;\n                  break;\n                }\n\n                _context16.next = 3;\n                return this.services.session.addCommand('leaveChannel', {\n                  channelSid: this.sid\n                });\n\n              case 3:\n                return _context16.abrupt(\"return\", this);\n\n              case 4:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function leave() {\n        return _leave.apply(this, arguments);\n      }\n\n      return leave;\n    }()\n    /**\n     * Remove a Participant from the Conversation. When a string is passed as the argument, it will assume that the string is an identity.\n     * @param {String|Participant} participant - identity or participant object to remove\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"removeParticipant\",\n    value: function () {\n      var _removeParticipant = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee17(participant) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                if (!(participant instanceof Participant)) {\n                  _context17.next = 4;\n                  break;\n                }\n\n                _context17.next = 3;\n                return this.participantsEntity.removeBySid(participant.sid);\n\n              case 3:\n                return _context17.abrupt(\"return\");\n\n              case 4:\n                _context17.next = 6;\n                return this.participantsEntity.removeByIdentity(participant);\n\n              case 6:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function removeParticipant(_x11) {\n        return _removeParticipant.apply(this, arguments);\n      }\n\n      return removeParticipant;\n    }()\n    /**\n     * Send a Message in the Conversation.\n     * @param {String|FormData|Conversation#SendMediaOptions|null} message - The message body for text message,\n     * FormData or MediaOptions for media content. Sending FormData supported only with browser engine\n     * @param {any} [messageAttributes] - attributes for the message\n     * @param {Conversation#SendEmailOptions} [emailOptions] - email options for the message\n     * @returns {Promise<number>} new Message's index in the Conversation's messages list\n     */\n\n  }, {\n    key: \"sendMessage\",\n    value: function () {\n      var _sendMessage = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee18(message, messageAttributes, emailOptions) {\n        var _response, response;\n\n        return _regeneratorRuntime__default['default'].wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                if (!(typeof message === 'string' || message === null)) {\n                  _context18.next = 5;\n                  break;\n                }\n\n                _context18.next = 3;\n                return this.messagesEntity.send(message, messageAttributes, emailOptions);\n\n              case 3:\n                _response = _context18.sent;\n                return _context18.abrupt(\"return\", parseToNumber(_response.messageId));\n\n              case 5:\n                _context18.next = 7;\n                return this.messagesEntity.sendMedia(message, messageAttributes, emailOptions);\n\n              case 7:\n                response = _context18.sent;\n                return _context18.abrupt(\"return\", parseToNumber(response.messageId));\n\n              case 9:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      function sendMessage(_x12, _x13, _x14) {\n        return _sendMessage.apply(this, arguments);\n      }\n\n      return sendMessage;\n    }()\n    /**\n     * Set last read Conversation's Message index to last known Message's index in this Conversation.\n     * @returns {Promise<number>} resulting unread messages count in the conversation\n     */\n\n  }, {\n    key: \"setAllMessagesRead\",\n    value: function () {\n      var _setAllMessagesRead = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee19() {\n        var messagesPage;\n        return _regeneratorRuntime__default['default'].wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                _context19.next = 2;\n                return this._subscribeStreams();\n\n              case 2:\n                _context19.next = 4;\n                return this.getMessages(1);\n\n              case 4:\n                messagesPage = _context19.sent;\n\n                if (!(messagesPage.items.length > 0)) {\n                  _context19.next = 7;\n                  break;\n                }\n\n                return _context19.abrupt(\"return\", this.advanceLastReadMessageIndex(messagesPage.items[0].index));\n\n              case 7:\n                return _context19.abrupt(\"return\", Promise.resolve(0));\n\n              case 8:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function setAllMessagesRead() {\n        return _setAllMessagesRead.apply(this, arguments);\n      }\n\n      return setAllMessagesRead;\n    }()\n    /**\n     * Set all messages in the conversation unread.\n     * @returns {Promise<number>} resulting unread messages count in the conversation\n     */\n\n  }, {\n    key: \"setAllMessagesUnread\",\n    value: function () {\n      var _setAllMessagesUnread = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee20() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                _context20.next = 2;\n                return this._subscribeStreams();\n\n              case 2:\n                return _context20.abrupt(\"return\", this.services.readHorizon.updateLastReadMessageIndexForConversation(this.sid, null));\n\n              case 3:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n\n      function setAllMessagesUnread() {\n        return _setAllMessagesUnread.apply(this, arguments);\n      }\n\n      return setAllMessagesUnread;\n    }()\n    /**\n     * Set User Notification level for this conversation.\n     * @param {Conversation#NotificationLevel} notificationLevel - The new user notification level\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"setUserNotificationLevel\",\n    value: function () {\n      var _setUserNotificationLevel = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee21(notificationLevel) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                _context21.next = 2;\n                return this.services.session.addCommand('editNotificationLevel', {\n                  channelSid: this.sid,\n                  notificationLevel: notificationLevel\n                });\n\n              case 2:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      function setUserNotificationLevel(_x15) {\n        return _setUserNotificationLevel.apply(this, arguments);\n      }\n\n      return setUserNotificationLevel;\n    }()\n    /**\n     * Send a notification to the server indicating that this Client is currently typing in this Conversation.\n     * Typing ended notification is sent after a while automatically, but by calling again this method you ensure typing ended is not received.\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"typing\",\n    value: function typing() {\n      return this.services.typingIndicator.send(this.sid);\n    }\n    /**\n     * Update the Conversation's attributes.\n     * @param {any} attributes - The new attributes object\n     * @returns {Promise<Conversation>}\n     */\n\n  }, {\n    key: \"updateAttributes\",\n    value: function () {\n      var _updateAttributes = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee22(attributes) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                _context22.next = 2;\n                return this.services.session.addCommand('editAttributes', {\n                  channelSid: this.sid,\n                  attributes: JSON.stringify(attributes)\n                });\n\n              case 2:\n                return _context22.abrupt(\"return\", this);\n\n              case 3:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n\n      function updateAttributes(_x16) {\n        return _updateAttributes.apply(this, arguments);\n      }\n\n      return updateAttributes;\n    }()\n    /**\n     * Update the Conversation's friendlyName.\n     * @param {String|null} name - The new Conversation friendlyName\n     * @returns {Promise<Conversation>}\n     */\n\n  }, {\n    key: \"updateFriendlyName\",\n    value: function () {\n      var _updateFriendlyName = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee23(name) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                if (!(this.channelState.friendlyName !== name)) {\n                  _context23.next = 3;\n                  break;\n                }\n\n                _context23.next = 3;\n                return this.services.session.addCommand('editFriendlyName', {\n                  channelSid: this.sid,\n                  friendlyName: name\n                });\n\n              case 3:\n                return _context23.abrupt(\"return\", this);\n\n              case 4:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this);\n      }));\n\n      function updateFriendlyName(_x17) {\n        return _updateFriendlyName.apply(this, arguments);\n      }\n\n      return updateFriendlyName;\n    }()\n    /**\n     * Set Conversation's last read Message index to current read horizon.\n     * @param {Number|null} index - Message index to set as last read.\n     * If null provided, then the behavior is identical to {@link Conversation#setAllMessagesUnread}\n     * @returns {Promise<number>} resulting unread messages count in the conversation\n     */\n\n  }, {\n    key: \"updateLastReadMessageIndex\",\n    value: function () {\n      var _updateLastReadMessageIndex = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee24(index) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                _context24.next = 2;\n                return this._subscribeStreams();\n\n              case 2:\n                return _context24.abrupt(\"return\", this.services.readHorizon.updateLastReadMessageIndexForConversation(this.sid, index));\n\n              case 3:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this);\n      }));\n\n      function updateLastReadMessageIndex(_x18) {\n        return _updateLastReadMessageIndex.apply(this, arguments);\n      }\n\n      return updateLastReadMessageIndex;\n    }()\n    /**\n     * Update the Conversation's unique name.\n     * @param {String|null} uniqueName - New unique name for the Conversation. Setting unique name to null removes it.\n     * @returns {Promise<Conversation>}\n     */\n\n  }, {\n    key: \"updateUniqueName\",\n    value: function () {\n      var _updateUniqueName = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee25(uniqueName) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                if (!(this.channelState.uniqueName !== uniqueName)) {\n                  _context25.next = 4;\n                  break;\n                }\n\n                if (!uniqueName) {\n                  uniqueName = '';\n                }\n\n                _context25.next = 4;\n                return this.services.session.addCommand('editUniqueName', {\n                  channelSid: this.sid,\n                  uniqueName: uniqueName\n                });\n\n              case 4:\n                return _context25.abrupt(\"return\", this);\n\n              case 5:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n\n      function updateUniqueName(_x19) {\n        return _updateUniqueName.apply(this, arguments);\n      }\n\n      return updateUniqueName;\n    }()\n  }], [{\n    key: \"preprocessUpdate\",\n    value: function preprocessUpdate(update, conversationSid) {\n      try {\n        if (typeof update.attributes === 'string') {\n          update.attributes = JSON.parse(update.attributes);\n        } else if (update.attributes) {\n          JSON.stringify(update.attributes);\n        }\n      } catch (e) {\n        log$4.warn('Retrieved malformed attributes from the server for conversation: ' + conversationSid);\n        update.attributes = {};\n      }\n\n      try {\n        if (update.dateCreated) {\n          update.dateCreated = new Date(update.dateCreated);\n        }\n      } catch (e) {\n        log$4.warn('Retrieved malformed dateCreated from the server for conversation: ' + conversationSid);\n        delete update.dateCreated;\n      }\n\n      try {\n        if (update.dateUpdated) {\n          update.dateUpdated = new Date(update.dateUpdated);\n        }\n      } catch (e) {\n        log$4.warn('Retrieved malformed dateUpdated from the server for conversation: ' + conversationSid);\n        delete update.dateUpdated;\n      }\n\n      try {\n        if (update.lastMessage && update.lastMessage.timestamp) {\n          update.lastMessage.timestamp = new Date(update.lastMessage.timestamp);\n        }\n      } catch (e) {\n        log$4.warn('Retrieved malformed lastMessage.timestamp from the server for conversation: ' + conversationSid);\n        delete update.lastMessage.timestamp;\n      }\n    }\n  }]);\n\n  return Conversation;\n}(EventEmitter);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.nonEmptyString, ['undefined', 'string', 'number', 'boolean', 'object', twilioSdkTypeValidator.literal(null)]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String, Object]), __metadata(\"design:returntype\", Promise)], Conversation.prototype, \"add\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.nonEmptyString, twilioSdkTypeValidator.nonEmptyString, ['undefined', 'object']), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String, String, Object]), __metadata(\"design:returntype\", Promise)], Conversation.prototype, \"addNonChatParticipant\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.nonNegativeInteger), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Number]), __metadata(\"design:returntype\", Promise)], Conversation.prototype, \"advanceLastReadMessageIndex\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(['undefined', twilioSdkTypeValidator.nonNegativeInteger], ['undefined', twilioSdkTypeValidator.nonNegativeInteger], ['undefined', twilioSdkTypeValidator.literal('backwards', 'forward')]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Number, Number, String]), __metadata(\"design:returntype\", Promise)], Conversation.prototype, \"getMessages\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.nonEmptyString), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Conversation.prototype, \"getParticipantBySid\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.nonEmptyString), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Conversation.prototype, \"getParticipantByIdentity\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync([twilioSdkTypeValidator.nonEmptyString, Participant]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Promise)], Conversation.prototype, \"removeParticipant\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(['string', twilioSdkTypeValidator.literal(null), // Wrapping it into a custom rule is necessary because the FormData class is not available on initialization.\ntwilioSdkTypeValidator.custom(function (value) {\n  return [value instanceof FormData, 'an instance of FormData'];\n}), twilioSdkTypeValidator.objectSchema('media options', {\n  contentType: twilioSdkTypeValidator.nonEmptyString,\n  media: twilioSdkTypeValidator.custom(function (value) {\n    var isValid = typeof value === 'string' && value.length > 0 || value instanceof Uint8Array || value instanceof ArrayBuffer;\n\n    if (typeof Blob === 'function') {\n      isValid = isValid || value instanceof Blob;\n    }\n\n    return [isValid, 'a non-empty string, an instance of Buffer or an instance of Blob'];\n  })\n})], ['undefined', 'string', 'number', 'boolean', 'object', twilioSdkTypeValidator.literal(null)], ['undefined', twilioSdkTypeValidator.literal(null), twilioSdkTypeValidator.objectSchema('email attributes', {\n  subject: [twilioSdkTypeValidator.nonEmptyString, 'undefined']\n})]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object, Object, Object]), __metadata(\"design:returntype\", Promise)], Conversation.prototype, \"sendMessage\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.literal('default', 'muted')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Conversation.prototype, \"setUserNotificationLevel\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(['string', 'number', 'boolean', 'object', twilioSdkTypeValidator.literal(null)]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Promise)], Conversation.prototype, \"updateAttributes\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(['string', twilioSdkTypeValidator.literal(null)]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Conversation.prototype, \"updateFriendlyName\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync([twilioSdkTypeValidator.literal(null), twilioSdkTypeValidator.nonNegativeInteger]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Number]), __metadata(\"design:returntype\", Promise)], Conversation.prototype, \"updateLastReadMessageIndex\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(['string', twilioSdkTypeValidator.literal(null)]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Conversation.prototype, \"updateUniqueName\", null);\n/**\n * Fired when a Participant has joined the Conversation.\n * @event Conversation#participantJoined\n * @type {Participant}\n */\n\n/**\n * Fired when a Participant has left the Conversation.\n * @event Conversation#participantLeft\n * @type {Participant}\n */\n\n/**\n * Fired when a Participant's fields has been updated.\n * @event Conversation#participantUpdated\n * @type {Object}\n * @property {Participant} participant - Updated Participant\n * @property {Participant#UpdateReason[]} updateReasons - Array of Participant's updated event reasons\n */\n\n/**\n * Fired when a new Message has been added to the Conversation.\n * @event Conversation#messageAdded\n * @type {Message}\n */\n\n/**\n * Fired when Message is removed from Conversation's message list.\n * @event Conversation#messageRemoved\n * @type {Message}\n */\n\n/**\n * Fired when an existing Message's fields are updated with new values.\n * @event Conversation#messageUpdated\n * @type {Object}\n * @property {Message} message - Updated Message\n * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons\n */\n\n/**\n * Fired when a Participant has stopped typing.\n * @event Conversation#typingEnded\n * @type {Participant}\n */\n\n/**\n * Fired when a Participant has started typing.\n * @event Conversation#typingStarted\n * @type {Participant}\n */\n\n/**\n * Fired when a Conversation's attributes or metadata have been updated.\n * @event Conversation#updated\n * @type {Object}\n * @property {Conversation} conversation - Updated Conversation\n * @property {Conversation#UpdateReason[]} updateReasons - Array of Conversation's updated event reasons\n */\n\n/**\n * Fired when the Conversation was destroyed or currently logged in User has left private Conversation\n * @event Conversation#removed\n * @type {Conversation}\n */\n\n\nfunction _createSuper$3(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$3() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar log$3 = Logger.scope('Conversations');\n/**\n * Represents conversations collection\n * {@see Conversation}\n */\n\nvar Conversations = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](Conversations, _EventEmitter);\n\n  var _super = _createSuper$3(Conversations); // sids\n\n\n  function Conversations(services) {\n    var _this;\n\n    _classCallCheck__default['default'](this, Conversations);\n\n    _this = _super.call(this);\n    _this.services = services;\n    _this.conversations = new Map();\n    _this.thumbstones = new Set();\n    _this.syncListFetched = false;\n    _this.syncListRead = new Deferred();\n    return _this;\n  }\n\n  _createClass__default['default'](Conversations, [{\n    key: \"getMap\",\n    value: function getMap() {\n      var _this2 = this;\n\n      return this.services.session.getMyConversationsId().then(function (name) {\n        return _this2.services.syncClient.map({\n          id: name,\n          mode: 'open_existing'\n        });\n      });\n    }\n    /**\n     * Add conversation to server\n     * @private\n     * @returns {Promise<Conversation>} Conversation\n     */\n\n  }, {\n    key: \"addConversation\",\n    value: function () {\n      var _addConversation = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(options) {\n        var attributes, response, conversationSid, conversationDocument, existingConversation, conversation;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (typeof options.attributes === 'undefined') {\n                  attributes = {};\n                } else {\n                  attributes = options.attributes;\n                }\n\n                _context.next = 3;\n                return this.services.session.addCommand('createConversation', {\n                  friendlyName: options.friendlyName,\n                  uniqueName: options.uniqueName,\n                  attributes: JSON.stringify(attributes)\n                });\n\n              case 3:\n                response = _context.sent;\n                conversationSid = 'conversationSid' in response ? response['conversationSid'] : null;\n                conversationDocument = 'conversation' in response ? response['conversation'] : null;\n                existingConversation = this.conversations.get(conversationSid);\n\n                if (!existingConversation) {\n                  _context.next = 11;\n                  break;\n                }\n\n                _context.next = 10;\n                return existingConversation._subscribe();\n\n              case 10:\n                return _context.abrupt(\"return\", existingConversation);\n\n              case 11:\n                conversation = new Conversation(this.services, {\n                  channel: conversationDocument,\n                  entityName: null,\n                  uniqueName: null,\n                  attributes: null,\n                  createdBy: null,\n                  friendlyName: null,\n                  lastConsumedMessageIndex: null,\n                  dateCreated: null,\n                  dateUpdated: null\n                }, conversationSid);\n                this.conversations.set(conversation.sid, conversation);\n                this.registerForEvents(conversation);\n                _context.next = 16;\n                return conversation._subscribe();\n\n              case 16:\n                this.emit('conversationAdded', conversation);\n                return _context.abrupt(\"return\", conversation);\n\n              case 18:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function addConversation(_x) {\n        return _addConversation.apply(this, arguments);\n      }\n\n      return addConversation;\n    }()\n    /**\n     * Fetch conversations list and instantiate all necessary objects\n     */\n\n  }, {\n    key: \"fetchConversations\",\n    value: function fetchConversations() {\n      var _this3 = this;\n\n      this.getMap().then( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(map) {\n          var upserts, paginator, items;\n          return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  map.on('itemAdded', function (args) {\n                    log$3.debug('itemAdded: ' + args.item.key);\n\n                    _this3.upsertConversation('sync', args.item.key, args.item.data);\n                  });\n                  map.on('itemRemoved', function (args) {\n                    log$3.debug('itemRemoved: ' + args.key);\n                    var sid = args.key;\n\n                    if (!_this3.syncListFetched) {\n                      _this3.thumbstones.add(sid);\n                    }\n\n                    var conversation = _this3.conversations.get(sid);\n\n                    if (conversation) {\n                      if (conversation && conversation.status === 'joined'\n                      /*|| conversation.status === 'invited'*/\n                      ) {\n                          conversation._setStatus('notParticipating', 'sync');\n\n                          _this3.emit('conversationLeft', conversation);\n                        }\n\n                      _this3.conversations.delete(sid);\n\n                      _this3.emit('conversationRemoved', conversation);\n\n                      conversation.emit('removed', conversation);\n                    }\n                  });\n                  map.on('itemUpdated', function (args) {\n                    log$3.debug('itemUpdated: ' + args.item.key);\n\n                    _this3.upsertConversation('sync', args.item.key, args.item.data);\n                  });\n                  upserts = [];\n                  _context2.next = 6;\n                  return _this3.services.syncList.getPage();\n\n                case 6:\n                  paginator = _context2.sent;\n                  items = paginator.items;\n                  items.forEach(function (item) {\n                    upserts.push(_this3.upsertConversation('synclist', item.channel_sid, item));\n                  });\n\n                case 9:\n                  if (!paginator.hasNextPage) {\n                    _context2.next = 16;\n                    break;\n                  }\n\n                  _context2.next = 12;\n                  return paginator.nextPage();\n\n                case 12:\n                  paginator = _context2.sent;\n                  paginator.items.forEach(function (item) {\n                    upserts.push(_this3.upsertConversation('synclist', item.channel_sid, item));\n                  });\n                  _context2.next = 9;\n                  break;\n\n                case 16:\n                  _this3.syncListRead.set(true);\n\n                  return _context2.abrupt(\"return\", Promise.all(upserts));\n\n                case 18:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n\n        return function (_x2) {\n          return _ref.apply(this, arguments);\n        };\n      }()).then(function () {\n        _this3.syncListFetched = true;\n\n        _this3.thumbstones.clear();\n\n        log$3.debug('Conversations list fetched');\n      }).then(function () {\n        return _this3;\n      }).catch(function (e) {\n        if (_this3.services.syncClient.connectionState != 'disconnected') {\n          log$3.error('Failed to get conversations list', e);\n        }\n\n        log$3.debug('ERROR: Failed to get conversations list', e);\n        throw e;\n      });\n    }\n  }, {\n    key: \"_wrapPaginator\",\n    value: function _wrapPaginator(page, op) {\n      var _this4 = this;\n\n      return op(page.items).then(function (items) {\n        return {\n          items: items,\n          hasNextPage: page.hasNextPage,\n          hasPrevPage: page.hasPrevPage,\n          nextPage: function nextPage() {\n            return page.nextPage().then(function (x) {\n              return _this4._wrapPaginator(x, op);\n            });\n          },\n          prevPage: function prevPage() {\n            return page.prevPage().then(function (x) {\n              return _this4._wrapPaginator(x, op);\n            });\n          }\n        };\n      });\n    }\n  }, {\n    key: \"getConversations\",\n    value: function getConversations(args) {\n      var _this5 = this;\n\n      return this.getMap().then(function (conversationsMap) {\n        return conversationsMap.getItems(args);\n      }).then(function (page) {\n        return _this5._wrapPaginator(page, function (items) {\n          return Promise.all(items.map(function (item) {\n            return _this5.upsertConversation('sync', item.key, item.data);\n          }));\n        });\n      });\n    }\n  }, {\n    key: \"getConversation\",\n    value: function getConversation(sid) {\n      var _this6 = this;\n\n      return this.getMap().then(function (conversationsMap) {\n        return conversationsMap.getItems({\n          key: sid\n        });\n      }).then(function (page) {\n        return page.items.map(function (item) {\n          return _this6.upsertConversation('sync', item.key, item.data);\n        });\n      }).then(function (items) {\n        return items.length > 0 ? items[0] : null;\n      });\n    }\n  }, {\n    key: \"getConversationByUniqueName\",\n    value: function () {\n      var _getConversationByUniqueName = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(uniqueName) {\n        var links, url, response, body, sid, data;\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.services.session.getSessionLinks();\n\n              case 2:\n                links = _context3.sent;\n                url = new UriBuilder(links.myChannelsUrl).path(uniqueName).build();\n                _context3.next = 6;\n                return this.services.network.get(url);\n\n              case 6:\n                response = _context3.sent;\n                body = response.body;\n                sid = body.channel_sid;\n                data = {\n                  entityName: null,\n                  lastConsumedMessageIndex: body.last_consumed_message_index,\n                  status: (body === null || body === void 0 ? void 0 : body.status) || 'unknown',\n                  friendlyName: body.friendly_name,\n                  dateUpdated: body.date_updated,\n                  dateCreated: body.date_created,\n                  uniqueName: body.unique_name,\n                  createdBy: body.created_by,\n                  attributes: body.attributes,\n                  channel: \"\".concat(sid, \".channel\"),\n                  notificationLevel: body === null || body === void 0 ? void 0 : body.notification_level,\n                  sid: sid\n                };\n                return _context3.abrupt(\"return\", this.upsertConversation('sync', sid, data));\n\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getConversationByUniqueName(_x3) {\n        return _getConversationByUniqueName.apply(this, arguments);\n      }\n\n      return getConversationByUniqueName;\n    }()\n  }, {\n    key: \"getWhisperConversation\",\n    value: function () {\n      var _getWhisperConversation = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4(sid) {\n        var _state, _state$stateV;\n\n        var links, url, response, body, state, data;\n        return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.services.session.getSessionLinks();\n\n              case 2:\n                links = _context4.sent;\n                url = new UriBuilder(links.publicChannelsUrl).path(sid).build();\n                _context4.next = 6;\n                return this.services.network.get(url);\n\n              case 6:\n                response = _context4.sent;\n                body = response.body;\n\n                if (!(body.type !== 'private')) {\n                  _context4.next = 10;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 10:\n                // If the state property is a string, it's expected to be a string that represents\n                // a JSON object.\n                if (typeof body.state === 'string') {\n                  state = JSON.parse(body.state);\n                } // If the state property is already a non-nullable object, then no JSON parsing is\n                // required.\n\n\n                if (_typeof__default['default'](body.state) === 'object' && body.state !== null) {\n                  state = body.state;\n                }\n\n                if (!(((_state = state) === null || _state === void 0 ? void 0 : (_state$stateV = _state['state.v1']) === null || _state$stateV === void 0 ? void 0 : _state$stateV.current) === 'closed')) {\n                  _context4.next = 14;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 14:\n                data = {\n                  entityName: null,\n                  lastConsumedMessageIndex: body.last_consumed_message_index,\n                  status: (body === null || body === void 0 ? void 0 : body.status) || 'unknown',\n                  friendlyName: body.friendly_name,\n                  dateUpdated: body.date_updated,\n                  dateCreated: body.date_created,\n                  uniqueName: body.unique_name,\n                  createdBy: body.created_by,\n                  attributes: body.attributes,\n                  channel: \"\".concat(sid, \".channel\"),\n                  notificationLevel: body === null || body === void 0 ? void 0 : body.notification_level,\n                  sid: sid\n                };\n                return _context4.abrupt(\"return\", this.upsertConversation('sync', sid, data));\n\n              case 16:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getWhisperConversation(_x4) {\n        return _getWhisperConversation.apply(this, arguments);\n      }\n\n      return getWhisperConversation;\n    }()\n  }, {\n    key: \"upsertConversation\",\n    value: function upsertConversation(source, sid, data) {\n      var _this7 = this;\n\n      log$3.trace('upsertConversation(sid=' + sid + ', data=', data);\n      var conversation = this.conversations.get(sid); // Update the Conversation's status if we know about it\n\n      if (conversation) {\n        log$3.trace('upsertConversation: conversation ' + sid + ' is known and it\\'s' + ' status is known from source ' + conversation._statusSource() + ' and update came from source ' + source, conversation);\n\n        if (typeof conversation._statusSource() === 'undefined' || source === conversation._statusSource() || source === 'synclist' && conversation._statusSource() !== 'sync' || source === 'sync') {\n          if (data.status === 'joined' && conversation.status !== 'joined') {\n            conversation._setStatus('joined', source);\n\n            var updateData = {};\n\n            if (typeof data.notificationLevel !== 'undefined') {\n              updateData.notificationLevel = data.notificationLevel;\n            }\n\n            if (typeof data.lastConsumedMessageIndex !== 'undefined') {\n              updateData.lastConsumedMessageIndex = data.lastConsumedMessageIndex;\n            }\n\n            if (!isDeepEqual(updateData, {})) {\n              conversation._update(updateData);\n            }\n\n            conversation._subscribe().then(function () {\n              _this7.emit('conversationJoined', conversation);\n            });\n          } else if (data.status === 'notParticipating' && conversation.status === 'joined') {\n            conversation._setStatus('notParticipating', source);\n\n            conversation._update(data);\n\n            conversation._subscribe().then(function () {\n              _this7.emit('conversationLeft', conversation);\n            });\n          } else if (data.status === 'notParticipating') {\n            conversation._subscribe();\n          } else {\n            conversation._update(data);\n          }\n        } else {\n          log$3.trace('upsertConversation: conversation is known from sync and came from chat, ignoring', {\n            sid: sid,\n            data: data.status,\n            conversation: conversation.status\n          });\n        }\n\n        return conversation._subscribe().then(function () {\n          return conversation;\n        });\n      }\n\n      if ((source === 'chat' || source === 'synclist') && this.thumbstones.has(sid)) {\n        // if conversation was deleted, we ignore it\n        log$3.trace('upsertConversation: conversation is deleted and came again from chat, ignoring', sid);\n        return;\n      } // Fetch the Conversation if we don't know about it\n\n\n      log$3.trace('upsertConversation: creating local conversation object with sid ' + sid, data);\n      conversation = new Conversation(this.services, data, sid);\n      this.conversations.set(sid, conversation);\n      return conversation._subscribe().then(function () {\n        _this7.registerForEvents(conversation);\n\n        _this7.emit('conversationAdded', conversation);\n\n        if (data.status === 'joined') {\n          conversation._setStatus('joined', source);\n\n          _this7.emit('conversationJoined', conversation);\n        }\n\n        return conversation;\n      });\n    }\n  }, {\n    key: \"onConversationRemoved\",\n    value: function onConversationRemoved(sid) {\n      var conversation = this.conversations.get(sid);\n\n      if (conversation) {\n        this.conversations.delete(sid);\n        this.emit('conversationRemoved', conversation);\n      }\n    }\n  }, {\n    key: \"registerForEvents\",\n    value: function registerForEvents(conversation) {\n      var _this8 = this;\n\n      conversation.on('removed', function () {\n        return _this8.onConversationRemoved(conversation.sid);\n      });\n      conversation.on('updated', function (args) {\n        return _this8.emit('conversationUpdated', args);\n      });\n      conversation.on('participantJoined', this.emit.bind(this, 'participantJoined'));\n      conversation.on('participantLeft', this.emit.bind(this, 'participantLeft'));\n      conversation.on('participantUpdated', function (args) {\n        return _this8.emit('participantUpdated', args);\n      });\n      conversation.on('messageAdded', this.emit.bind(this, 'messageAdded'));\n      conversation.on('messageUpdated', function (args) {\n        return _this8.emit('messageUpdated', args);\n      });\n      conversation.on('messageRemoved', this.emit.bind(this, 'messageRemoved'));\n      conversation.on('typingStarted', this.emit.bind(this, 'typingStarted'));\n      conversation.on('typingEnded', this.emit.bind(this, 'typingEnded'));\n    }\n  }]);\n\n  return Conversations;\n}(EventEmitter);\n\nfunction _createSuper$2(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$2() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar log$2 = Logger.scope('User');\n/**\n * @classdesc Extended user information.\n * Note that <code>isOnline</code> and <code>isNotifiable</code> properties are eligible\n * to use only if reachability function is enabled.\n * You may check if it is enabled by reading value of {@link Client}'s <code>reachabilityEnabled</code> property.\n *\n * @property {String} identity - User identity\n * @property {String} friendlyName - User friendly name, null if not set\n * @property {any} attributes - Object with custom attributes for user\n * @property {Boolean} isOnline - User real-time conversation connection status\n * @property {Boolean} isNotifiable - User push notification registration status\n * @property {Boolean} isSubscribed - Check if this user receives real-time status updates\n *\n * @fires User#updated\n * @fires User#userSubscribed\n * @fires User#userUnsubscribed\n *\n * @constructor\n * @param {String} identity - Identity of user\n * @param {String} entityId - id of user's object\n * @param {Object} datasync - datasync service\n * @param {Object} session - session service\n */\n\nvar User = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](User, _EventEmitter);\n\n  var _super = _createSuper$2(User);\n  /**\n   * The update reason for <code>updated</code> event emitted on User\n   * @typedef {('friendlyName' | 'attributes' | 'reachabilityOnline' | 'reachabilityNotifiable')} User#UpdateReason\n   */\n\n\n  function User(identity, entityName, services) {\n    var _this;\n\n    _classCallCheck__default['default'](this, User);\n\n    _this = _super.call(this);\n    _this.subscribed = 'initializing';\n\n    _this.setMaxListeners(0);\n\n    _this.services = services;\n    _this.state = {\n      identity: identity,\n      entityName: entityName,\n      friendlyName: null,\n      attributes: {},\n      online: null,\n      notifiable: null\n    };\n    return _this;\n  }\n\n  _createClass__default['default'](User, [{\n    key: \"identity\",\n    get: function get() {\n      return this.state.identity;\n    },\n    set: function set(identity) {\n      this.state.identity = identity;\n    }\n  }, {\n    key: \"entityName\",\n    set: function set(name) {\n      this.state.entityName = name;\n    }\n  }, {\n    key: \"attributes\",\n    get: function get() {\n      return this.state.attributes;\n    }\n  }, {\n    key: \"friendlyName\",\n    get: function get() {\n      return this.state.friendlyName;\n    }\n  }, {\n    key: \"isOnline\",\n    get: function get() {\n      return this.state.online;\n    }\n  }, {\n    key: \"isNotifiable\",\n    get: function get() {\n      return this.state.notifiable;\n    }\n  }, {\n    key: \"isSubscribed\",\n    get: function get() {\n      return this.subscribed == 'subscribed';\n    } // Handles service updates\n\n  }, {\n    key: \"_update\",\n    value: function _update(key, value) {\n      var updateReasons = [];\n      log$2.debug('User for', this.state.identity, 'updated:', key, value);\n\n      switch (key) {\n        case 'friendlyName':\n          if (this.state.friendlyName !== value.value) {\n            updateReasons.push('friendlyName');\n            this.state.friendlyName = value.value;\n          }\n\n          break;\n\n        case 'attributes':\n          var updateAttributes = parseAttributes(value.value, \"Retrieved malformed attributes from the server for user: \".concat(this.state.identity), log$2);\n\n          if (!isDeepEqual(this.state.attributes, updateAttributes)) {\n            this.state.attributes = updateAttributes;\n            updateReasons.push('attributes');\n          }\n\n          break;\n\n        case 'reachability':\n          if (this.state.online !== value.online) {\n            this.state.online = value.online;\n            updateReasons.push('reachabilityOnline');\n          }\n\n          if (this.state.notifiable !== value.notifiable) {\n            this.state.notifiable = value.notifiable;\n            updateReasons.push('reachabilityNotifiable');\n          }\n\n          break;\n\n        default:\n          return;\n      }\n\n      if (updateReasons.length > 0) {\n        this.emit('updated', {\n          user: this,\n          updateReasons: updateReasons\n        });\n      }\n    } // Fetch reachability info\n\n  }, {\n    key: \"_updateReachabilityInfo\",\n    value: function _updateReachabilityInfo(map, update) {\n      var _this2 = this;\n\n      if (!this.services.session.reachabilityEnabled) {\n        return Promise.resolve();\n      }\n\n      return map.get('reachability').then(update).catch(function (err) {\n        log$2.warn('Failed to get reachability info for ', _this2.state.identity, err);\n      });\n    } // Fetch user\n\n  }, {\n    key: \"_fetch\",\n    value: function () {\n      var _fetch2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {\n        var _this3 = this;\n\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.state.entityName) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this);\n\n              case 2:\n                this.promiseToFetch = this.services.syncClient.map({\n                  id: this.state.entityName,\n                  mode: 'open_existing',\n                  includeItems: true\n                }).then(function (map) {\n                  _this3.entity = map;\n                  map.on('itemUpdated', function (args) {\n                    log$2.debug(_this3.state.entityName + ' (' + _this3.state.identity + ') itemUpdated: ' + args.item.key);\n                    return _this3._update(args.item.key, args.item.data);\n                  });\n                  return Promise.all([map.get('friendlyName').then(function (item) {\n                    return _this3._update(item.key, item.data);\n                  }), map.get('attributes').then(function (item) {\n                    return _this3._update(item.key, item.data);\n                  }), _this3._updateReachabilityInfo(map, function (item) {\n                    return _this3._update(item.key, item.data);\n                  })]);\n                }).then(function () {\n                  log$2.debug('Fetched for', _this3.identity);\n                  _this3.subscribed = 'subscribed';\n\n                  _this3.emit('userSubscribed', _this3);\n\n                  return _this3;\n                }).catch(function (err) {\n                  _this3.promiseToFetch = null;\n                  throw err;\n                });\n                return _context.abrupt(\"return\", this.promiseToFetch);\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _fetch() {\n        return _fetch2.apply(this, arguments);\n      }\n\n      return _fetch;\n    }()\n  }, {\n    key: \"_ensureFetched\",\n    value: function _ensureFetched() {\n      return this.promiseToFetch || this._fetch();\n    }\n    /**\n     * Updates user attributes.\n     * @param {any} attributes new attributes for User.\n     * @returns {Promise<User>}\n     */\n\n  }, {\n    key: \"updateAttributes\",\n    value: function () {\n      var _updateAttributes = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(attributes) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this.subscribed == 'unsubscribed')) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new Error('Can\\'t modify unsubscribed object');\n\n              case 2:\n                _context2.next = 4;\n                return this.services.session.addCommand('editUserAttributes', {\n                  username: this.state.identity,\n                  attributes: JSON.stringify(attributes)\n                });\n\n              case 4:\n                return _context2.abrupt(\"return\", this);\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function updateAttributes(_x) {\n        return _updateAttributes.apply(this, arguments);\n      }\n\n      return updateAttributes;\n    }()\n    /**\n     * Update Users friendlyName.\n     * @param {String|null} friendlyName - Updated friendlyName\n     * @returns {Promise<User>}\n     */\n\n  }, {\n    key: \"updateFriendlyName\",\n    value: function () {\n      var _updateFriendlyName = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(friendlyName) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(this.subscribed == 'unsubscribed')) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                throw new Error('Can\\'t modify unsubscribed object');\n\n              case 2:\n                _context3.next = 4;\n                return this.services.session.addCommand('editUserFriendlyName', {\n                  username: this.state.identity,\n                  friendlyName: friendlyName\n                });\n\n              case 4:\n                return _context3.abrupt(\"return\", this);\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function updateFriendlyName(_x2) {\n        return _updateFriendlyName.apply(this, arguments);\n      }\n\n      return updateFriendlyName;\n    }()\n    /**\n     * Removes User from subscription list.\n     * @returns {Promise<void>} Promise of completion\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function () {\n      var _unsubscribe = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!this.promiseToFetch) {\n                  _context4.next = 7;\n                  break;\n                }\n\n                _context4.next = 3;\n                return this.promiseToFetch;\n\n              case 3:\n                this.entity.close();\n                this.promiseToFetch = null;\n                this.subscribed = 'unsubscribed';\n                this.emit('userUnsubscribed', this);\n\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function unsubscribe() {\n        return _unsubscribe.apply(this, arguments);\n      }\n\n      return unsubscribe;\n    }()\n  }]);\n\n  return User;\n}(EventEmitter);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(['string', 'number', 'boolean', 'object', twilioSdkTypeValidator.literal(null)]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Promise)], User.prototype, \"updateAttributes\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(['string', twilioSdkTypeValidator.literal(null)]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], User.prototype, \"updateFriendlyName\", null);\n/**\n * Fired when User's properties or reachability status have been updated.\n * @event User#updated\n * @type {Object}\n * @property {User} user - Updated User\n * @property {User#UpdateReason[]} updateReasons - Array of User's updated event reasons\n */\n\n/**\n * Fired when Client is subscribed to User.\n * @event User#userSubscribed\n * @type {User}\n */\n\n/**\n * Fired when Client is unsubscribed from this User.\n * @event User#userUnsubscribed\n * @type {User}\n */\n\n\nfunction _createSuper$1(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$1() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * @classdesc Container for known users\n * @fires Users#userUpdated\n */\n\n\nvar Users = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](Users, _EventEmitter);\n\n  var _super = _createSuper$1(Users);\n\n  function Users(services) {\n    var _this;\n\n    _classCallCheck__default['default'](this, Users);\n\n    _this = _super.call(this);\n    _this.services = services;\n    _this.fifoStack = [];\n    _this.fifoStackMaxLength = 100;\n    _this.myself = new User(null, null, _this.services);\n\n    _this.myself.on('updated', function (args) {\n      return _this.emit('userUpdated', args);\n    });\n\n    _this.myself.on('userSubscribed', function () {\n      return _this.emit('userSubscribed', _this.myself);\n    });\n\n    _this.myself.on('userUnsubscribed', function () {\n      _this.emit('userUnsubscribed', _this.myself);\n\n      _this.myself._ensureFetched();\n    });\n\n    _this.services = services;\n    _this.subscribedUsers = new Map();\n    _this.userUrlPromise = _this.services.session.getSessionLinks().then(function (links) {\n      _this.userUrl = links.usersUrl;\n      return _this.userUrl;\n    });\n\n    _this.services.session.getMaxUserInfosToSubscribe().then(function (maxUserInfosToSubscribe) {\n      _this.fifoStackMaxLength = maxUserInfosToSubscribe;\n    });\n\n    _this.services.session.getUsersData().then(function (data) {\n      _this.myself.identity = data.identity;\n      _this.myself.entityName = data.user;\n      return _this.myself._ensureFetched();\n    });\n\n    return _this;\n  }\n\n  _createClass__default['default'](Users, [{\n    key: \"handleUnsubscribeUser\",\n    value: function handleUnsubscribeUser(user) {\n      if (this.subscribedUsers.has(user.identity)) {\n        this.subscribedUsers.delete(user.identity);\n      }\n\n      var foundItemIndex = -1;\n      var foundItem = this.fifoStack.find(function (item, index) {\n        if (item == user.identity) {\n          foundItemIndex = index;\n          return true;\n        }\n\n        return false;\n      });\n\n      if (foundItem) {\n        this.fifoStack.splice(foundItemIndex, 1);\n      }\n\n      this.emit('userUnsubscribed', user);\n    }\n  }, {\n    key: \"handleSubscribeUser\",\n    value: function handleSubscribeUser(user) {\n      if (this.subscribedUsers.has(user.identity)) {\n        return;\n      }\n\n      if (this.fifoStack.length >= this.fifoStackMaxLength) {\n        this.subscribedUsers.get(this.fifoStack.shift()).unsubscribe();\n      }\n\n      this.fifoStack.push(user.identity);\n      this.subscribedUsers.set(user.identity, user);\n      this.emit('userSubscribed', user);\n    }\n    /**\n     * Gets user, if it's in subscribed list - then return the user object from it,\n     * if not - then subscribes and adds user to the FIFO stack\n     * @returns {Promise<User>} Fully initialized user\n     */\n\n  }, {\n    key: \"getUser\",\n    value: function () {\n      var _getUser = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(identity) {\n        var _this2 = this;\n\n        var entityName,\n            user,\n            _args = arguments;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                entityName = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;\n                _context.next = 3;\n                return this.services.session.getUsersData();\n\n              case 3:\n                _context.next = 5;\n                return this.myself._ensureFetched();\n\n              case 5:\n                if (!(identity == this.myself.identity)) {\n                  _context.next = 7;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this.myself);\n\n              case 7:\n                user = this.subscribedUsers.get(identity);\n\n                if (user) {\n                  _context.next = 19;\n                  break;\n                }\n\n                if (entityName) {\n                  _context.next = 13;\n                  break;\n                }\n\n                _context.next = 12;\n                return this.getSyncUniqueName(identity);\n\n              case 12:\n                entityName = _context.sent;\n\n              case 13:\n                user = new User(identity, entityName, this.services);\n                user.on('updated', function (args) {\n                  return _this2.emit('userUpdated', args);\n                });\n                user.on('userSubscribed', function () {\n                  return _this2.handleSubscribeUser(user);\n                });\n                user.on('userUnsubscribed', function () {\n                  return _this2.handleUnsubscribeUser(user);\n                });\n                _context.next = 19;\n                return user._ensureFetched();\n\n              case 19:\n                return _context.abrupt(\"return\", user);\n\n              case 20:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getUser(_x) {\n        return _getUser.apply(this, arguments);\n      }\n\n      return getUser;\n    }()\n    /**\n     * @returns {Promise<Array<User>>} returns list of subscribed User objects {@see User}\n     */\n\n  }, {\n    key: \"getSubscribedUsers\",\n    value: function () {\n      var _getSubscribedUsers = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {\n        var users;\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.services.session.getUsersData();\n\n              case 2:\n                _context2.next = 4;\n                return this.myself._ensureFetched();\n\n              case 4:\n                users = [this.myself];\n                this.subscribedUsers.forEach(function (user) {\n                  return users.push(user);\n                });\n                return _context2.abrupt(\"return\", users);\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getSubscribedUsers() {\n        return _getSubscribedUsers.apply(this, arguments);\n      }\n\n      return getSubscribedUsers;\n    }()\n    /**\n     * @returns {Promise<string>} User's sync unique name\n     */\n\n  }, {\n    key: \"getSyncUniqueName\",\n    value: function () {\n      var _getSyncUniqueName = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(identity) {\n        var url, response;\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                url = new UriBuilder(this.userUrl).path(identity).build();\n                _context3.next = 3;\n                return this.services.network.get(url);\n\n              case 3:\n                response = _context3.sent;\n                return _context3.abrupt(\"return\", response.body.sync_unique_name);\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getSyncUniqueName(_x2) {\n        return _getSyncUniqueName.apply(this, arguments);\n      }\n\n      return getSyncUniqueName;\n    }()\n  }]);\n\n  return Users;\n}(EventEmitter);\n\nvar log$1 = Logger.scope('TypingIndicator');\n/**\n * An important note in regards to typing timeout timers. There are two places that the SDK can get the \"typing_timeout\" attribute from. The first\n * place that the attribute appears in is the response received from POST -> /v1/typing REST call. In the body of that response, the value of the\n * \"typing_timeout\" attribute will be exactly the same as defined in the console. The second place that the attribute appears in is from a\n * notification of type \"twilio.ipmsg.typing_indicator\". In this case, the \"typing_timeout\" value will be +1 of that in the console. This\n * intentional. The timeout returned from the POST -> /v1/typing call should be used to disable further calls for that period of time. On contrary,\n * the timeout returned from the notification should be used as the timeout for the \"typingEnded\" event, +1 is to account for latency.\n *\n * @private\n */\n\n/**\n * @class TypingIndicator\n *\n * @constructor\n * @private\n */\n\nvar TypingIndicator = /*#__PURE__*/function () {\n  function TypingIndicator(config, services, getConversation) {\n    _classCallCheck__default['default'](this, TypingIndicator);\n\n    this.config = config;\n    this.services = services;\n    this.getConversation = getConversation;\n    this.serviceTypingTimeout = null;\n    this.sentUpdates = new Map();\n  }\n\n  _createClass__default['default'](TypingIndicator, [{\n    key: \"typingTimeout\",\n    get: function get() {\n      return this.config.typingIndicatorTimeoutOverride || this.serviceTypingTimeout || this.config.typingIndicatorTimeoutDefault;\n    }\n    /**\n     * Initialize TypingIndicator controller\n     * Registers for needed message types and sets listeners\n     * @private\n     */\n\n  }, {\n    key: \"initialize\",\n    value: function initialize() {\n      var _this = this;\n\n      this.services.notificationClient.subscribe(NotificationTypes.TYPING_INDICATOR, 'twilsock');\n      this.services.notificationClient.on('message', function (type, message) {\n        if (type === NotificationTypes.TYPING_INDICATOR) {\n          _this.handleRemoteTyping(message);\n        }\n      });\n    }\n    /**\n     * Remote participants typing events handler\n     * @private\n     */\n\n  }, {\n    key: \"handleRemoteTyping\",\n    value: function handleRemoteTyping(message) {\n      var _this2 = this;\n\n      log$1.trace('Got new typing indicator ', message);\n      this.getConversation(message.channel_sid).then(function (conversation) {\n        if (!conversation) {\n          return;\n        }\n\n        conversation.participants.forEach(function (participant) {\n          if (participant.identity !== message.identity) {\n            return;\n          }\n\n          var timeout = _this2.config.typingIndicatorTimeoutOverride + 1000 || message.typing_timeout * 1000;\n\n          participant._startTyping(timeout);\n        });\n      }).catch(function (err) {\n        log$1.error(err);\n        throw err;\n      });\n    }\n    /**\n     * Send typing event for the given conversation sid\n     * @param {String} conversationSid\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(conversationSid) {\n      var lastUpdate = this.sentUpdates.get(conversationSid);\n\n      if (lastUpdate && lastUpdate > Date.now() - this.typingTimeout) {\n        return Promise.resolve();\n      }\n\n      this.sentUpdates.set(conversationSid, Date.now());\n      return this._send(conversationSid);\n    }\n  }, {\n    key: \"_send\",\n    value: function _send(conversationSid) {\n      var _this3 = this;\n\n      log$1.trace('Sending typing indicator');\n      var url = this.config.typingIndicatorUri;\n      var headers = {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      };\n      var body = 'ChannelSid=' + conversationSid;\n      return this.services.transport.post(url, headers, body, this.config.productId).then(function (response) {\n        if (response.body.hasOwnProperty('typing_timeout')) {\n          _this3.serviceTypingTimeout = response.body.typing_timeout * 1000;\n        }\n      }).catch(function (err) {\n        log$1.error('Failed to send typing indicator:', err);\n        throw err;\n      });\n    }\n  }]);\n\n  return TypingIndicator;\n}();\n/**\n * @classdesc Provides read horizon management functionality\n */\n\n\nvar ReadHorizon = /*#__PURE__*/function () {\n  function ReadHorizon(services) {\n    _classCallCheck__default['default'](this, ReadHorizon);\n\n    this.services = services;\n    this.readHorizonRequests = new Map();\n    this.readHorizonUpdateTimer = null;\n  }\n\n  _createClass__default['default'](ReadHorizon, [{\n    key: \"getReportInterval\",\n    value: function getReportInterval() {\n      return this.services.session.getConsumptionReportInterval().then(function (seconds) {\n        return seconds * 1000;\n      });\n    }\n  }, {\n    key: \"delayedSendReadHorizon\",\n    value: function delayedSendReadHorizon(delay) {\n      var _this = this;\n\n      if (this.readHorizonUpdateTimer !== null) {\n        return;\n      }\n\n      this.sendConsumptionReport(true);\n      this.readHorizonUpdateTimer = setTimeout(function () {\n        _this.sendConsumptionReport(false);\n      }, delay);\n    }\n  }, {\n    key: \"sendConsumptionReport\",\n    value: function sendConsumptionReport(keepTimer) {\n      var _this2 = this;\n\n      var reports = [];\n      var promises = new Map();\n      this.readHorizonRequests.forEach(function (request, conversationSid) {\n        reports.push(request.entry);\n        promises.set(conversationSid, request.promises);\n      });\n\n      if (reports.length > 0) {\n        this.services.session.addCommand('consumptionReportV2', {\n          report: reports\n        }).then(function (response) {\n          return _this2.processConsumptionReportResponse(response, promises);\n        }).catch(function (err) {\n          return _this2.processConsumptionReportError(err, promises);\n        });\n      }\n\n      if (!keepTimer) {\n        this.readHorizonUpdateTimer = null;\n      }\n\n      this.readHorizonRequests.clear();\n    }\n  }, {\n    key: \"processConsumptionReportResponse\",\n    value: function processConsumptionReportResponse(response, promises) {\n      if (response && response.report && Array.isArray(response.report) && response.report.length > 0) {\n        response.report.forEach(function (entry) {\n          var responseEntry = entry;\n\n          if (promises.has(responseEntry.channelSid)) {\n            var unreadMessagesCount = null;\n\n            if (typeof responseEntry.unreadMessagesCount !== 'undefined' && responseEntry.unreadMessagesCount != null) {\n              unreadMessagesCount = responseEntry.unreadMessagesCount;\n            }\n\n            promises.get(responseEntry.channelSid).forEach(function (promise) {\n              return promise.resolve(unreadMessagesCount);\n            });\n            promises.delete(responseEntry.channelSid);\n          }\n        });\n      }\n\n      this.processConsumptionReportError(new SessionError('Error while setting LastReadMessageIndex', null), promises);\n    }\n  }, {\n    key: \"processConsumptionReportError\",\n    value: function processConsumptionReportError(err, promises) {\n      promises.forEach(function (conversationPromises) {\n        return conversationPromises.forEach(function (promise) {\n          return promise.reject(err);\n        });\n      });\n    }\n    /**\n     * Updates read horizon value without any checks\n     */\n\n  }, {\n    key: \"updateLastReadMessageIndexForConversation\",\n    value: function updateLastReadMessageIndexForConversation(conversationSid, messageIdx) {\n      var _this3 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this3.addPendingConsumptionHorizonRequest(conversationSid, {\n          channelSid: conversationSid,\n          messageIdx: messageIdx\n        }, {\n          resolve: resolve,\n          reject: reject\n        });\n\n        _this3.getReportInterval().then(function (delay) {\n          return _this3.delayedSendReadHorizon(delay);\n        });\n      });\n    }\n    /**\n     * Move read horizon forward\n     */\n\n  }, {\n    key: \"advanceLastReadMessageIndexForConversation\",\n    value: function advanceLastReadMessageIndexForConversation(conversationSid, messageIdx, currentConversationLastReadIndex) {\n      var _this4 = this;\n\n      var currentHorizon = this.readHorizonRequests.get(conversationSid);\n      return new Promise(function (resolve, reject) {\n        if (currentHorizon && currentHorizon.entry) {\n          if (currentHorizon.entry.messageIdx >= messageIdx) {\n            _this4.addPendingConsumptionHorizonRequest(conversationSid, currentHorizon.entry, {\n              resolve: resolve,\n              reject: reject\n            });\n          } else {\n            _this4.addPendingConsumptionHorizonRequest(conversationSid, {\n              channelSid: conversationSid,\n              messageIdx: messageIdx\n            }, {\n              resolve: resolve,\n              reject: reject\n            });\n          }\n        } else {\n          if (currentConversationLastReadIndex !== null && messageIdx < currentConversationLastReadIndex) {\n            _this4.addPendingConsumptionHorizonRequest(conversationSid, {\n              channelSid: conversationSid,\n              messageIdx: currentConversationLastReadIndex\n            }, {\n              resolve: resolve,\n              reject: reject\n            });\n          } else {\n            _this4.addPendingConsumptionHorizonRequest(conversationSid, {\n              channelSid: conversationSid,\n              messageIdx: messageIdx\n            }, {\n              resolve: resolve,\n              reject: reject\n            });\n          }\n        }\n\n        _this4.getReportInterval().then(function (delay) {\n          return _this4.delayedSendReadHorizon(delay);\n        });\n      });\n    }\n  }, {\n    key: \"addPendingConsumptionHorizonRequest\",\n    value: function addPendingConsumptionHorizonRequest(conversationSid, entry, promise) {\n      if (this.readHorizonRequests.has(conversationSid)) {\n        var request = this.readHorizonRequests.get(conversationSid);\n        request.entry = entry;\n        request.promises.push(promise);\n      } else {\n        this.readHorizonRequests.set(conversationSid, {\n          entry: entry,\n          promises: [promise]\n        });\n      }\n    }\n  }]);\n\n  return ReadHorizon;\n}();\n\nvar PushNotification =\n/**\n * Conversation push notification type\n * @typedef {('twilio.conversations.new_message' | 'twilio.conversations.added_to_conversation'\n | 'twilio.conversations.removed_from_conversation')} PushNotification#NotificationType\n */\n\n/**\n * Additional Conversations data for given Push Notification\n * @typedef {Object} PushNotification#ConversationData\n * @property {String} [conversationSid] - SID of Conversation\n * @property {Number} [messageIndex] - Index of Message in Conversation\n * @property {String} [messageSid] - SID of Message\n */\n\n/**\n * @param {PushNotification.Descriptor} data - initial data for PushNotification\n */\nfunction PushNotification(data) {\n  _classCallCheck__default['default'](this, PushNotification);\n\n  this.title = data.title || null;\n  this.body = data.body || null;\n  this.sound = data.sound || null;\n  this.badge = data.badge || null;\n  this.action = data.action || null;\n  this.type = data.type || null;\n  this.data = data.data || {};\n};\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty__default['default'](target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar log = Logger.scope('Client');\nvar SDK_VERSION = version;\n\nvar ClientServices = function ClientServices() {\n  _classCallCheck__default['default'](this, ClientServices);\n};\n/**\n * A Client is a starting point to access Twilio Conversations functionality.\n *\n * @property {Client#ConnectionState} connectionState - Client connection state\n * @property {Boolean} reachabilityEnabled - Client reachability state\n * @property {User} user - Information for logged in user\n * @property {String} version - Current version of Conversations client\n *\n * @fires Client#connectionError\n * @fires Client#connectionStateChanged\n * @fires Client#conversationAdded\n * @fires Client#conversationJoined\n * @fires Client#conversationLeft\n * @fires Client#conversationRemoved\n * @fires Client#conversationUpdated\n * @fires Client#participantJoined\n * @fires Client#participantLeft\n * @fires Client#participantUpdated\n * @fires Client#messageAdded\n * @fires Client#messageRemoved\n * @fires Client#messageUpdated\n * @fires Client#pushNotification\n * @fires Client#tokenAboutToExpire\n * @fires Client#tokenExpired\n * @fires Client#typingEnded\n * @fires Client#typingStarted\n * @fires Client#userSubscribed\n * @fires Client#userUnsubscribed\n * @fires Client#userUpdated\n */\n\n\nvar Client = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](Client, _EventEmitter);\n\n  var _super = _createSuper(Client);\n  /**\n   * These options can be passed to Client constructor.\n   * @typedef {Object} Client#ClientOptions\n   * @property {String} [logLevel='error'] - The level of logging to enable. Valid options\n   *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']\n   */\n\n  /**\n   * These options can be passed to {@link Client#createConversation}.\n   * @typedef {Object} Client#CreateConversationOptions\n   * @property {any} [attributes] - Any custom attributes to attach to the Conversation\n   * @property {String} [friendlyName] - The non-unique display name of the Conversation\n   * @property {String} [uniqueName] - The unique identifier of the Conversation\n   */\n\n  /**\n   * Connection state of Client.\n   * @typedef {('connecting'|'connected'|'disconnecting'|'disconnected'|'denied')} Client#ConnectionState\n   */\n\n  /**\n   * Notifications channel type.\n   * @typedef {('fcm'|'apn')} Client#NotificationsChannelType\n   */\n\n\n  function Client(token, options) {\n    var _this;\n\n    _classCallCheck__default['default'](this, Client);\n\n    _this = _super.call(this);\n\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"connectionState\", 'connecting');\n\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"sessionPromise\", null);\n\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"conversationsPromise\", null);\n\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"version\", SDK_VERSION);\n\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"parsePushNotification\", Client.parsePushNotification);\n\n    _this.options = options || {};\n\n    if (!_this.options.disableDeepClone) {\n      var _options = _objectSpread(_objectSpread({}, _this.options), {}, {\n        transport: undefined,\n        twilsockClient: undefined\n      });\n\n      _options = deepClone(_options);\n      _options.transport = _this.options.transport;\n      _options.twilsockClient = _this.options.twilsockClient;\n      _this.options = _options;\n    }\n\n    _this.options.logLevel = _this.options.logLevel || 'silent';\n    log.setLevel(_this.options.logLevel);\n    var productId = _this.options.productId = 'ip_messaging'; // Filling ClientMetadata\n\n    _this.options.clientMetadata = _this.options.clientMetadata || {};\n\n    if (!_this.options.clientMetadata.hasOwnProperty('type')) {\n      _this.options.clientMetadata.type = 'conversations';\n    }\n\n    if (!_this.options.clientMetadata.hasOwnProperty('sdk')) {\n      _this.options.clientMetadata.sdk = 'JS';\n      _this.options.clientMetadata.sdkv = SDK_VERSION;\n    } // Enable session local storage for Sync\n\n\n    _this.options.Sync = _this.options.Sync || {};\n\n    if (typeof _this.options.Sync.enableSessionStorage === 'undefined') {\n      _this.options.Sync.enableSessionStorage = true;\n    }\n\n    if (_this.options.region) {\n      _this.options.Sync.region = _this.options.region;\n    }\n\n    if (!token) {\n      throw new Error('A valid Twilio token should be provided');\n    }\n\n    _this.services = new ClientServices();\n    _this.config = new Configuration(_this.options);\n    _this.options.twilsockClient = _this.options.twilsockClient || new twilsock.Twilsock(token, productId, _this.options);\n    _this.options.transport = _this.options.transport || _this.options.twilsockClient;\n    _this.options.notificationsClient = _this.options.notificationsClient || new twilioNotifications.Notifications(token, _this.options);\n    _this.options.syncClient = _this.options.syncClient || new twilioSync.SyncClient(token, _this.options);\n    _this.services.syncClient = _this.options.syncClient;\n    _this.services.transport = _this.options.transport;\n    _this.services.twilsockClient = _this.options.twilsockClient;\n    _this.services.notificationClient = _this.options.notificationsClient;\n    _this.services.session = new Session(_this.services, _this.config);\n    _this.sessionPromise = _this.services.session.initialize();\n    _this.services.network = new Network(_this.config, _this.services);\n    _this.services.users = new Users({\n      session: _this.services.session,\n      network: _this.services.network,\n      syncClient: _this.services.syncClient\n    });\n\n    _this.services.users.on('userSubscribed', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'userSubscribed'));\n\n    _this.services.users.on('userUpdated', function (args) {\n      return _this.emit('userUpdated', args);\n    });\n\n    _this.services.users.on('userUnsubscribed', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'userUnsubscribed'));\n\n    _this.services.twilsockClient.on('tokenAboutToExpire', function (ttl) {\n      return _this.emit('tokenAboutToExpire', ttl);\n    });\n\n    _this.services.twilsockClient.on('tokenExpired', function () {\n      return _this.emit('tokenExpired');\n    });\n\n    _this.services.twilsockClient.on('connectionError', function (error) {\n      return _this.emit('connectionError', error);\n    });\n\n    _this.services.readHorizon = new ReadHorizon(_this.services);\n    _this.services.typingIndicator = new TypingIndicator(_this.config, {\n      transport: _this.services.twilsockClient,\n      notificationClient: _this.services.notificationClient\n    }, _this.getConversationBySid.bind(_assertThisInitialized__default['default'](_this)));\n    _this.services.syncList = new SyncList(_this.services);\n    _this.conversations = new Conversations(_this.services);\n    _this.conversationsPromise = _this.sessionPromise.then(function () {\n      _this.conversations.on('conversationAdded', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'conversationAdded'));\n\n      _this.conversations.on('conversationRemoved', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'conversationRemoved'));\n\n      _this.conversations.on('conversationJoined', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'conversationJoined'));\n\n      _this.conversations.on('conversationLeft', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'conversationLeft'));\n\n      _this.conversations.on('conversationUpdated', function (args) {\n        return _this.emit('conversationUpdated', args);\n      });\n\n      _this.conversations.on('participantJoined', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'participantJoined'));\n\n      _this.conversations.on('participantLeft', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'participantLeft'));\n\n      _this.conversations.on('participantUpdated', function (args) {\n        return _this.emit('participantUpdated', args);\n      });\n\n      _this.conversations.on('messageAdded', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'messageAdded'));\n\n      _this.conversations.on('messageUpdated', function (args) {\n        return _this.emit('messageUpdated', args);\n      });\n\n      _this.conversations.on('messageRemoved', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'messageRemoved'));\n\n      _this.conversations.on('typingStarted', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'typingStarted'));\n\n      _this.conversations.on('typingEnded', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'typingEnded'));\n\n      return _this.conversations.fetchConversations();\n    }).then(function () {\n      return _this.conversations;\n    });\n\n    _this.services.notificationClient.on('connectionStateChanged', function (state) {\n      var changedConnectionState = null;\n\n      switch (state) {\n        case 'connected':\n          changedConnectionState = 'connected';\n          break;\n\n        case 'denied':\n          changedConnectionState = 'denied';\n          break;\n\n        case 'disconnecting':\n          changedConnectionState = 'disconnecting';\n          break;\n\n        case 'disconnected':\n          changedConnectionState = 'disconnected';\n          break;\n\n        default:\n          changedConnectionState = 'connecting';\n      }\n\n      if (changedConnectionState !== _this.connectionState) {\n        _this.connectionState = changedConnectionState;\n\n        _this.emit('connectionStateChanged', _this.connectionState);\n      }\n    });\n\n    _this.fpaToken = token;\n    return _this;\n  }\n  /**\n   * Factory method to create Conversations client instance.\n   *\n   * @param {String} token - Access token\n   * @param {Client#ClientOptions} [options] - Options to customize the Client\n   * @returns {Promise<Client>}\n   */\n\n\n  _createClass__default['default'](Client, [{\n    key: \"user\",\n    get: function get() {\n      return this.services.users.myself;\n    }\n  }, {\n    key: \"reachabilityEnabled\",\n    get: function get() {\n      return this.services.session.reachabilityEnabled;\n    }\n  }, {\n    key: \"token\",\n    get: function get() {\n      return this.fpaToken;\n    }\n  }, {\n    key: \"subscribeToPushNotifications\",\n    value: function subscribeToPushNotifications(channelType) {\n      var _this2 = this;\n\n      var subscriptions = [];\n      [NotificationTypes.NEW_MESSAGE, NotificationTypes.ADDED_TO_CONVERSATION, NotificationTypes.REMOVED_FROM_CONVERSATION, NotificationTypes.TYPING_INDICATOR, NotificationTypes.CONSUMPTION_UPDATE].forEach(function (messageType) {\n        subscriptions.push(_this2.services.notificationClient.subscribe(messageType, channelType));\n      });\n      return Promise.all(subscriptions);\n    }\n  }, {\n    key: \"unsubscribeFromPushNotifications\",\n    value: function unsubscribeFromPushNotifications(channelType) {\n      var _this3 = this;\n\n      var subscriptions = [];\n      [NotificationTypes.NEW_MESSAGE, NotificationTypes.ADDED_TO_CONVERSATION, NotificationTypes.REMOVED_FROM_CONVERSATION, NotificationTypes.TYPING_INDICATOR, NotificationTypes.CONSUMPTION_UPDATE].forEach(function (messageType) {\n        subscriptions.push(_this3.services.notificationClient.unsubscribe(messageType, channelType));\n      });\n      return Promise.all(subscriptions);\n    }\n  }, {\n    key: \"initialize\",\n    value: function () {\n      var _initialize = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {\n        var _this4 = this;\n\n        var links, options;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.sessionPromise;\n\n              case 2:\n                Client.supportedPushChannels.forEach(function (channelType) {\n                  return _this4.subscribeToPushNotifications(channelType);\n                });\n                _context.next = 5;\n                return this.services.session.getSessionLinks();\n\n              case 5:\n                links = _context.sent;\n                options = Object.assign(this.options);\n                options.transport = null;\n                this.services.mcsClient = new twilioMcsClient.McsClient(this.fpaToken, links.mediaServiceUrl, options);\n                _context.next = 11;\n                return this.services.typingIndicator.initialize();\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function initialize() {\n        return _initialize.apply(this, arguments);\n      }\n\n      return initialize;\n    }()\n    /**\n     * Gracefully shutting down library instance.\n     * @public\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"shutdown\",\n    value: function () {\n      var _shutdown = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.services.twilsockClient.disconnect();\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function shutdown() {\n        return _shutdown.apply(this, arguments);\n      }\n\n      return shutdown;\n    }()\n    /**\n     * Update the token used by the Client and re-register with Conversations services.\n     * @param {String} token - Access token\n     * @public\n     * @returns {Promise<Client>}\n     */\n\n  }, {\n    key: \"updateToken\",\n    value: function () {\n      var _updateToken = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(token) {\n        var _this5 = this;\n\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                log.info('updateToken');\n\n                if (!(this.fpaToken === token)) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", this);\n\n              case 3:\n                _context3.next = 5;\n                return this.services.twilsockClient.updateToken(token).then(function () {\n                  return _this5.fpaToken = token;\n                }).then(function () {\n                  return _this5.services.mcsClient.updateToken(token);\n                }).then(function () {\n                  return _this5.sessionPromise;\n                });\n\n              case 5:\n                return _context3.abrupt(\"return\", this);\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function updateToken(_x) {\n        return _updateToken.apply(this, arguments);\n      }\n\n      return updateToken;\n    }()\n    /**\n     * Get a known Conversation by its SID.\n     * @param {String} conversationSid - Conversation sid\n     * @returns {Promise<Conversation>}\n     */\n\n  }, {\n    key: \"getConversationBySid\",\n    value: function () {\n      var _getConversationBySid = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4(conversationSid) {\n        var conversation;\n        return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.conversations.syncListRead.promise;\n\n              case 2:\n                _context4.next = 4;\n                return this.conversations.getConversation(conversationSid);\n\n              case 4:\n                conversation = _context4.sent;\n\n                if (conversation) {\n                  _context4.next = 9;\n                  break;\n                }\n\n                _context4.next = 8;\n                return this.conversations.getWhisperConversation(conversationSid);\n\n              case 8:\n                conversation = _context4.sent;\n\n              case 9:\n                if (conversation) {\n                  _context4.next = 11;\n                  break;\n                }\n\n                throw new Error(\"Conversation with SID \".concat(conversationSid, \" is not found.\"));\n\n              case 11:\n                return _context4.abrupt(\"return\", conversation);\n\n              case 12:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getConversationBySid(_x2) {\n        return _getConversationBySid.apply(this, arguments);\n      }\n\n      return getConversationBySid;\n    }()\n    /**\n     * Get a known Conversation by its unique identifier name.\n     * @param {String} uniqueName - The unique identifier name of the Conversation to get\n     * @returns {Promise<Conversation>}\n     */\n\n  }, {\n    key: \"getConversationByUniqueName\",\n    value: function () {\n      var _getConversationByUniqueName = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee5(uniqueName) {\n        var conversation;\n        return _regeneratorRuntime__default['default'].wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.conversations.syncListRead.promise;\n\n              case 2:\n                _context5.next = 4;\n                return this.conversations.getConversationByUniqueName(uniqueName);\n\n              case 4:\n                conversation = _context5.sent;\n\n                if (conversation) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Conversation with unique name \".concat(uniqueName, \" is not found.\"));\n\n              case 7:\n                return _context5.abrupt(\"return\", conversation);\n\n              case 8:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getConversationByUniqueName(_x3) {\n        return _getConversationByUniqueName.apply(this, arguments);\n      }\n\n      return getConversationByUniqueName;\n    }()\n    /**\n     * Get the current list of all subscribed Conversations.\n     * @returns {Promise<Paginator<Conversation>>}\n     */\n\n  }, {\n    key: \"getSubscribedConversations\",\n    value: function getSubscribedConversations(args) {\n      return this.conversationsPromise.then(function (conversations) {\n        return conversations.getConversations(args);\n      });\n    }\n    /**\n     * Create a Conversation on the server and subscribe to its events.\n     * The default is a Conversation with an empty friendlyName.\n     * @param {Client#CreateConversationOptions} [options] - Options for the Conversation\n     * @returns {Promise<Conversation>}\n     */\n\n  }, {\n    key: \"createConversation\",\n    value: function createConversation(options) {\n      options = options || {};\n      return this.conversationsPromise.then(function (conversationsEntity) {\n        return conversationsEntity.addConversation(options);\n      });\n    }\n    /**\n     * Registers for push notifications.\n     * @param {Client#NotificationsChannelType} channelType - 'apn' and 'fcm' are supported\n     * @param {string} registrationId - Push notification id provided by the platform\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"setPushRegistrationId\",\n    value: function () {\n      var _setPushRegistrationId = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee6(channelType, registrationId) {\n        var _this6 = this;\n\n        return _regeneratorRuntime__default['default'].wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.subscribeToPushNotifications(channelType).then(function () {\n                  return _this6.services.notificationClient.setPushRegistrationId(registrationId, channelType);\n                });\n\n              case 2:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function setPushRegistrationId(_x4, _x5) {\n        return _setPushRegistrationId.apply(this, arguments);\n      }\n\n      return setPushRegistrationId;\n    }()\n    /**\n     * Unregisters from push notifications.\n     * @param {Client#NotificationsChannelType} channelType - 'apn' and 'fcm' are supported\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"unsetPushRegistrationId\",\n    value: function () {\n      var _unsetPushRegistrationId = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee7(channelType) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!(Client.supportedPushChannels.indexOf(channelType) === -1)) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                throw new Error('Invalid or unsupported channelType: ' + channelType);\n\n              case 2:\n                _context7.next = 4;\n                return this.unsubscribeFromPushNotifications(channelType);\n\n              case 4:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function unsetPushRegistrationId(_x6) {\n        return _unsetPushRegistrationId.apply(this, arguments);\n      }\n\n      return unsetPushRegistrationId;\n    }()\n  }, {\n    key: \"handlePushNotification\",\n    value:\n    /**\n     * Handle push notification payload parsing and emits event {@link Client#event:pushNotification} on this {@link Client} instance.\n     * @param {Object} notificationPayload - Push notification payload\n     * @returns {Promise<void>}\n     */\n    function () {\n      var _handlePushNotification = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee8(notificationPayload) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                log.debug('handlePushNotification, notificationPayload=', notificationPayload);\n                this.emit('pushNotification', Client.parsePushNotification(notificationPayload));\n\n              case 2:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function handlePushNotification(_x7) {\n        return _handlePushNotification.apply(this, arguments);\n      }\n\n      return handlePushNotification;\n    }()\n    /**\n     * Gets user for given identity, if it's in subscribed list - then return the user object from it,\n     * if not - then subscribes and adds user to the subscribed list.\n     * @param {String} identity - Identity of User\n     * @returns {Promise<User>} Fully initialized user\n     */\n\n  }, {\n    key: \"getUser\",\n    value: function getUser(identity) {\n      return this.services.users.getUser(identity);\n    }\n    /**\n     * @returns {Promise<Array<User>>} List of subscribed User objects\n     */\n\n  }, {\n    key: \"getSubscribedUsers\",\n    value: function () {\n      var _getSubscribedUsers = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee9() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                return _context9.abrupt(\"return\", this.services.users.getSubscribedUsers());\n\n              case 1:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function getSubscribedUsers() {\n        return _getSubscribedUsers.apply(this, arguments);\n      }\n\n      return getSubscribedUsers;\n    }()\n  }], [{\n    key: \"create\",\n    value: function () {\n      var _create = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee10(token, options) {\n        var client, startupEvent;\n        return _regeneratorRuntime__default['default'].wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                client = new Client(token, options);\n                startupEvent = 'conversations.client.startup';\n                client.services.twilsockClient.addPartialTelemetryEvent(new telemetrytracker.TelemetryEventDescription(startupEvent, 'Conversations client startup', new Date()), startupEvent, telemetrytracker.TelemetryPoint.Start);\n                _context10.next = 5;\n                return client.initialize();\n\n              case 5:\n                client.services.twilsockClient.addPartialTelemetryEvent(new telemetrytracker.TelemetryEventDescription('', '', new Date()), startupEvent, telemetrytracker.TelemetryPoint.End);\n                return _context10.abrupt(\"return\", client);\n\n              case 7:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10);\n      }));\n\n      function create(_x8, _x9) {\n        return _create.apply(this, arguments);\n      }\n\n      return create;\n    }()\n  }, {\n    key: \"parsePushNotificationChatData\",\n    value: function parsePushNotificationChatData(data) {\n      var result = {};\n\n      for (var key in Client.supportedPushDataFields) {\n        if (typeof data[key] !== 'undefined' && data[key] !== null) {\n          if (key === 'message_index') {\n            if (parseToNumber(data[key]) !== null) {\n              result[Client.supportedPushDataFields[key]] = Number(data[key]);\n            }\n          } else {\n            result[Client.supportedPushDataFields[key]] = data[key];\n          }\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Static method for push notification payload parsing. Returns parsed push as {@link PushNotification} object\n     * @param {Object} notificationPayload - Push notification payload\n     * @returns {PushNotification|Error}\n     */\n\n  }, {\n    key: \"parsePushNotification\",\n    value: function parsePushNotification(notificationPayload) {\n      log.debug('parsePushNotification, notificationPayload=', notificationPayload); // APNS specifics\n\n      if (typeof notificationPayload.aps !== 'undefined') {\n        if (!notificationPayload.twi_message_type) {\n          throw new Error('Provided push notification payload does not contain Programmable Chat push notification type');\n        }\n\n        var data = Client.parsePushNotificationChatData(notificationPayload);\n        var apsPayload = notificationPayload.aps;\n        var body = null;\n        var title = null;\n\n        if (typeof apsPayload.alert === 'string') {\n          body = apsPayload.alert || null;\n        } else {\n          body = apsPayload.alert.body || null;\n          title = apsPayload.alert.title || null;\n        }\n\n        return new PushNotification({\n          title: title,\n          body: body,\n          sound: apsPayload.sound || null,\n          badge: apsPayload.badge || null,\n          action: apsPayload.category || null,\n          type: notificationPayload.twi_message_type,\n          data: data\n        });\n      } // FCM specifics\n\n\n      if (typeof notificationPayload.data !== 'undefined') {\n        var dataPayload = notificationPayload.data;\n\n        if (!dataPayload.twi_message_type) {\n          throw new Error('Provided push notification payload does not contain Programmable Chat push notification type');\n        }\n\n        var _data = Client.parsePushNotificationChatData(notificationPayload.data);\n\n        return new PushNotification({\n          title: dataPayload.twi_title || null,\n          body: dataPayload.twi_body || null,\n          sound: dataPayload.twi_sound || null,\n          badge: null,\n          action: dataPayload.twi_action || null,\n          type: dataPayload.twi_message_type,\n          data: _data\n        });\n      }\n\n      throw new Error('Provided push notification payload is not Programmable Chat notification');\n    }\n  }]);\n\n  return Client;\n}(EventEmitter);\n\n_defineProperty__default['default'](Client, \"version\", SDK_VERSION);\n\n_defineProperty__default['default'](Client, \"supportedPushChannels\", ['fcm', 'apn']);\n\n_defineProperty__default['default'](Client, \"supportedPushDataFields\", {\n  'conversation_sid': 'conversationSid',\n  'message_sid': 'messageSid',\n  'message_index': 'messageIndex'\n});\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.nonEmptyString), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Client.prototype, \"updateToken\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.nonEmptyString), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Client.prototype, \"getConversationBySid\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.nonEmptyString), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Client.prototype, \"getConversationByUniqueName\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(['undefined', twilioSdkTypeValidator.objectSchema('conversation options', {\n  friendlyName: ['string', 'undefined'],\n  isPrivate: ['boolean', 'undefined'],\n  uniqueName: ['string', 'undefined']\n})]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Promise)], Client.prototype, \"createConversation\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.literal('fcm', 'apn'), 'string'), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String, String]), __metadata(\"design:returntype\", Promise)], Client.prototype, \"setPushRegistrationId\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.literal('fcm', 'apn')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Client.prototype, \"unsetPushRegistrationId\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.pureObject), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Promise)], Client.prototype, \"handlePushNotification\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.nonEmptyString), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Client.prototype, \"getUser\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync('string', ['undefined', twilioSdkTypeValidator.pureObject]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String, Object]), __metadata(\"design:returntype\", Promise)], Client, \"create\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypes(twilioSdkTypeValidator.pureObject), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", PushNotification)], Client, \"parsePushNotification\", null);\n/**\n * Fired when a Conversation becomes visible to the Client. The event is also triggered when the client creates a new Conversation.\n * Fired for all conversations Client has joined.\n * @event Client#conversationAdded\n * @type {Conversation}\n */\n\n/**\n * Fired when the Client joins a Conversation.\n * @event Client#conversationJoined\n * @type {Conversation}\n */\n\n/**\n * Fired when the Client leaves a Conversation.\n * @event Client#conversationLeft\n * @type {Conversation}\n */\n\n/**\n * Fired when a Conversation is no longer visible to the Client.\n * @event Client#conversationRemoved\n * @type {Conversation}\n */\n\n/**\n * Fired when a Conversation's attributes or metadata have been updated.\n * During Conversation's {@link Client.create| creation and initialization} this event might be fired multiple times\n * for same joined or created Conversation as new data is arriving from different sources.\n * @event Client#conversationUpdated\n * @type {Object}\n * @property {Conversation} conversation - Updated Conversation\n * @property {Conversation#UpdateReason[]} updateReasons - Array of Conversation's updated event reasons\n */\n\n/**\n * Fired when Client's connection state has been changed.\n * @event Client#connectionStateChanged\n * @type {Client#ConnectionState}\n */\n\n/**\n * Fired when a Participant has joined the Conversation.\n * @event Client#participantJoined\n * @type {Participant}\n */\n\n/**\n * Fired when a Participant has left the Conversation.\n * @event Client#participantLeft\n * @type {Participant}\n */\n\n/**\n * Fired when a Participant's fields has been updated.\n * @event Client#participantUpdated\n * @type {Object}\n * @property {Participant} participant - Updated Participant\n * @property {Participant#UpdateReason[]} updateReasons - Array of Participant's updated event reasons\n */\n\n/**\n * Fired when a new Message has been added to the Conversation on the server.\n * @event Client#messageAdded\n * @type {Message}\n */\n\n/**\n * Fired when Message is removed from Conversation's message list.\n * @event Client#messageRemoved\n * @type {Message}\n */\n\n/**\n * Fired when an existing Message's fields are updated with new values.\n * @event Client#messageUpdated\n * @type {Object}\n * @property {Message} message - Updated Message\n * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons\n */\n\n/**\n * Fired when token is about to expire and needs to be updated.\n * @event Client#tokenAboutToExpire\n * @type {void}\n */\n\n/**\n * Fired when token is expired.\n * @event Client#tokenExpired\n * @type {void}\n */\n\n/**\n * Fired when a Participant has stopped typing.\n * @event Client#typingEnded\n * @type {Participant}\n */\n\n/**\n * Fired when a Participant has started typing.\n * @event Client#typingStarted\n * @type {Participant}\n */\n\n/**\n * Fired when client received (and parsed) push notification via one of push channels (apn or fcm).\n * @event Client#pushNotification\n * @type {PushNotification}\n */\n\n/**\n * Fired when the Client is subscribed to a User.\n * @event Client#userSubscribed\n * @type {User}\n */\n\n/**\n * Fired when the Client is unsubscribed from a User.\n * @event Client#userUnsubscribed\n * @type {User}\n */\n\n/**\n * Fired when the User's properties or reachability status have been updated.\n * @event Client#userUpdated\n * @type {Object}\n * @property {User} user - Updated User\n * @property {User#UpdateReason[]} updateReasons - Array of User's updated event reasons\n */\n\n/**\n * Fired when connection is interrupted by unexpected reason\n * @event Client#connectionError\n * @type {Object}\n * @property {Boolean} terminal - twilsock will stop connection attempts\n * @property {String} message - root cause\n * @property {Number} [httpStatusCode] - http status code if available\n * @property {Number} [errorCode] - Twilio public error code if available\n */\n\n\nexports.Client = Client;\nexports.PushNotification = PushNotification;\nexports.User = User;\nexports.default = Client;","map":{"version":3,"sources":["../node_modules/tslib/tslib.es6.js","../src/logger.ts","../src/configuration.ts","../src/services/network.ts","../src/interfaces/notificationtypes.ts","../src/util/index.ts","../src/restpaginator.ts","../src/synclistdescriptor.ts","../src/synclist.ts","../src/interfaces/responsecodes.ts","../src/sessionerror.ts","../src/util/deferred.ts","../src/session.ts","../src/participant.ts","../src/data/participants.ts","../src/media.ts","../src/aggregateddeliveryreceipt.ts","../src/detaileddeliveryreceipt.ts","../src/message.ts","../src/data/messages.ts","../src/conversation.ts","../src/data/conversations.ts","../src/user.ts","../src/data/users.ts","../src/services/typingindicator.ts","../src/services/readhorizon.ts","../src/pushnotification.ts","../src/client.ts"],"names":["c","arguments","r","desc","Object","Reflect","i","decorators","d","log","loglevelLog","Retrier","JsonDiff","SDK_VERSION","platform","uuid","toSeconds","parseDuration","parseTime","validateTypesAsync","literal","nonEmptyString","nonNegativeInteger","custom","objectSchema","_typeof","TwilsockClient","NotificationClient","SyncClient","pureObject","TelemetryEventDescription","TelemetryPoint","McsClient","validateTypes"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || from);\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","import * as loglevelLog from 'loglevel';\n\nfunction prepareLine(prefix, args) {\n  return [`${new Date().toISOString()} Conversations ${prefix}:`].concat(Array.from(args));\n}\n\nconst log: loglevelLog.Logger = loglevelLog.getLogger('twilio-conversations'); // twilio-conversations is used by Flex SDK. Please DO NOT change\n\nclass Logger {\n  private prefix: string = '';\n\n  private constructor(prefix: string) {\n    this.prefix = prefix !== null && prefix !== undefined && prefix.length > 0\n      ? prefix + ' '\n      : '';\n  }\n\n  static scope(prefix: string): Logger {\n    return new Logger(prefix);\n  }\n\n  setLevel(level: any) {\n    log.setLevel(level);\n  }\n\n  static setLevel(level: any) {\n    log.setLevel(level);\n  }\n\n  trace(...args) { log.trace.apply(null, prepareLine(this.prefix + 'T', args)); }\n\n  debug(...args) { log.debug.apply(null, prepareLine(this.prefix + 'D', args)); }\n\n  info(...args) { log.info.apply(null, prepareLine(this.prefix + 'I', args)); }\n\n  warn(...args) { log.warn.apply(null, prepareLine(this.prefix + 'W', args)); }\n\n  error(...args) { log.error.apply(null, prepareLine(this.prefix + 'E', args)); }\n\n  static trace(...args) { log.trace.apply(null, prepareLine('T', args)); }\n\n  static debug(...args) { log.debug.apply(null, prepareLine('D', args)); }\n\n  static info(...args) { log.info.apply(null, prepareLine('I', args)); }\n\n  static warn(...args) { log.warn.apply(null, prepareLine('W', args)); }\n\n  static error(...args) { log.error.apply(null, prepareLine('E', args)); }\n\n}\n\nexport { Logger };\n","const TYPING_PATH = '/v1/typing';\nconst TYPING_TIMEOUT = 5;\nconst HTTP_CACHE_LIFETIME = 'PT5S';\nconst CONSUMPTION_HORIZON_SENDING_INTERVAL = 'PT5S';\nconst USER_INFOS_TO_SUBSCRIBE = 100;\n\nconst MINIMUM_RETRY_DELAY = 1000;\nconst MAXIMUM_RETRY_DELAY = 4000;\nconst MAXIMUM_ATTEMPTS_COUNT = 3;\nconst RETRY_WHEN_THROTTLED = true;\n\nclass Configuration {\n  token: string;\n  public readonly typingIndicatorTimeoutOverride?: number;\n  public readonly httpCacheIntervalOverride?: string;\n  public readonly consumptionReportIntervalOverride?: number;\n  public readonly userInfosToSubscribeOverride?: number;\n  public readonly retryWhenThrottledOverride?: boolean;\n  public readonly backoffConfigOverride?: any;\n  public readonly typingIndicatorUri: string;\n  public readonly productId: string;\n  private baseUrl: string;\n  private region: string;\n\n  constructor(options: any) {\n    options = options || {};\n    let constructorOptions = options.Chat || options.IPMessaging || options || {};\n    this.region = constructorOptions.region || options.region;\n    this.baseUrl = constructorOptions.apiUri || constructorOptions.typingUri ||\n      ((!this.region || this.region === 'us1') ? 'https://aim.twilio.com' : `https://aim.${this.region}.twilio.com`);\n    this.typingIndicatorUri = this.baseUrl + TYPING_PATH;\n    this.typingIndicatorTimeoutOverride = constructorOptions.typingIndicatorTimeoutOverride;\n    this.httpCacheIntervalOverride = constructorOptions.httpCacheIntervalOverride;\n    this.consumptionReportIntervalOverride = constructorOptions.consumptionReportIntervalOverride;\n    this.userInfosToSubscribeOverride = constructorOptions.userInfosToSubscribeOverride;\n    this.retryWhenThrottledOverride = constructorOptions.retryWhenThrottledOverride;\n    this.backoffConfigOverride = constructorOptions.backoffConfigOverride;\n    this.productId = options.productId;\n  }\n\n  public get typingIndicatorTimeoutDefault(): number { return TYPING_TIMEOUT * 1000; }\n\n  public get httpCacheIntervalDefault(): string { return HTTP_CACHE_LIFETIME; }\n\n  public get consumptionReportIntervalDefault(): string { return CONSUMPTION_HORIZON_SENDING_INTERVAL; }\n\n  public get userInfosToSubscribeDefault(): number { return USER_INFOS_TO_SUBSCRIBE; }\n\n  public get retryWhenThrottledDefault(): boolean { return RETRY_WHEN_THROTTLED; }\n\n  public get backoffConfigDefault(): any {\n    return {\n      min: MINIMUM_RETRY_DELAY,\n      max: MAXIMUM_RETRY_DELAY,\n      maxAttemptsCount: MAXIMUM_ATTEMPTS_COUNT\n    };\n  }\n}\n\nexport { Configuration };\n","import { Retrier } from 'operation-retrier';\nimport { Session } from '../session';\nimport { Transport } from '../interfaces/transport';\n\ninterface CacheEntry {\n  response: Object;\n  timestamp: number;\n}\n\nexport interface NetworkServices {\n  session: Session;\n  transport: Transport;\n}\n\nclass Network {\n  private readonly config: any;\n  private readonly services: NetworkServices;\n  private cacheLifetime: number;\n\n  private readonly cache: Map<string, CacheEntry>;\n  private timer: any;\n\n  constructor(config, services) {\n    this.config = config;\n    this.services = services;\n    this.cache = new Map<string, CacheEntry>();\n    this.cacheLifetime = 0;\n    this.services.session.getHttpCacheInterval().then(seconds => {\n      this.cacheLifetime = seconds * 1000;\n      this.cleanupCache();\n    });\n  }\n\n  private backoffConfig() {\n    return Object.assign(this.config.backoffConfigDefault, this.config.backoffConfigOverride);\n  }\n\n  private retryWhenThrottled(): boolean {\n    if (typeof this.config.retryWhenThrottledOverride !== 'undefined') { return this.config.retryWhenThrottledOverride; }\n    if (typeof this.config.retryWhenThrottledDefault !== 'undefined') { return this.config.retryWhenThrottledDefault; }\n    return false;\n  }\n\n  private isExpired(timestamp: number): boolean {\n    return !this.cacheLifetime || (Date.now() - timestamp) > this.cacheLifetime;\n  }\n\n  private cleanupCache() {\n    for (let [k, v] of this.cache) {\n      if (this.isExpired(v.timestamp)) {\n        this.cache.delete(k);\n      }\n    }\n\n    if (this.cache.size === 0) {\n      clearInterval(this.timer);\n    }\n  }\n\n  pokeTimer() {\n    this.timer = this.timer || setInterval(() => this.cleanupCache(), this.cacheLifetime * 2);\n  }\n\n  private executeWithRetry(request, retryWhenThrottled = false): Promise<any> {\n    return new Promise((resolve, reject) => {\n      let codesToRetryOn = [502, 503, 504];\n      if (retryWhenThrottled) {\n        codesToRetryOn.push(429);\n      }\n\n      let retrier = new Retrier(this.backoffConfig());\n      retrier.on('attempt', () => {\n        request()\n          .then(result => retrier.succeeded(result))\n          .catch(err => {\n            if (codesToRetryOn.indexOf(err.status) > -1) {\n              retrier.failed(err);\n            } else if (err.message === 'Twilsock disconnected') {\n              // Ugly hack. We must make a proper exceptions for twilsock\n              retrier.failed(err);\n            } else {\n              // Fatal error\n              retrier.removeAllListeners();\n              retrier.cancel();\n              reject(err);\n            }\n          });\n      });\n\n      retrier.on('succeeded', result => { resolve(result); });\n      retrier.on('cancelled', err => reject(err));\n      retrier.on('failed', err => reject(err));\n\n      retrier.start();\n    });\n  }\n\n  async get(url: string) {\n    let cacheEntry = this.cache.get(url);\n    if (cacheEntry && !this.isExpired(cacheEntry.timestamp)) {\n      return cacheEntry.response;\n    }\n\n    const headers = {};\n    let response = await this.executeWithRetry(\n      () => this.services.transport.get(url, headers, this.config.productId), this.retryWhenThrottled());\n    this.cache.set(url, { response, timestamp: Date.now() });\n    this.pokeTimer();\n    return response;\n  }\n}\n\nexport { Network };\n","class NotificationTypes {\n  static readonly TYPING_INDICATOR = 'twilio.ipmsg.typing_indicator';\n  static readonly NEW_MESSAGE = 'twilio.conversations.new_message';\n  static readonly ADDED_TO_CONVERSATION = 'twilio.conversations.added_to_conversation';\n  // static readonly INVITED_TO_CHANNEL = 'twilio.channel.invited_to_channel';\n  static readonly REMOVED_FROM_CONVERSATION = 'twilio.conversations.removed_from_conversation';\n  static readonly CONSUMPTION_UPDATE = 'twilio.channel.consumption_update';\n}\n\nexport { NotificationTypes };","import * as JsonDiff from 'rfc6902';\nimport { Logger } from '../logger';\n\n/**\n * Checks if objects are equal\n */\nfunction isDeepEqual(o1: Object, o2: Object): boolean {\n  return JsonDiff.createPatch(o1, o2).length === 0;\n}\n\n/**\n * Deep-clone an object. Note that this does not work on object containing\n * functions.\n * @param {object} obj - the object to deep-clone\n * @returns {object}\n */\nfunction deepClone<T>(obj: T): T {\n  return JSON.parse(JSON.stringify(obj)) as T;\n}\n\nfunction parseToNumber(value) {\n  if (typeof value !== 'undefined' && !isNaN(Number(value))) {\n    return Number(value);\n  }\n  return null;\n}\n\n// timeString cannot be typed `string` because in member.ts\n// call to parseTime(data.lastReadTimestamp) uses number not a string for timestamp.\nfunction parseTime(timeString): Date {\n  try {\n    return new Date(timeString);\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction parseAttributes(rawAttributes, warningMessage: string, log: Logger): Object {\n  let attributes = {};\n  if (rawAttributes) {\n    try {\n      attributes = JSON.parse(rawAttributes);\n    } catch (e) {\n      log.warn(warningMessage, e);\n    }\n  }\n\n  return attributes;\n}\n\n/**\n * Construct URI with query parameters\n */\nclass UriBuilder {\n  private base: string;\n  private args: string[];\n  private paths: string[];\n\n  constructor(base: string) {\n    this.base = base.replace(/\\/$/, '');\n    this.args = [];\n    this.paths = [];\n  }\n\n  public arg(name: string, value: any): UriBuilder {\n    if (typeof value !== 'undefined') {\n      this.args.push(encodeURIComponent(name) + '=' + encodeURIComponent(value));\n    }\n    return this;\n  }\n\n  public path(name: string): UriBuilder {\n    this.paths.push(encodeURIComponent(name));\n    return this;\n  }\n\n  public build(): string {\n    let result = this.base;\n    if (this.paths.length) {\n      result += '/' + this.paths.join('/');\n    }\n\n    if (this.args.length) {\n      result += '?' + this.args.join('&');\n    }\n    return result;\n  }\n}\n\nexport { isDeepEqual, deepClone, UriBuilder, parseToNumber, parseTime, parseAttributes };\n","'use strict';\nimport { Paginator } from './interfaces/paginator';\n\ninterface PaginatorState {\n  source: any;\n  nextToken: any;\n  prevToken: any;\n  items: any;\n}\n\n/**\n * @class Paginator\n * @classdesc Pagination helper class\n *\n * @property {Array} items Array of elements on current page\n * @property {boolean} hasNextPage Indicates the existence of next page\n * @property {boolean} hasPrevPage Indicates the existence of previous page\n */\nclass RestPaginator<T> implements Paginator<T> {\n  private state: PaginatorState;\n\n  public get hasNextPage(): boolean { return !!this.state.nextToken; }\n\n  public get hasPrevPage(): boolean { return !!this.state.prevToken; }\n\n  public get items(): Array<T> { return this.state.items; }\n\n  /*\n  * @constructor\n  * @param {Array} items Array of element for current page\n  * @param {Object} params\n  * @private\n  */\n  constructor(items, source, prevToken, nextToken) {\n\n    this.state = {\n      prevToken,\n      nextToken,\n      source,\n      items\n    };\n  }\n\n  nextPage(): Promise<RestPaginator<T>> {\n    return this.hasNextPage ? this.state.source(this.state.nextToken) : Promise.reject(new Error('No next page'));\n  }\n\n  prevPage(): Promise<RestPaginator<T>> {\n    return this.hasPrevPage ? this.state.source(this.state.prevToken) : Promise.reject(new Error('No previous page'));\n  }\n}\n\nexport { RestPaginator };\n","/**\n * Contains sync list item information.\n *\n * @property {string} channel_sid Conversation sid\n * @property {string} conversation Conversation entity name\n * @property {string} messages Conversation messages entity name\n * @property {string} roster Conversation roster entity name\n * @property {Number} lastReadMessageIndex Index of the last Message the User has read in this Conversation\n\n */\nimport { Conversation } from './conversation';\n\nclass SyncListDescriptor {\n\n  public readonly channel_sid: string;\n  public readonly status: string;\n  public readonly channel: string;\n  public readonly messages: string;\n  public readonly roster: string;\n  public readonly lastConsumedMessageIndex: number | null;\n  public readonly notificationLevel: Conversation.NotificationLevel;\n  public readonly descriptor: any;\n\n  /**\n   * @param {Object} descriptor - sync list descriptor data object\n   * @private\n   */\n  constructor(descriptor) {\n    this.channel_sid = descriptor.channel_sid;\n    this.status = descriptor.status;\n    this.channel = descriptor.channel;\n    this.messages = descriptor.messages;\n    this.roster = descriptor.roster;\n    this.lastConsumedMessageIndex = descriptor.last_consumed_message_index;\n    this.notificationLevel = descriptor.notification_level;\n    this.descriptor = descriptor;\n  }\n}\n\nexport { SyncListDescriptor };\n","import { Network } from './services/network';\nimport { Session } from './session';\nimport { UriBuilder } from './util/index';\nimport { RestPaginator } from './restpaginator';\nimport { SyncListDescriptor } from './synclistdescriptor';\n\nexport interface SyncListServices {\n  session: Session;\n  network: Network;\n}\n\n/**\n * Provides async pagination interface for sync list\n *\n * @property {Network} network Network transport\n * @property {string} syncListUrl Url to the sync list endpoint\n */\nclass SyncList {\n\n  private readonly services: SyncListServices;\n\n  /**\n   * @param {SyncListServices} services - services needed for SyncList service\n   * @private\n   */\n  constructor(services: SyncListServices) {\n    this.services = services;\n  }\n\n  public async getPage(args?): Promise<RestPaginator<SyncListDescriptor>> {\n    args = args || {};\n    let links = await this.services.session.getSessionLinks();\n    const url = new UriBuilder(links.syncListUrl).arg('PageToken', args.pageToken).build();\n    let response = await this.services.network.get(url);\n    return new RestPaginator<SyncListDescriptor>(response.body.channels.map(x => new SyncListDescriptor(x))\n      , pageToken => this.getPage({ pageToken })\n      , response.body.meta.previous_token\n      , response.body.meta.next_token);\n  }\n}\n\nexport { SyncList };\n","class ResponseCodes {\n  static readonly HTTP_200_OK = 200;\n  static readonly HTTP_400_BAD_REQUEST = 400;\n  static readonly HTTP_404_NOT_FOUND = 404;\n  static readonly ACCESS_FORBIDDEN_FOR_IDENTITY = 54007;\n  static readonly LIST_NOT_FOUND = 54150;\n}\n\nexport { ResponseCodes };","/**\n * @class\n * @classdesc Exception type for service-side errors.\n *\n * @property {Number} code - Error code\n * @property {String} message - Error description\n */\nclass SessionError extends Error {\n\n  public code: number;\n\n  constructor(message: string, code: number) {\n    super();\n\n    this.name = this.constructor.name;\n    this.message = message;\n    this.code = code;\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    } else {\n      this.stack = (new Error()).stack;\n    }\n  }\n}\n\nexport { SessionError };\n","class Deferred<T> {\n  private _promise: Promise<T>;\n  private _resolve;\n  private _reject;\n\n  public current: T;\n\n  constructor() {\n    this._promise = new Promise<T>((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  public get promise(): Promise<T> { return this._promise; }\n\n  update(value: T) {\n    this._resolve(value);\n  }\n\n  set(value: T) {\n    this.current = value;\n    this._resolve(value);\n  }\n\n  fail(e) {\n    this._reject(e);\n  }\n}\n\nexport { Deferred };\n","import * as uuid from 'uuid';\nimport * as platform from 'platform';\nimport { ResponseCodes } from './interfaces/responsecodes';\n\nimport { Logger } from './logger';\nimport { Configuration } from './configuration';\n\nimport { SessionError } from './sessionerror';\nimport { Deferred } from './util/deferred';\nimport { SyncClient } from 'twilio-sync';\nimport { parse as parseDuration, toSeconds } from 'iso8601-duration';\nimport { version } from '../package.json';\n\nconst SDK_VERSION = version;\nconst SESSION_PURPOSE = 'com.twilio.rtd.ipmsg';\n\nconst log = Logger.scope('Session');\n\nclass Command {\n  resolve: any;\n  reject: any;\n  commandId: any;\n  request: any;\n}\n\ninterface SessionLinks {\n  publicChannelsUrl: string;\n  myChannelsUrl: string;\n  typingUrl: string;\n  syncListUrl: string;\n  usersUrl: string;\n  mediaServiceUrl: string;\n  messagesReceiptsUrl: string;\n}\n\ninterface ImmutableSessionInfo {\n  identity: string;\n  links: SessionLinks;\n\n  userInfo: string;\n  channels: string;\n  myChannels: string;\n  userInfosToSubscribe: number;\n}\n\nexport interface SessionServices {\n  syncClient: SyncClient;\n}\n\nfunction hasAllPropertiesSet(obj: Object, properties: string[]): boolean {\n  return !(properties.some(prop => !obj.hasOwnProperty(prop)));\n}\n\n/**\n *  Constructs the instance of Session\n *\n *  @classdesc Provides the interface to send the command to the server\n *  It is reliable, which means that it tracks the command object state\n *  and waits the answer from the server.\n */\nclass Session {\n  public readonly services: SessionServices;\n\n  private endpointPlatform: string;\n  private config: any;\n\n  private pendingCommands: Map<string, Command>;\n  private sessionStreamPromise: any;\n\n  private readonly sessionInfo: Deferred<ImmutableSessionInfo>;\n  private currentContext: any;\n\n  constructor(services: SessionServices, config: Configuration) {\n    let platformInfo = typeof navigator !== 'undefined' ?\n      platform.parse(navigator.userAgent) : platform;\n\n    this.services = services;\n    this.config = config;\n\n    this.sessionInfo = new Deferred<ImmutableSessionInfo>();\n    this.currentContext = {};\n\n    this.pendingCommands = new Map();\n    this.sessionStreamPromise = null;\n\n    this.endpointPlatform = [\n      'JS',\n      SDK_VERSION,\n      platformInfo.os,\n      platformInfo.name,\n      platformInfo.version\n    ].join('|');\n  }\n\n  public get identity(): string { return this.sessionInfo.current.identity; }\n\n  public get reachabilityEnabled(): boolean { return this.currentContext.reachabilityEnabled; }\n\n  private handleContextUpdate(updatedContext: any) {\n    log.info('Session context updated');\n    log.debug('new session context:', updatedContext);\n\n    this.currentContext = updatedContext;\n\n    if (!hasAllPropertiesSet(updatedContext, ['identity', 'userInfo', 'links', 'myChannels', 'channels'])) {\n      return; // not enough data to proceed, wait\n    }\n\n    log.info('new session context accepted');\n    this.sessionInfo.set(updatedContext);\n  }\n\n  initialize(): Promise<Session> {\n    let context = {\n      type: 'IpMsgSession',\n      apiVersion: '4',\n      endpointPlatform: this.endpointPlatform\n    };\n\n    this.sessionStreamPromise = this.services.syncClient.list({ purpose: SESSION_PURPOSE, context })\n                                    .then(list => {\n                                      log.info('Session created', list.sid);\n                                      list.on('itemAdded', args => this.processCommandResponse(args.item));\n                                      list.on('itemUpdated', args => this.processCommandResponse(args.item));\n                                      list.on('contextUpdated', args => this.handleContextUpdate(args.context));\n                                      return list;\n                                    }).catch(function(err) {\n        log.error('Failed to create session', err);\n        throw err;\n      });\n\n    return this.sessionStreamPromise;\n  }\n\n  /**\n   * Sends the command to the server\n   * @returns Promise the promise, which is being fulfilled only when service will reply\n   */\n  addCommand(action: string, params: any): Promise<any> {\n    return this.processCommand(action, params);\n  }\n\n  /**\n   * @private\n   */\n  private processCommand(action, params, createSessionIfNotFound = true) {\n    let command = new Command();\n    command.request = params;\n    command.request.action = action;\n    command.commandId = uuid.v4();\n\n    log.info('Adding command: ', action, command.commandId);\n    log.debug('command arguments:', params, createSessionIfNotFound);\n\n    return new Promise((resolve, reject) => {\n      this.sessionStreamPromise.then(list => {\n        this.pendingCommands.set(command.commandId,\n          { resolve, reject, commandId: command.commandId, request: command.request });\n        return list.push(command);\n      })\n          .then(() => log.debug('Command accepted by server', command.commandId))\n          .catch(err => {\n            this.pendingCommands.delete(command.commandId);\n            log.error('Failed to add a command to the session', err);\n            if ((err.code == ResponseCodes.ACCESS_FORBIDDEN_FOR_IDENTITY || err.code === ResponseCodes.LIST_NOT_FOUND) && createSessionIfNotFound) {\n              log.info('recreating session...');\n              this.initialize();\n              resolve(this.processCommand(action, params, false)); // second attempt\n            } else {\n              reject(new Error('Can\\'t add command: ' + err.message));\n            }\n          });\n    });\n  }\n\n  /**\n   * @private\n   */\n  private processCommandResponse(entity) {\n    if (entity.data.hasOwnProperty('response') &&\n      entity.data.hasOwnProperty('commandId') &&\n      this.pendingCommands.has(entity.data.commandId)\n    ) {\n      const data = entity.data;\n      const commandId = data.commandId;\n      if (data.response.status === ResponseCodes.HTTP_200_OK) {\n        log.debug('Command succeeded: ', data);\n        let resolve = this.pendingCommands.get(commandId).resolve;\n        this.pendingCommands.delete(commandId);\n        resolve(data.response);\n      } else {\n        log.error('Command failed: ', data);\n        let reject = this.pendingCommands.get(commandId).reject;\n        this.pendingCommands.delete(commandId);\n        reject(new SessionError(data.response.statusText, data.response.status));\n      }\n    }\n  }\n\n  private getSessionContext(): any {\n    return this.sessionStreamPromise\n               .then(stream => stream.getContext());\n  }\n\n  async getSessionLinks(): Promise<SessionLinks> {\n    let info = await this.sessionInfo.promise;\n    return {\n      publicChannelsUrl: this.config.baseUrl + info.links.publicChannelsUrl as string,\n      myChannelsUrl: this.config.baseUrl + info.links.myChannelsUrl as string,\n      typingUrl: this.config.baseUrl + info.links.typingUrl as string,\n      syncListUrl: this.config.baseUrl + info.links.syncListUrl as string,\n      usersUrl: this.config.baseUrl + info.links.usersUrl as string,\n      mediaServiceUrl: info.links.mediaServiceUrl as string,\n      messagesReceiptsUrl: this.config.baseUrl + info.links.messagesReceiptsUrl as string\n    };\n  }\n\n  async getConversationsId(): Promise<string> {\n    let info = await this.sessionInfo.promise;\n    return info.channels;\n  }\n\n  async getMyConversationsId(): Promise<string> {\n    let info = await this.sessionInfo.promise;\n    return info.myChannels;\n  }\n\n  async getMaxUserInfosToSubscribe(): Promise<number> {\n    let info = await this.sessionInfo.promise;\n    return this.config.userInfosToSubscribeOverride\n      || info.userInfosToSubscribe\n      || this.config.userInfosToSubscribeDefault;\n  }\n\n  getUsersData() {\n    return this.sessionInfo.promise.then(info => ({\n      user: info.userInfo,\n      identity: info.identity\n    }));\n  }\n\n  async getConsumptionReportInterval(): Promise<number> {\n    let context = await this.getSessionContext();\n    let consumptionIntervalToUse = this.config.consumptionReportIntervalOverride\n      || context.consumptionReportInterval\n      || this.config.consumptionReportIntervalDefault;\n\n    try {\n      return toSeconds(parseDuration(consumptionIntervalToUse));\n    } catch (e) {\n      log.error(\n        'Failed to parse consumption report interval', consumptionIntervalToUse,\n        'using default value', this.config.consumptionReportIntervalDefault\n      );\n      return toSeconds(parseDuration(this.config.consumptionReportIntervalDefault));\n    }\n  }\n\n  async getHttpCacheInterval(): Promise<number> {\n    let context = await this.getSessionContext();\n    let cacheIntervalToUse = this.config.httpCacheIntervalOverride\n      || context.httpCacheInterval\n      || this.config.httpCacheIntervalDefault;\n\n    try {\n      return toSeconds(parseDuration(cacheIntervalToUse));\n    } catch (e) {\n      log.error(\n        'Failed to parse cache interval', cacheIntervalToUse,\n        'using default value', this.config.httpCacheIntervalDefault\n      );\n      return toSeconds(parseDuration(this.config.httpCacheIntervalDefault));\n    }\n  }\n}\n\nexport { SessionLinks, Session };\n","import { EventEmitter } from 'events';\nimport { Users } from './data/users';\nimport { User } from './user';\nimport { isDeepEqual, parseTime, parseAttributes } from './util';\nimport { Logger } from './logger';\nimport { Session } from './session';\nimport { Conversation } from './conversation';\nimport { validateTypesAsync, literal } from 'twilio-sdk-type-validator';\n\nconst log = Logger.scope('Participant');\n\ninterface ParticipantDescriptor {\n  attributes?: Object;\n  dateCreated: any;\n  dateUpdated: any;\n  identity: string;\n  roleSid?: string;\n  lastConsumedMessageIndex: number;\n  lastConsumptionTimestamp: number;\n  type: Participant.Type;\n  userInfo: string;\n}\n\ninterface ParticipantState {\n  attributes: any;\n  dateCreated: Date;\n  dateUpdated: Date;\n  identity: string;\n  isTyping: boolean;\n  lastReadMessageIndex: number | null;\n  lastReadTimestamp: Date;\n  roleSid: string;\n  sid: string;\n  type: Participant.Type;\n  typingTimeout: any;\n  userInfo: string;\n}\n\nexport interface ParticipantServices {\n  users: Users;\n  session: Session;\n}\n\nnamespace Participant {\n  export type UpdateReason = 'attributes' | 'dateCreated' | 'dateUpdated' | 'roleSid' | 'lastReadMessageIndex' | 'lastReadTimestamp';\n\n  export type Type = 'chat' | 'sms' | 'whatsapp';\n\n  export interface UpdatedEventArgs {\n    participant: Participant;\n    updateReasons: Participant.UpdateReason[];\n  }\n}\n\n/**\n * @classdesc A Participant represents a remote Client in a Conversation.\n * @property {any} attributes - Object with custom attributes for Participant\n * @property {Conversation} conversation - The Conversation the remote Client is a Participant of\n * @property {Date} dateCreated - The Date this Participant was created\n * @property {Date} dateUpdated - The Date this Participant was last updated\n * @property {String} identity - The identity of the remote Client\n * @property {Boolean} isTyping - Whether or not this Participant is currently typing\n   * @property {Number|null} lastReadMessageIndex - Latest read Message index by this Participant.\n * Note that just retrieving messages on a client endpoint does not mean that messages are read,\n * please consider reading about [Read Horizon feature]{@link https://www.twilio.com/docs/api/chat/guides/consumption-horizon}\n * to find out how to mark messages as read.\n * @property {Date} lastReadTimestamp - Date when Participant has updated his read horizon\n * @property {String} sid - The server-assigned unique identifier for the Participant\n * @property {Participant#Type} type - The type of Participant\n * @fires Participant#typingEnded\n * @fires Participant#typingStarted\n * @fires Participant#updated\n */\nclass Participant extends EventEmitter {\n  private state: ParticipantState;\n  private services: ParticipantServices;\n  public readonly conversation: Conversation;\n\n  public get sid(): string { return this.state.sid; }\n\n  public get attributes(): Object { return this.state.attributes; }\n\n  public get dateCreated(): Date { return this.state.dateCreated; }\n\n  public get dateUpdated(): Date { return this.state.dateUpdated; }\n\n  public get identity(): string { return this.state.identity; }\n\n  public get isTyping(): boolean { return this.state.isTyping; }\n\n  public get lastReadMessageIndex(): number | null { return this.state.lastReadMessageIndex; }\n\n  public get lastReadTimestamp(): Date { return this.state.lastReadTimestamp; }\n\n  public get roleSid(): string { return this.state.roleSid; }\n\n  public get type(): Participant.Type { return this.state.type; }\n\n  /**\n   * The update reason for <code>updated</code> event emitted on Participant\n   * @typedef {('attributes' | 'dateCreated' | 'dateUpdated' | 'roleSid' |\n    'lastReadMessageIndex' | 'lastReadTimestamp')} Participant#UpdateReason\n   */\n\n  /**\n   * The type of Participant\n   * @typedef {('chat' | 'sms' | 'whatsapp')} Participant#Type\n   */\n\n  constructor(services: ParticipantServices, conversation: Conversation, data: ParticipantDescriptor, sid: string) {\n    super();\n\n    this.conversation = conversation;\n    this.services = services;\n    this.state = {\n      attributes: parseAttributes(data.attributes,\n        'Retrieved malformed attributes from the server for participant: ' + sid,\n        log),\n      dateCreated: data.dateCreated ? parseTime(data.dateCreated) : null,\n      dateUpdated: data.dateCreated ? parseTime(data.dateUpdated) : null,\n      sid: sid,\n      typingTimeout: null,\n      isTyping: false,\n      identity: data.identity || null,\n      roleSid: data.roleSid || null,\n      lastReadMessageIndex: Number.isInteger(data.lastConsumedMessageIndex) ? data.lastConsumedMessageIndex : null,\n      lastReadTimestamp: data.lastConsumptionTimestamp ? parseTime(data.lastConsumptionTimestamp) : null,\n      type: data.type || 'chat',\n      userInfo: data.userInfo\n    };\n\n    if (!data.identity && !data.type) {\n      throw new Error('Received invalid Participant object from server: Missing identity or type of Participant.');\n    }\n  }\n\n  /**\n   * Private method used to start or reset the typing indicator timeout (with event emitting)\n   * @private\n   */\n  _startTyping(timeout) {\n    clearTimeout(this.state.typingTimeout);\n\n    this.state.isTyping = true;\n    this.emit('typingStarted', this);\n    this.conversation.emit('typingStarted', this);\n\n    this.state.typingTimeout = setTimeout(() => this._endTyping(), timeout);\n    return this;\n  }\n\n  /**\n   * Private method function used to stop typing indicator (with event emitting)\n   * @private\n   */\n  _endTyping() {\n    if (!this.state.typingTimeout) { return; }\n\n    this.state.isTyping = false;\n    this.emit('typingEnded', this);\n    this.conversation.emit('typingEnded', this);\n\n    clearInterval(this.state.typingTimeout);\n    this.state.typingTimeout = null;\n  }\n\n  /**\n   * Private method function used update local object's property roleSid with new value\n   * @private\n   */\n  _update(data) {\n    let updateReasons: Participant.UpdateReason[] = [];\n\n    let updateAttributes =\n      parseAttributes(\n        data.attributes,\n        'Retrieved malformed attributes from the server for participant: ' + this.state.sid,\n        log);\n\n    if (data.attributes && !isDeepEqual(this.state.attributes, updateAttributes)) {\n      this.state.attributes = updateAttributes;\n      updateReasons.push('attributes');\n    }\n\n    let updatedDateUpdated = parseTime(data.dateUpdated);\n    if (data.dateUpdated &&\n      updatedDateUpdated.getTime() !== (this.state.dateUpdated && this.state.dateUpdated.getTime())) {\n      this.state.dateUpdated = updatedDateUpdated;\n      updateReasons.push('dateUpdated');\n    }\n\n    let updatedDateCreated = parseTime(data.dateCreated);\n    if (data.dateCreated &&\n      updatedDateCreated.getTime() !== (this.state.dateCreated && this.state.dateCreated.getTime())) {\n      this.state.dateCreated = updatedDateCreated;\n      updateReasons.push('dateCreated');\n    }\n\n    if (data.roleSid && this.state.roleSid !== data.roleSid) {\n      this.state.roleSid = data.roleSid;\n      updateReasons.push('roleSid');\n    }\n\n    if ((Number.isInteger(data.lastConsumedMessageIndex) || data.lastConsumedMessageIndex === null)\n      && this.state.lastReadMessageIndex !== data.lastConsumedMessageIndex) {\n      this.state.lastReadMessageIndex = data.lastConsumedMessageIndex;\n      updateReasons.push('lastReadMessageIndex');\n    }\n\n    if (data.lastConsumptionTimestamp) {\n      let lastReadTimestamp = new Date(data.lastConsumptionTimestamp);\n      if (!this.state.lastReadTimestamp ||\n        this.state.lastReadTimestamp.getTime() !== lastReadTimestamp.getTime()) {\n        this.state.lastReadTimestamp = lastReadTimestamp;\n        updateReasons.push('lastReadTimestamp');\n      }\n    }\n\n    if (updateReasons.length > 0) {\n      this.emit('updated', { participant: this, updateReasons: updateReasons });\n    }\n\n    return this;\n  }\n\n  /**\n   * Gets User for this participant and subscribes to it. Supported only for <code>chat</code> type of Participants\n   * @returns {Promise<User>}\n   */\n  async getUser(): Promise<User> {\n    if (this.type != 'chat') {\n      throw new Error('Getting User is not supported for this Participant type: ' + this.type);\n    }\n\n    return this.services.users.getUser(this.state.identity, this.state.userInfo);\n  }\n\n  /**\n   * Remove Participant from the Conversation.\n   * @returns {Promise<void>}\n   */\n  async remove() {\n    return this.conversation.removeParticipant(this);\n  }\n\n  /**\n   * Edit participant attributes.\n   * @param {any} attributes new attributes for Participant.\n   * @returns {Promise<Participant>}\n   */\n  @validateTypesAsync(['string', 'number', 'boolean', 'object', literal(null)])\n  async updateAttributes(attributes: any): Promise<Participant> {\n    await this.services.session.addCommand('editMemberAttributes', {\n      channelSid: this.conversation.sid,\n      memberSid: this.sid,\n      attributes: JSON.stringify(attributes)\n    });\n\n    return this;\n  }\n}\n\nexport { ParticipantDescriptor, Participant };\n\n/**\n * Fired when Participant started to type.\n * @event Participant#typingStarted\n * @type {Participant}\n */\n\n/**\n * Fired when Participant ended to type.\n * @event Participant#typingEnded\n * @type {Participant}\n */\n\n/**\n * Fired when Participant's fields has been updated.\n * @event Participant#updated\n * @type {Object}\n * @property {Participant} participant - Updated Participant\n * @property {Participant#UpdateReason[]} updateReasons - Array of Participant's updated event reasons\n */\n","import { EventEmitter } from 'events';\nimport { ParticipantDescriptor, Participant } from '../participant';\nimport { Logger } from '../logger';\n\nimport { Conversation } from '../conversation';\n\nimport { SyncMap, SyncClient } from 'twilio-sync';\nimport { Users } from './users';\nimport { Session } from '../session';\nimport { SessionError } from '../sessionerror';\n\nconst log = Logger.scope('Participants');\n\nexport interface ParticipantsServices {\n  session: Session;\n  syncClient: SyncClient;\n  users: Users;\n}\n\n/**\n * @classdesc Represents the collection of participants for the conversation\n * @fires Participants#participantJoined\n * @fires Participants#participantLeft\n * @fires Participants#participantUpdated\n */\nclass Participants extends EventEmitter {\n\n  services: ParticipantsServices;\n  rosterEntityPromise: Promise<SyncMap>;\n\n  public readonly conversation: Conversation;\n  public readonly participants: Map<string, Participant>;\n\n  constructor(conversation: Conversation, services: ParticipantsServices, participants: Map<string, Participant>) {\n    super();\n    this.services = services;\n    this.conversation = conversation;\n    this.participants = participants;\n  }\n\n  async unsubscribe(): Promise<void> {\n    if (this.rosterEntityPromise) {\n      let entity = await this.rosterEntityPromise;\n      entity.close();\n      this.rosterEntityPromise = null;\n    }\n  }\n\n  subscribe(rosterObjectName: string) {\n    return this.rosterEntityPromise = this.rosterEntityPromise\n      || this.services.syncClient.map({ id: rosterObjectName, mode: 'open_existing' })\n             .then(rosterMap => {\n               rosterMap.on('itemAdded', args => {\n                 log.debug(this.conversation.sid + ' itemAdded: ' + args.item.key);\n                 this.upsertParticipant(args.item.key, args.item.data)\n                     .then(participant => {\n                       this.emit('participantJoined', participant);\n                     });\n               });\n\n               rosterMap.on('itemRemoved', args => {\n                 log.debug(this.conversation.sid + ' itemRemoved: ' + args.key);\n                 let participantSid = args.key;\n                 if (!this.participants.has(participantSid)) {\n                   return;\n                 }\n                 let leftParticipant = this.participants.get(participantSid);\n                 this.participants.delete(participantSid);\n                 this.emit('participantLeft', leftParticipant);\n               });\n\n               rosterMap.on('itemUpdated', args => {\n                 log.debug(this.conversation.sid + ' itemUpdated: ' + args.item.key);\n                 this.upsertParticipant(args.item.key, args.item.data);\n               });\n\n               let participantsPromises = [];\n               let that = this;\n               const rosterMapHandler = function(paginator) {\n                 paginator.items.forEach(item => { participantsPromises.push(that.upsertParticipant(item.key, item.data)); });\n                 return paginator.hasNextPage ? paginator.nextPage().then(rosterMapHandler) : null;\n               };\n\n               return rosterMap\n                 .getItems()\n                 .then(rosterMapHandler)\n                 .then(() => Promise.all(participantsPromises))\n                 .then(() => rosterMap);\n             })\n             .catch(err => {\n               this.rosterEntityPromise = null;\n               if (this.services.syncClient.connectionState != 'disconnected') {\n                 log.error('Failed to get roster object for conversation', this.conversation.sid, err);\n               }\n               log.debug('ERROR: Failed to get roster object for conversation', this.conversation.sid, err);\n               throw err;\n             });\n  }\n\n  async upsertParticipant(participantSid: string, data: ParticipantDescriptor): Promise<Participant> {\n    let participant = this.participants.get(participantSid);\n    if (participant) {\n      return participant._update(data);\n    }\n\n    participant = new Participant(this.services, this.conversation, data, participantSid);\n    this.participants.set(participantSid, participant);\n    participant.on('updated', (args: Participant.UpdatedEventArgs) => this.emit('participantUpdated', args));\n    return participant;\n  }\n\n  /**\n   * @returns {Promise<Array<Participant>>} returns list of participants {@see Participant}\n   */\n  getParticipants(): Promise<Array<Participant>> {\n    return this.rosterEntityPromise.then(() => {\n      let participants = [];\n      this.participants.forEach(participant => participants.push(participant));\n      return participants;\n    });\n  }\n\n  /**\n   * Get participant by SID from conversation\n   * @returns {Promise<Participant>}\n   */\n  async getParticipantBySid(participantSid: string): Promise<Participant> {\n    return this.rosterEntityPromise.then(() => {\n      let participant = this.participants.get(participantSid);\n      if (!participant) {\n        throw new Error('Participant with SID ' + participantSid + ' was not found');\n      }\n      return participant;\n    });\n  }\n\n  /**\n   * Get participant by identity from conversation\n   * @returns {Promise<Participant>}\n   */\n  async getParticipantByIdentity(identity: string): Promise<Participant> {\n    let foundParticipant = null;\n    return this.rosterEntityPromise.then(() => {\n      this.participants.forEach(participant => {\n        if (participant.identity === identity) {\n          foundParticipant = participant;\n        }\n      });\n      if (!foundParticipant) {\n        throw new Error('Participant with identity ' + identity + ' was not found');\n      }\n      return foundParticipant;\n    });\n  }\n\n  /**\n   * Add a chat participant to the conversation\n   * @returns {Promise<any>}\n   */\n  add(identity: string, attributes: any): Promise<any> {\n    return this.services.session.addCommand('addMemberV2', {\n      channelSid: this.conversation.sid,\n      attributes: JSON.stringify(attributes),\n      username: identity\n    });\n  }\n\n  /**\n   * Add a non-chat participant to the conversation.\n   *\n   * @param proxyAddress\n   * @param address\n   * @param attributes\n   * @returns {Promise<any>}\n   */\n  addNonChatParticipant(proxyAddress: string, address: string, attributes: Record<string, any> = {}): Promise<any> {\n    return this.services.session.addCommand('addNonChatParticipant', {\n      conversationSid: this.conversation.sid,\n      proxyAddress,\n      attributes: JSON.stringify(attributes),\n      address\n    });\n  }\n\n  /**\n   * Invites user to the conversation\n   * User can choose either to join or not\n   * @returns {Promise<any>}\n   */\n  invite(identity: string): Promise<any> {\n    return this.services.session.addCommand('inviteMember', {\n      channelSid: this.conversation.sid,\n      username: identity\n    });\n  }\n\n  /**\n   * Remove participant from conversation by Identity\n   * @returns {Promise<any>}\n   */\n  removeByIdentity(identity: string): Promise<any> {\n    return this.services.session.addCommand('removeMember', {\n      channelSid: this.conversation.sid,\n      username: identity\n    });\n  }\n\n  /**\n   * Remove participant from conversation by sid\n   * @returns {Promise<any>}\n   */\n  removeBySid(sid: string): Promise<any> {\n    return this.services.session.addCommand('removeMember', {\n      channelSid: this.conversation.sid,\n      memberSid: sid\n    });\n  }\n}\n\nexport { Participants };\n\n/**\n * Fired when participant joined conversation\n * @event Participants#participantJoined\n * @type {Participant}\n */\n\n/**\n * Fired when participant left conversation\n * @event Participants#participantLeft\n * @type {Participant}\n */\n\n/**\n * Fired when participant updated\n * @event Participants#participantUpdated\n * @type {Object}\n * @property {Participant} participant - Updated Participant\n * @property {Participant#UpdateReason[]} updateReasons - Array of Participant's updated event reasons\n */\n","import { McsClient, McsMedia } from 'twilio-mcs-client';\n\nexport interface MediaState {\n  sid: string;\n  filename?: string;\n  contentType: string;\n  size: number;\n}\n\nexport interface MediaServices {\n  mcsClient: McsClient;\n}\n\n/**\n * @classdesc A Media represents a media information for Message in a Conversation.\n * @property {String} contentType - content type of media\n * @property {String} sid - The server-assigned unique identifier for Media\n * @property {Number} size - Size of media, bytes\n * @property {String} [filename] - file name if present, null otherwise\n */\nclass Media {\n\n  private state: MediaState;\n  private services: MediaServices;\n  private mcsMedia: McsMedia = null;\n\n  constructor(data: MediaState, services: MediaServices) {\n\n    this.services = services;\n\n    this.state = {\n      sid: data.sid,\n      filename: data.filename,\n      contentType: data.contentType,\n      size: data.size\n    };\n  }\n\n  public get sid(): string { return this.state.sid; }\n\n  public get filename(): string {return this.state.filename; }\n\n  public get contentType(): string { return this.state.contentType; }\n\n  public get size(): number {return this.state.size; }\n\n  /**\n   * Returns direct content URL for the media.\n   *\n   * This URL is impermanent, it will expire in several minutes and cannot be cached.\n   * If the URL becomes expired, you need to request a new one.\n   * Each call to this function produces a new temporary URL.\n   *\n   * @returns {Promise<String>}\n   */\n  public async getContentTemporaryUrl() {\n    if (!this.mcsMedia) {\n      if (this.services.mcsClient) {\n        this.mcsMedia = await this.services.mcsClient.get(this.state.sid);\n      } else {\n        throw new Error('Media Content Service is unavailable');\n      }\n    }\n    return this.mcsMedia.getContentUrl();\n  }\n}\n\nexport { Media };\n","namespace AggregatedDeliveryReceipt {\n  export type DeliveryAmount = 'none' | 'some' | 'all';\n\n  export interface AggregatedDeliveryDescriptor {\n    total: number;\n    delivered: DeliveryAmount;\n    failed: DeliveryAmount;\n    read: DeliveryAmount;\n    sent: DeliveryAmount;\n    undelivered: DeliveryAmount;\n  }\n}\n\n/**\n * @classdesc Contains aggregated information about a {@link Message}'s delivery statuses across all {@link Participant}s\n * of a {@link Conversation}.\n *\n * At any moment during delivering message to a {@link Participant} the message can have zero or more of following\n * delivery statuses:\n *\n * <ul><li>\n * Message considered as <b>sent</b> to a participant, if the nearest upstream carrier accepted the message.\n * </li><li>\n * Message considered as <b>delivered</b> to a participant, if Twilio has received confirmation of message\n * delivery from the upstream carrier, and, where available, the destination handset.\n * </li><li>\n * Message considered as <b>undelivered</b> to a participant, if Twilio has received a delivery receipt\n * indicating that the message was not delivered. This can happen for many reasons including carrier content\n * filtering and the availability of the destination handset.\n * </li><li>\n * Message considered as <b>read</b> by a participant, if the message has been delivered and opened by the\n * recipient in the conversation. The recipient must have enabled read receipts.\n * </li><li>\n * Message considered as <b>failed</b> to be delivered to a participant if the message could not be sent.\n * This can happen for various reasons including queue overflows, account suspensions and media\n * errors (in the case of MMS for instance).\n *</li></ul>\n *\n * {@link AggregatedDeliveryReceipt} class contains aggregated value {@link AggregatedDeliveryReceipt#DeliveryAmount} for each delivery status.\n *\n * @property {number} total - Maximum number of delivery events expected for the message\n * @property {AggregatedDeliveryReceipt#DeliveryAmount} sent - Amount of participants that have <b>sent</b> delivery status for the message.\n * @property {AggregatedDeliveryReceipt#DeliveryAmount} delivered - Amount of participants that have <b>delivered</b> delivery status\n *   for the message.\n * @property {AggregatedDeliveryReceipt#DeliveryAmount} read - Amount of participants that have <b>read</b> delivery status for the message.\n * @property {AggregatedDeliveryReceipt#DeliveryAmount} undelivered - Amount of participants that have <b>undelivered</b> delivery status\n *   for the message.\n * @property {AggregatedDeliveryReceipt#DeliveryAmount} failed - Amount of participants that have <b>failed</b> delivery status for the message.\n */\nclass AggregatedDeliveryReceipt {\n\n  private state: AggregatedDeliveryReceipt.AggregatedDeliveryDescriptor;\n\n  /**\n   * Signifies amount of participants which have the status for the message.\n   * @typedef {('none'|'some'|'all')} AggregatedDeliveryReceipt#DeliveryAmount\n   */\n\n  constructor(data: AggregatedDeliveryReceipt.AggregatedDeliveryDescriptor) {\n    this.state = data;\n  }\n\n  /**\n   * @return Maximum number of delivery events expected for the message.\n   */\n  public get total(): number {\n    return this.state.total;\n  }\n\n  /**\n   * Message considered as <b>sent</b> to a participant, if the nearest upstream carrier accepted the message.\n   *\n   * @return {@link DeliveryAmount} of participants that have <b>sent</b> delivery status for the message.\n   */\n  public get sent(): AggregatedDeliveryReceipt.DeliveryAmount {\n    return this.state.sent;\n  }\n\n  /**\n   * Message considered as <b>delivered</b> to a participant, if Twilio has received confirmation of message\n   * delivery from the upstream carrier, and, where available, the destination handset.\n   *\n   * @return {@link DeliveryAmount} of participants that have <b>delivered</b> delivery status for the message.\n   */\n  public get delivered(): AggregatedDeliveryReceipt.DeliveryAmount {\n    return this.state.delivered;\n  }\n\n  /**\n   * Message considered as <b>read</b> by a participant, if the message has been delivered and opened by the\n   * recipient in the conversation. The recipient must have enabled read receipts.\n   *\n   * @return {@link DeliveryAmount} of participants that have <b>read</b> delivery status for the message.\n   */\n  public get read(): AggregatedDeliveryReceipt.DeliveryAmount {\n    return this.state.read;\n  }\n\n  /**\n   * Message considered as <b>undelivered</b> to a participant, if Twilio has received a delivery receipt\n   * indicating that the message was not delivered. This can happen for many reasons including carrier content\n   * filtering and the availability of the destination handset.\n   *\n   * @return {@link DeliveryAmount} of participants that have <b>undelivered</b> delivery status for the message.\n   */\n  public get undelivered(): AggregatedDeliveryReceipt.DeliveryAmount {\n    return this.state.undelivered;\n  }\n\n  /**\n   * Message considered as <b>failed</b> to be delivered to a participant if the message could not be sent.\n   * This can happen for various reasons including queue overflows, account suspensions and media\n   * errors (in the case of MMS for instance). Twilio does not charge you for failed messages.\n   *\n   * @return {@link DeliveryAmount} of participants that have <b>failed</b> delivery status for the message.\n   */\n  public get failed(): AggregatedDeliveryReceipt.DeliveryAmount {\n    return this.state.failed;\n  }\n\n  _update(data: AggregatedDeliveryReceipt.AggregatedDeliveryDescriptor): void {\n    this.state = data;\n  }\n\n  _isEquals(data: AggregatedDeliveryReceipt.AggregatedDeliveryDescriptor): boolean {\n    const isTotalSame = this.total === data.total;\n    const isSentSame = this.sent === data.sent;\n    const isDeliveredSame = this.delivered === data.delivered;\n    const isReadSame = this.read === data.read;\n    const isUndeliveredSame = this.undelivered === data.undelivered;\n    const isFailedSame = this.failed === data.failed;\n\n    return isTotalSame && isSentSame && isDeliveredSame && isReadSame && isUndeliveredSame && isFailedSame;\n  }\n}\n\nexport { AggregatedDeliveryReceipt };\n","namespace DetailedDeliveryReceipt {\n  export type Status  = 'sent' | 'delivered' | 'failed' | 'read' | 'undelivered' | 'queued';\n\n  export interface Descriptor {\n    sid: string;\n    message_sid: string;\n    conversation_sid: string;\n    channel_message_sid: string;\n    participant_sid: string;\n    status: Status;\n    error_code: number | null;\n    date_created: string;\n    date_updated: string;\n  }\n}\n\n/**\n * @classdesc Represents a delivery receipt of a {@link Message}.\n *\n * @property {String} sid - The unique identifier for Delivery Receipt\n * @property {String} messageSid - The unique identifier for Conversation Message\n * @property {String} conversationSid - The unique identifier for Conversation\n * @property {String} channelMessageSid - The unique identifier for the â€˜channelâ€™ message e.g WAxx for Whatsapp, SMxx for SMS\n * @property {String} participantSid - Participant's unique identifier\n * @property {DetailedDeliveryReceipt#Status} status - Message delivery status\n * @property {number | null} errorCode - Numeric error code mapped from Status callback code. Information about the error codes can be found\n * <a href=\"https://www.twilio.com/docs/sms/api/message-resource#delivery-related-errors\">here</a>.\n * @property {String} dateCreated - When Delivery Receipt was created\n * @property {String} dateUpdated - When Delivery Receipt was updated\n */\nexport class DetailedDeliveryReceipt {\n  sid: string;\n  messageSid: string;\n  conversationSid: string;\n  channelMessageSid: string;\n  participantSid: string;\n  status: DetailedDeliveryReceipt.Status;\n  errorCode: number | null;\n  dateCreated: string;\n  dateUpdated: string;\n\n  /**\n   * Signifies the message delivery status.\n   * @typedef {('sent'|'delivered'|'failed'|'read'|'undelivered'|'queued')} DetailedDeliveryReceipt#Status\n   */\n\n  constructor(descriptor: DetailedDeliveryReceipt.Descriptor) {\n    this.sid = descriptor.sid;\n    this.messageSid = descriptor.message_sid;\n    this.conversationSid = descriptor.conversation_sid;\n    this.channelMessageSid = descriptor.channel_message_sid;\n    this.participantSid = descriptor.participant_sid;\n    this.status = descriptor.status || 'queued';\n    this.errorCode = descriptor.error_code || 0;\n    this.dateCreated = descriptor.date_created;\n    this.dateUpdated = descriptor.date_updated;\n  }\n}\n","import { EventEmitter } from 'events';\nimport { isDeepEqual, parseAttributes, UriBuilder } from './util';\nimport { Logger } from './logger';\n\nimport { Conversation } from './conversation';\nimport { Session } from './session';\nimport { McsClient } from 'twilio-mcs-client';\nimport { Media } from './media';\nimport { Participant } from './participant';\nimport { AggregatedDeliveryReceipt } from './aggregateddeliveryreceipt';\nimport { validateTypesAsync, literal } from 'twilio-sdk-type-validator';\nimport { Network } from './services/network';\nimport { RestPaginator } from './restpaginator';\nimport { DetailedDeliveryReceipt } from './detaileddeliveryreceipt';\nimport { Paginator } from './interfaces/paginator';\n\nconst log = Logger.scope('Message');\n\nnamespace Message {\n  export type Type = 'text' | 'media';\n}\n\ninterface MessageState {\n  sid: string;\n  index: number;\n  author?: string;\n  subject?: string;\n  body: string;\n  dateUpdated: Date;\n  lastUpdatedBy: string;\n  attributes: Object;\n  timestamp: Date;\n  type: Message.Type;\n  media?: Media;\n  participantSid?: string;\n  aggregatedDeliveryReceipt?: AggregatedDeliveryReceipt;\n}\n\nexport interface MessageServices {\n  session: Session;\n  mcsClient: McsClient;\n  network: Network;\n}\n\nnamespace Message {\n  export type UpdateReason = 'body' | 'lastUpdatedBy' | 'dateCreated' | 'dateUpdated' | 'attributes' | 'author' |\n    'deliveryReceipt' | 'subject';\n\n  export interface UpdatedEventArgs {\n    message: Message;\n    updateReasons: Message.UpdateReason[];\n  }\n}\n\n/**\n * @classdesc A Message represents a Message in a Conversation.\n * @property {String} author - The name of the user that sent Message\n * @property {String|null} subject - Message subject. Used only in email conversations\n * @property {String} body - The body of the Message. Is null if Message is Media Message\n * @property {any} attributes - Message custom attributes\n * @property {Conversation} conversation - Conversation Message belongs to\n * @property {Date} dateCreated - When Message was created\n * @property {Date} dateUpdated - When Message was updated\n * @property {Number} index - Index of Message in the Conversation's messages list\n *  By design of the conversations system the message indices may have arbitrary gaps between them,\n *  that does not necessarily mean they were deleted or otherwise modified - just that\n *  messages may have non-contiguous indices even if they are sent immediately one after another.\n *\n *  Trying to use indices for some calculations is going to be unreliable.\n *\n *  To calculate the number of unread messages it is better to use the read horizon API.\n *  See {@link Conversation#getUnreadMessagesCount} for details.\n *\n * @property {String} lastUpdatedBy - Identity of the last user that updated Message\n * @property {Media} media - Contains Media information (if present)\n * @property {String} participantSid - Authoring Participant's server-assigned unique identifier\n * @property {String} sid - The server-assigned unique identifier for Message\n * @property {'text' | 'media'} type - Type of message: 'text' or 'media'\n * @property {AggregatedDeliveryReceipt | null} aggregatedDeliveryReceipt - Aggregated information about\n *   Message delivery statuses across all {@link Participant}s of a {@link Conversation}.\n * @fires Message#updated\n */\nclass Message extends EventEmitter {\n\n  public readonly conversation: Conversation;\n  private services: MessageServices;\n  private state: MessageState;\n\n  /**\n   * The update reason for <code>updated</code> event emitted on Message\n   * @typedef {('body' | 'lastUpdatedBy' | 'dateCreated' | 'dateUpdated' | 'attributes' | 'author' |\n   *   'deliveryReceipt' | 'subject')} Message#UpdateReason\n   */\n\n  constructor(conversation: Conversation, services: MessageServices, index: number, data: any) {\n    super();\n\n    this.conversation = conversation;\n    this.services = services;\n\n    this.state = {\n      sid: data.sid,\n      index: index,\n      author: data.author == null ? null : data.author,\n      subject: data.subject == null ? null : data.subject,\n      body: data.text,\n      timestamp: data.timestamp ? new Date(data.timestamp) : null,\n      dateUpdated: data.dateUpdated ? new Date(data.dateUpdated) : null,\n      lastUpdatedBy: data.lastUpdatedBy ? data.lastUpdatedBy : null,\n      attributes: parseAttributes(data.attributes, `Got malformed attributes for the message ${data.sid}`, log),\n      type: data.type ? data.type : 'text',\n      media: (data.type && data.type === 'media' && data.media)\n        ? new Media(data.media, this.services) : null,\n      participantSid: data.memberSid == null ? null : data.memberSid,\n      aggregatedDeliveryReceipt: data.delivery ? new AggregatedDeliveryReceipt(data.delivery) : null\n    };\n  }\n\n  public get sid(): string { return this.state.sid; }\n\n  public get author(): string { return this.state.author; }\n\n  public get subject(): string | null { return this.state.subject; }\n\n  public get body(): string {\n    if (this.type === 'media') { return null; }\n    return this.state.body;\n  }\n\n  public get dateUpdated(): Date { return this.state.dateUpdated; }\n\n  public get index(): number { return this.state.index; }\n\n  public get lastUpdatedBy(): string { return this.state.lastUpdatedBy; }\n\n  public get dateCreated(): Date { return this.state.timestamp; }\n\n  public get attributes(): Object { return this.state.attributes; }\n\n  public get type(): Message.Type { return this.state.type; }\n\n  public get media(): Media { return this.state.media; }\n\n  public get participantSid(): string { return this.state.participantSid; }\n\n  public get aggregatedDeliveryReceipt(): AggregatedDeliveryReceipt | null { return this.state.aggregatedDeliveryReceipt; }\n\n  _update(data) {\n    let updateReasons: Message.UpdateReason[] = [];\n\n    if ((data.text || ((typeof data.text) === 'string')) && data.text !== this.state.body) {\n      this.state.body = data.text;\n      updateReasons.push('body');\n    }\n\n    if (data.subject && data.subject !== this.state.subject) {\n      this.state.subject = data.subject;\n      updateReasons.push('subject');\n    }\n\n    if (data.lastUpdatedBy && data.lastUpdatedBy !== this.state.lastUpdatedBy) {\n      this.state.lastUpdatedBy = data.lastUpdatedBy;\n      updateReasons.push('lastUpdatedBy');\n    }\n\n    if (data.author && data.author !== this.state.author) {\n      this.state.author = data.author;\n      updateReasons.push('author');\n    }\n\n    if (data.dateUpdated &&\n      new Date(data.dateUpdated).getTime() !== (this.state.dateUpdated && this.state.dateUpdated.getTime())) {\n      this.state.dateUpdated = new Date(data.dateUpdated);\n      updateReasons.push('dateUpdated');\n    }\n\n    if (data.timestamp &&\n      new Date(data.timestamp).getTime() !== (this.state.timestamp && this.state.timestamp.getTime())) {\n      this.state.timestamp = new Date(data.timestamp);\n      updateReasons.push('dateCreated');\n    }\n\n    let updatedAttributes = parseAttributes(data.attributes, `Got malformed attributes for the message ${this.sid}`, log);\n    if (!isDeepEqual(this.state.attributes, updatedAttributes)) {\n      this.state.attributes = updatedAttributes;\n      updateReasons.push('attributes');\n    }\n\n    let updatedAggregatedDelivery = data.delivery;\n    let currentAggregatedDelivery = this.state.aggregatedDeliveryReceipt;\n    let isUpdatedAggregateDeliveryValid = !!updatedAggregatedDelivery && !!updatedAggregatedDelivery.total &&\n      !!updatedAggregatedDelivery.delivered && !!updatedAggregatedDelivery.failed && !!updatedAggregatedDelivery.read &&\n      !!updatedAggregatedDelivery.sent && !!updatedAggregatedDelivery.undelivered;\n    if (isUpdatedAggregateDeliveryValid) {\n      if (!currentAggregatedDelivery) {\n        this.state.aggregatedDeliveryReceipt = new AggregatedDeliveryReceipt(updatedAggregatedDelivery);\n        updateReasons.push('deliveryReceipt');\n      } else if (!currentAggregatedDelivery._isEquals(updatedAggregatedDelivery)) {\n        currentAggregatedDelivery._update(updatedAggregatedDelivery);\n        updateReasons.push('deliveryReceipt');\n      }\n    }\n\n    if (updateReasons.length > 0) {\n      this.emit('updated', { message: this, updateReasons: updateReasons });\n    }\n  }\n\n  /**\n   * Get Participant who is author of the Message\n   * @returns {Promise<Participant>}\n   */\n  async getParticipant(): Promise<Participant> {\n    let participant: Participant = null;\n    if (this.state.participantSid) {\n      participant = await this.conversation.getParticipantBySid(this.participantSid)\n        .catch(() => {\n          log.debug('Participant with sid \"' + this.participantSid + '\" not found for message ' + this.sid);\n          return null;\n        });\n    }\n    if (!participant && this.state.author) {\n      participant = await this.conversation.getParticipantByIdentity(this.state.author)\n        .catch(() => {\n          log.debug('Participant with identity \"' + this.author + '\" not found for message ' + this.sid);\n          return null;\n        });\n    }\n    if (participant) {\n      return participant;\n    }\n    let errorMesage = 'Participant with ';\n    if (this.state.participantSid) {\n      errorMesage += 'SID \\'' + this.state.participantSid + '\\' ';\n    }\n    if (this.state.author) {\n      if (this.state.participantSid) {\n        errorMesage += 'or ';\n      }\n      errorMesage += 'identity \\'' + this.state.author + '\\' ';\n    }\n    if (errorMesage === 'Participant with ') {\n      errorMesage = 'Participant ';\n    }\n    errorMesage += 'was not found';\n    throw new Error(errorMesage);\n  }\n\n  /**\n   * Get delivery receipts of the message\n   * @returns {Promise<DetailedDeliveryReceipt[]>}\n   */\n  async getDetailedDeliveryReceipts(): Promise<DetailedDeliveryReceipt[]> {\n    let paginator: Paginator<DetailedDeliveryReceipt> = await this._getDetailedDeliveryReceiptsPaginator();\n    let detailedDeliveryReceipts: DetailedDeliveryReceipt[] = [];\n\n    while (true) {\n      detailedDeliveryReceipts = [...detailedDeliveryReceipts, ...paginator.items];\n\n      if (!paginator.hasNextPage) {\n        break;\n      }\n\n      paginator = await paginator.nextPage();\n    }\n\n    return detailedDeliveryReceipts;\n  }\n\n  /**\n   * Remove the Message.\n   * @returns {Promise<Message>}\n   */\n  async remove(): Promise<Message> {\n    await this.services.session.addCommand('deleteMessage', {\n      channelSid: this.conversation.sid,\n      messageIdx: this.index.toString()\n    });\n    return this;\n  }\n\n  /**\n   * Edit message body.\n   * @param {String} body - new body of Message.\n   * @returns {Promise<Message>}\n   */\n  @validateTypesAsync('string')\n  async updateBody(body: string): Promise<Message> {\n    await this.services.session.addCommand('editMessage', {\n      channelSid: this.conversation.sid,\n      messageIdx: this.index.toString(),\n      text: body\n    });\n\n    return this;\n  }\n\n  /**\n   * Edit message attributes.\n   * @param {any} attributes new attributes for Message.\n   * @returns {Promise<Message>}\n   */\n  @validateTypesAsync(['string', 'number', 'boolean', 'object', literal(null)])\n  async updateAttributes(attributes: any): Promise<Message> {\n    await this.services.session.addCommand('editMessageAttributes', {\n      channelSid: this.conversation.sid,\n      messageIdx: this.index,\n      attributes: JSON.stringify(attributes)\n    });\n\n    return this;\n  }\n\n  private async _getDetailedDeliveryReceiptsPaginator(options?: {\n    pageToken?: string,\n    pageSize?: number\n  }): Promise<Paginator<DetailedDeliveryReceipt>> {\n    let links = await this.services.session.getSessionLinks();\n    let messagesReceiptsUrl = links.messagesReceiptsUrl.replace('%s', this.conversation.sid).replace('%s', this.sid);\n    let url = new UriBuilder(messagesReceiptsUrl).arg('PageToken', options?.pageToken).arg('PageSize', options?.pageSize).build();\n    let response = await this.services.network.get(url);\n\n    return new RestPaginator<DetailedDeliveryReceipt>(response.body.delivery_receipts.map(x => new DetailedDeliveryReceipt(x))\n      , (pageToken, pageSize) => this._getDetailedDeliveryReceiptsPaginator({ pageToken, pageSize })\n      , response.body.meta.previous_token\n      , response.body.meta.next_token);\n  }\n}\n\nexport { Message };\n\n/**\n * Fired when the Message's properties or body has been updated.\n * @event Message#updated\n * @type {Object}\n * @property {Message} message - Updated Message\n * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons\n */\n","import { EventEmitter } from 'events';\nimport { Logger } from '../logger';\n\nimport { Message } from '../message';\nimport { Conversation } from '../conversation';\n\nimport { SyncList, SyncClient } from 'twilio-sync';\nimport { SyncPaginator } from '../syncpaginator';\n\nimport { Session } from '../session';\nimport { McsClient, McsMedia } from 'twilio-mcs-client';\nimport { Network } from '../services/network';\n\nconst log = Logger.scope('Messages');\n\nexport interface MessagesServices {\n  session: Session;\n  mcsClient: McsClient;\n  network: Network;\n  syncClient: SyncClient;\n}\n\n/**\n * Represents the collection of messages in a conversation\n */\nclass Messages extends EventEmitter {\n  private readonly services: MessagesServices;\n  private readonly messagesByIndex: Map<number, Message>;\n  private messagesListPromise: Promise<SyncList>;\n\n  public readonly conversation: Conversation;\n\n  constructor(conversation: Conversation, services: MessagesServices) {\n    super();\n\n    this.conversation = conversation;\n    this.services = services;\n\n    this.messagesByIndex = new Map();\n    this.messagesListPromise = null;\n  }\n\n  /**\n   * Subscribe to the Messages Event Stream\n   * @param {String} name - The name of Sync object for the Messages resource.\n   * @returns {Promise}\n   */\n  subscribe(name: string) {\n    return this.messagesListPromise =\n      this.messagesListPromise ||\n      this.services.syncClient.list({ id: name, mode: 'open_existing' })\n          .then(list => {\n\n            list.on('itemAdded', args => {\n              log.debug(this.conversation.sid + ' itemAdded: ' + args.item.index);\n              let message = new Message(this.conversation, this.services, args.item.index, args.item.data);\n              if (this.messagesByIndex.has(message.index)) {\n                log.debug('Message arrived, but already known and ignored', this.conversation.sid, message.index);\n                return;\n              }\n\n              this.messagesByIndex.set(message.index, message);\n              message.on('updated',\n                (args: Message.UpdatedEventArgs) => this.emit('messageUpdated', args));\n              this.emit('messageAdded', message);\n            });\n\n            list.on('itemRemoved', args => {\n              log.debug(this.conversation.sid + ' itemRemoved: ' + args.index);\n              let index = args.index;\n              if (this.messagesByIndex.has(index)) {\n                let message = this.messagesByIndex.get(index);\n                this.messagesByIndex.delete(message.index);\n                message.removeAllListeners('updated');\n                this.emit('messageRemoved', message);\n              }\n            });\n\n            list.on('itemUpdated', args => {\n              log.debug(this.conversation.sid + ' itemUpdated: ' + args.item.index);\n              let message = this.messagesByIndex.get(args.item.index);\n              if (message) {\n                message._update(args.item.data);\n              }\n            });\n\n            return list;\n          })\n          .catch(err => {\n            this.messagesListPromise = null;\n            if (this.services.syncClient.connectionState != 'disconnected') {\n              log.error('Failed to get messages object for conversation', this.conversation.sid, err);\n            }\n            log.debug('ERROR: Failed to get messages object for conversation', this.conversation.sid, err);\n            throw err;\n          });\n  }\n\n  async unsubscribe() {\n    if (this.messagesListPromise) {\n      let entity = await this.messagesListPromise;\n      entity.close();\n      this.messagesListPromise = null;\n    }\n  }\n\n  /**\n   * Send Message to the conversation\n   * @param {String} message - Message to post\n   * @param {any} attributes Message attributes\n   * @param {Conversation.SendEmailOptions} emailOptions Options that modify E-mail integration behaviors.\n   * @returns Returns promise which can fail\n   */\n  async send(message: string, attributes: any = {}, emailOptions?: Conversation.SendEmailOptions) {\n    log.debug('Sending text message', message, attributes, emailOptions);\n\n    return this.services.session.addCommand('sendMessage', {\n      channelSid: this.conversation.sid,\n      text: message,\n      attributes: JSON.stringify(attributes),\n      subject: emailOptions?.subject,\n    });\n  }\n\n  /**\n   * Send Media Message to the conversation\n   * @param {FormData | Conversation#SendMediaOptions} mediaContent - Media content to post\n   * @param {any} attributes Message attributes\n   * @returns Returns promise which can fail\n   */\n  async sendMedia(mediaContent: FormData | Conversation.SendMediaOptions, attributes: any = {}, emailOptions?: Conversation.SendEmailOptions) {\n    log.debug('Sending media message', mediaContent, attributes, emailOptions);\n\n    let media: McsMedia;\n    if (typeof FormData !== 'undefined'  && (mediaContent instanceof FormData)) {\n      log.debug('Sending media message as FormData', mediaContent, attributes);\n      media = await this.services.mcsClient.postFormData(mediaContent);\n    } else {\n      log.debug('Sending media message as SendMediaOptions', mediaContent, attributes);\n      let mediaOptions = mediaContent as Conversation.SendMediaOptions;\n      if (!mediaOptions.contentType || !mediaOptions.media) {\n        throw new Error('Media content <Conversation#SendMediaOptions> must contain non-empty contentType and media');\n      }\n      media = await this.services.mcsClient.post(mediaOptions.contentType, mediaOptions.media);\n    }\n    // emailOptions are currently ignored for media messages.\n    return this.services.session.addCommand('sendMediaMessage', {\n      channelSid: this.conversation.sid,\n      mediaSid: media.sid,\n      attributes: JSON.stringify(attributes)\n    });\n  }\n\n  /**\n   * Returns messages from conversation using paginator interface\n   * @param {Number} [pageSize] Number of messages to return in single chunk. By default it's 30.\n   * @param {String} [anchor] Most early message id which is already known, or 'end' by default\n   * @param {String} [direction] Pagination order 'backwards' or 'forward', or 'forward' by default\n   * @returns {Promise<Paginator<Message>>} last page of messages by default\n   */\n  getMessages(pageSize, anchor, direction) {\n    anchor = (typeof anchor !== 'undefined') ? anchor : 'end';\n    direction = direction || 'backwards';\n    return this._getMessages(pageSize, anchor, direction);\n  }\n\n  private wrapPaginator(order, page, op) {\n    // We should swap next and prev page here, because of misfit of Sync and Chat paging conceptions\n    let shouldReverse = order === 'desc';\n\n    let np = () => page.nextPage().then(x => this.wrapPaginator(order, x, op));\n    let pp = () => page.prevPage().then(x => this.wrapPaginator(order, x, op));\n\n    return op(page.items).then(items => ({\n      items: items.sort((x, y) => { return x.index - y.index; }),\n      hasPrevPage: shouldReverse ? page.hasNextPage : page.hasPrevPage,\n      hasNextPage: shouldReverse ? page.hasPrevPage : page.hasNextPage,\n      prevPage: shouldReverse ? np : pp,\n      nextPage: shouldReverse ? pp : np\n    }));\n  }\n\n  private _upsertMessage(index: number, value: string) {\n    let cachedMessage = this.messagesByIndex.get(index);\n    if (cachedMessage) {\n      return cachedMessage;\n    }\n\n    let message = new Message(this.conversation, this.services, index, value);\n    this.messagesByIndex.set(message.index, message);\n    message.on('updated',\n      (args: Message.UpdatedEventArgs) => this.emit('messageUpdated', args));\n    return message;\n  }\n\n  /**\n   * Returns last messages from conversation\n   * @param {Number} [pageSize] Number of messages to return in single chunk. By default it's 30.\n   * @param {String} [anchor] Most early message id which is already known, or 'end' by default\n   * @param {String} [direction] Pagination order 'backwards' or 'forward', or 'forward' by default\n   * @returns {Promise<SyncPaginator<Message>>} last page of messages by default\n   * @private\n   */\n  private _getMessages(pageSize, anchor, direction): Promise<SyncPaginator<Message>> {\n    anchor = (typeof anchor !== 'undefined') ? anchor : 'end';\n    pageSize = pageSize || 30;\n    let order = direction === 'backwards' ? 'desc' : 'asc';\n\n    return this.messagesListPromise\n               .then(messagesList => messagesList.getItems({\n                 from: anchor !== 'end' ? anchor : void (0),\n                 pageSize,\n                 order\n               }))\n               .then(page => this.wrapPaginator(order, page\n                 , items => Promise.all(items.map(item => this._upsertMessage(item.index, item.data))))\n               );\n  }\n}\n\nexport { Messages };\n","import { EventEmitter } from 'events';\nimport { Logger } from './logger';\n\nimport { Participants } from './data/participants';\nimport { Participant } from './participant';\nimport { Messages } from './data/messages';\nimport { Message } from './message';\n\nimport { UriBuilder, isDeepEqual, parseToNumber } from './util';\nimport { Users } from './data/users';\nimport { Paginator } from './interfaces/paginator';\nimport { Conversations } from './data/conversations';\nimport { McsClient } from 'twilio-mcs-client';\n\nimport { SyncClient } from 'twilio-sync';\nimport { Session } from './session';\nimport { ReadHorizon } from './services/readhorizon';\nimport { TypingIndicator } from './services/typingindicator';\nimport { Network } from './services/network';\nimport { validateTypesAsync, custom, literal, nonEmptyString, nonNegativeInteger, objectSchema } from 'twilio-sdk-type-validator';\n\nconst log = Logger.scope('Conversation');\n\nconst fieldMappings = {\n  lastMessage: 'lastMessage',\n  attributes: 'attributes',\n  createdBy: 'createdBy',\n  dateCreated: 'dateCreated',\n  dateUpdated: 'dateUpdated',\n  friendlyName: 'friendlyName',\n  lastConsumedMessageIndex: 'lastConsumedMessageIndex',\n  notificationLevel: 'notificationLevel',\n  sid: 'sid',\n  status: 'status',\n  uniqueName: 'uniqueName',\n  state: 'state'\n};\n\nfunction parseTime(timeString) {\n  try {\n    return new Date(timeString);\n  } catch (e) {\n    return null;\n  }\n}\n\nexport interface ConversationServices {\n  session: Session;\n  users: Users;\n  typingIndicator: TypingIndicator;\n  readHorizon: ReadHorizon;\n  network: Network;\n  mcsClient: McsClient;\n  syncClient: SyncClient;\n}\n\ninterface ConversationState {\n  uniqueName: string;\n  status: Conversation.Status;\n  attributes: any;\n  createdBy?: string;\n  dateCreated: Date;\n  dateUpdated: Date;\n  friendlyName?: string;\n  lastReadMessageIndex: number | null;\n  lastMessage?: Conversation.LastMessage;\n  notificationLevel?: Conversation.NotificationLevel;\n  state?: Conversation.State;\n}\n\ninterface ConversationDescriptor {\n  channel: string;\n  entityName: string;\n  uniqueName: string;\n  attributes: any;\n  createdBy?: string;\n  friendlyName?: string;\n  lastConsumedMessageIndex: number;\n  dateCreated: any;\n  dateUpdated: any;\n  notificationLevel?: Conversation.NotificationLevel;\n}\n\nnamespace Conversation {\n  export type UpdateReason = 'attributes' | 'createdBy' | 'dateCreated' | 'dateUpdated' |\n    'friendlyName' | 'lastReadMessageIndex' | 'state' | 'status' | 'uniqueName' | 'lastMessage' | 'notificationLevel';\n\n  export type Status = 'notParticipating' | 'joined';\n\n  export type NotificationLevel = 'default' | 'muted';\n\n  export type State = {\n    current: 'active' | 'inactive' | 'closed',\n    dateUpdated: Date\n  } | undefined;\n\n  export interface UpdatedEventArgs {\n    conversation: Conversation;\n    updateReasons: Conversation.UpdateReason[];\n  }\n\n  export interface SendMediaOptions {\n    contentType: string;\n    media: string | Buffer;\n  }\n\n  export interface SendEmailOptions {\n    subject?: string;\n  }\n\n  export interface LastMessage {\n    index?: number;\n    dateCreated?: Date;\n  }\n}\n\n/**\n * @classdesc A Conversation represents communication between multiple Conversations Clients\n * @property {any} attributes - The Conversation's custom attributes\n * @property {String} createdBy - The identity of the User that created this Conversation\n * @property {Date} dateCreated - The Date this Conversation was created\n * @property {Date} dateUpdated - The Date this Conversation was last updated\n * @property {String} [friendlyName] - The Conversation's name\n * @property {Number|null} lastReadMessageIndex - Index of the last Message the User has read in this Conversation\n * @property {Conversation#LastMessage} lastMessage - Last Message sent to this Conversation\n * @property {Conversation#NotificationLevel} notificationLevel - User Notification level for this Conversation\n * @property {String} sid - The Conversation's unique system identifier\n * @property {Conversation#Status} status - The Conversation's status\n * @property {Conversation#State} state - The Conversation's state\n * @property {String} uniqueName - The Conversation's unique name\n * @fires Conversation#participantJoined\n * @fires Conversation#participantLeft\n * @fires Conversation#participantUpdated\n * @fires Conversation#messageAdded\n * @fires Conversation#messageRemoved\n * @fires Conversation#messageUpdated\n * @fires Conversation#typingEnded\n * @fires Conversation#typingStarted\n * @fires Conversation#updated\n * @fires Conversation#removed\n */\nclass Conversation extends EventEmitter {\n  public readonly sid: string;\n\n  private services: ConversationServices;\n  private channelState: ConversationState;\n  private statusSource: Conversations.DataSource;\n\n  private entityPromise: Promise<any>;\n  private entityName: string;\n  private entity: any;\n  private messagesEntity: any;\n  private participantsEntity: Participants;\n  private participants: any;\n\n  /**\n   * These options can be passed to {@link Conversation#sendMessage}.\n   * @typedef {Object} Conversation#SendMediaOptions\n   * @property {String} contentType - content type of media\n   * @property {String | Buffer} media - content to post\n   */\n\n  /**\n   * These options can be passed to {@link Conversation#sendMessage}.\n   * @typedef {Object} Conversation#SendEmailOptions\n   * @property {String} subject - subject for the message. Ignored for media messages.\n   */\n\n  /**\n   * The update reason for <code>updated</code> event emitted on Conversation\n   * @typedef {('attributes' | 'createdBy' | 'dateCreated' | 'dateUpdated' |\n    'friendlyName' | 'lastReadMessageIndex' | 'state' | 'status' | 'uniqueName' | 'lastMessage' |\n    'notificationLevel' )} Conversation#UpdateReason\n   */\n\n  /**\n   * The status of the Conversation, relative to the Client: whether the Conversation has been <code>joined</code> or the Client is\n   * <code>notParticipating</code> in the Conversation.\n   * @typedef {('notParticipating' | 'joined')} Conversation#Status\n   */\n\n  /**\n   * The User's Notification level for Conversation, determines whether the currently logged-in User will receive\n   * pushes for events in this Conversation. Can be either <code>muted</code> or <code>default</code>,\n   * where <code>default</code> defers to global Service push configuration.\n   * @typedef {('default' | 'muted')} Conversation#NotificationLevel\n   */\n\n  /**\n   * The Conversation's state.\n   * @typedef {Object} Conversation#State\n   * @property {('active' | 'inactive' | 'closed')} current - the current state\n   * @property {Date} dateUpdated - date at which the latest conversation state update happened\n   */\n\n  constructor(services: ConversationServices, descriptor: ConversationDescriptor, sid: string) {\n    super();\n\n    let attributes = descriptor.attributes || {};\n    let createdBy = descriptor.createdBy;\n    let dateCreated = parseTime(descriptor.dateCreated);\n    let dateUpdated = parseTime(descriptor.dateUpdated);\n    let friendlyName = descriptor.friendlyName || null;\n    let lastReadMessageIndex =\n      Number.isInteger(descriptor.lastConsumedMessageIndex) ? descriptor.lastConsumedMessageIndex : null;\n    let uniqueName = descriptor.uniqueName || null;\n\n    try {\n      JSON.stringify(attributes);\n    } catch (e) {\n      throw new Error('Attributes must be a valid JSON object.');\n    }\n\n    this.services = services;\n\n    this.sid = sid;\n    this.entityName = descriptor.channel;\n    this.channelState = {\n      uniqueName,\n      status: 'notParticipating',\n      attributes,\n      createdBy,\n      dateCreated,\n      dateUpdated,\n      friendlyName,\n      lastReadMessageIndex: lastReadMessageIndex\n    };\n\n    if (descriptor.notificationLevel) {\n      this.channelState.notificationLevel = descriptor.notificationLevel;\n    }\n\n    this.participants = new Map();\n    this.participantsEntity = new Participants(this, this.services, this.participants);\n    this.participantsEntity.on('participantJoined', this.emit.bind(this, 'participantJoined'));\n    this.participantsEntity.on('participantLeft', this.emit.bind(this, 'participantLeft'));\n    this.participantsEntity.on('participantUpdated',\n      (args: Participant.UpdatedEventArgs) => this.emit('participantUpdated', args));\n\n    this.messagesEntity = new Messages(this, services);\n    this.messagesEntity.on('messageAdded', message => this._onMessageAdded(message));\n    this.messagesEntity.on('messageUpdated',\n      (args: Message.UpdatedEventArgs) => this.emit('messageUpdated', args));\n    this.messagesEntity.on('messageRemoved', this.emit.bind(this, 'messageRemoved'));\n  }\n\n  public get uniqueName(): string { return this.channelState.uniqueName; }\n\n  public get status(): Conversation.Status { return this.channelState.status; }\n\n  public get friendlyName(): string { return this.channelState.friendlyName; }\n\n  public get dateUpdated(): any { return this.channelState.dateUpdated; }\n\n  public get dateCreated(): any { return this.channelState.dateCreated; }\n\n  public get createdBy(): string { return this.channelState.createdBy; }\n\n  public get attributes(): Object { return this.channelState.attributes; }\n\n  public get lastReadMessageIndex(): number | null { return this.channelState.lastReadMessageIndex; }\n\n  public get lastMessage(): Conversation.LastMessage { return this.channelState.lastMessage; }\n\n  public get notificationLevel(): Conversation.NotificationLevel { return this.channelState.notificationLevel; }\n\n  public get state(): Conversation.State { return this.channelState.state; }\n\n  /**\n   * The Conversation's last message's information.\n   * @typedef {Object} Conversation#LastMessage\n   * @property {Number} index - Message's index\n   * @property {Date} dateCreated - Message's creation date\n   */\n\n  /**\n   * Load and Subscribe to this Conversation and do not subscribe to its Participants and Messages.\n   * This or _subscribeStreams will need to be called before any events on Conversation will fire.\n   * @returns {Promise}\n   * @private\n   */\n  _subscribe() {\n    if (this.entityPromise) { return this.entityPromise; }\n\n    return this.entityPromise = this.entityPromise ||\n      this.services.syncClient.document({ id: this.entityName, mode: 'open_existing' })\n        .then(entity => {\n          this.entity = entity;\n          this.entity.on('updated', args => { this._update(args.data); });\n          this.entity.on('removed', () => this.emit('removed', this));\n          this._update(this.entity.data);\n          return entity;\n        })\n        .catch(err => {\n          this.entity = null;\n          this.entityPromise = null;\n          if (this.services.syncClient.connectionState != 'disconnected') {\n            log.error('Failed to get conversation object', err);\n          }\n          log.debug('ERROR: Failed to get conversation object', err);\n          throw err;\n        });\n  }\n\n  /**\n   * Load the attributes of this Conversation and instantiate its Participants and Messages.\n   * This or _subscribe will need to be called before any events on Conversation will fire.\n   * This will need to be called before any events on Participants or Messages will fire\n   * @returns {Promise}\n   * @private\n   */\n  async _subscribeStreams() {\n    try {\n      await this._subscribe();\n      log.trace('_subscribeStreams, this.entity.data=', this.entity.data);\n      const messagesObjectName = this.entity.data.messages;\n      const rosterObjectName = this.entity.data.roster;\n      await Promise.all([\n        this.messagesEntity.subscribe(messagesObjectName),\n        this.participantsEntity.subscribe(rosterObjectName)\n      ]);\n    } catch (err) {\n      if (this.services.syncClient.connectionState !== 'disconnected') {\n        log.error('Failed to subscribe on conversation objects', this.sid, err);\n      }\n      log.debug('ERROR: Failed to subscribe on conversation objects', this.sid, err);\n      throw err;\n    }\n  }\n\n  /**\n   * Stop listening for and firing events on this Conversation.\n   * @returns {Promise}\n   * @private\n   */\n  async _unsubscribe() {\n    if (this.entity) {\n      await this.entity.close();\n      this.entity = null;\n      this.entityPromise = null;\n    }\n\n    return Promise.all([\n      this.participantsEntity.unsubscribe(),\n      this.messagesEntity.unsubscribe()\n    ]);\n  }\n\n  /**\n   * Set conversation status\n   * @private\n   */\n  _setStatus(status: Conversation.Status, source: Conversations.DataSource) {\n    this.statusSource = source;\n\n    if (this.channelState.status === status) { return; }\n\n    this.channelState.status = status;\n\n    if (status === 'joined') {\n      this._subscribeStreams()\n        .catch(err => {\n          log.debug('ERROR while setting conversation status ' + status, err);\n          if (this.services.syncClient.connectionState !== 'disconnected') {\n            throw err;\n          }\n        });\n    } else if (this.entityPromise) {\n      this._unsubscribe().catch(err => {\n        log.debug('ERROR while setting conversation status ' + status, err);\n        if (this.services.syncClient.connectionState !== 'disconnected') {\n          throw err;\n        }\n      });\n    }\n  }\n\n  /**\n   * If conversation's status update source\n   * @private\n   * @return {Conversations.DataSource}\n   */\n  _statusSource(): Conversations.DataSource {\n    return this.statusSource;\n  }\n\n  private static preprocessUpdate(update, conversationSid) {\n    try {\n      if (typeof update.attributes === 'string') {\n        update.attributes = JSON.parse(update.attributes);\n      } else if (update.attributes) {\n        JSON.stringify(update.attributes);\n      }\n    } catch (e) {\n      log.warn('Retrieved malformed attributes from the server for conversation: ' + conversationSid);\n      update.attributes = {};\n    }\n\n    try {\n      if (update.dateCreated) {\n        update.dateCreated = new Date(update.dateCreated);\n      }\n    } catch (e) {\n      log.warn('Retrieved malformed dateCreated from the server for conversation: ' + conversationSid);\n      delete update.dateCreated;\n    }\n\n    try {\n      if (update.dateUpdated) {\n        update.dateUpdated = new Date(update.dateUpdated);\n      }\n    } catch (e) {\n      log.warn('Retrieved malformed dateUpdated from the server for conversation: ' + conversationSid);\n      delete update.dateUpdated;\n    }\n\n    try {\n      if (update.lastMessage && update.lastMessage.timestamp) {\n        update.lastMessage.timestamp = new Date(update.lastMessage.timestamp);\n      }\n    } catch (e) {\n      log.warn('Retrieved malformed lastMessage.timestamp from the server for conversation: ' + conversationSid);\n      delete update.lastMessage.timestamp;\n    }\n  }\n\n  /**\n   * Updates local conversation object with new values\n   * @private\n   */\n  _update(update) {\n    log.trace('_update', update);\n\n    Conversation.preprocessUpdate(update, this.sid);\n    const updateReasons = new Set<Conversation.UpdateReason>();\n\n    for (const key of Object.keys(update)) {\n      const localKey = fieldMappings[key];\n\n      if (!localKey) {\n        continue;\n      }\n\n      switch (localKey) {\n        case fieldMappings.status:\n          if (!update.status || update.status === 'unknown'\n            || this.channelState.status === update.status) {\n            break;\n          }\n\n          this.channelState.status = update.status;\n          updateReasons.add(localKey);\n\n          break;\n        case fieldMappings.attributes:\n          if (isDeepEqual(this.channelState.attributes, update.attributes)) {\n            break;\n          }\n\n          this.channelState.attributes = update.attributes;\n          updateReasons.add(localKey);\n\n          break;\n        case fieldMappings.lastConsumedMessageIndex:\n          if (update.lastConsumedMessageIndex === undefined\n            || update.lastConsumedMessageIndex === this.channelState.lastReadMessageIndex) {\n            break;\n          }\n\n          this.channelState.lastReadMessageIndex = update.lastConsumedMessageIndex;\n          updateReasons.add('lastReadMessageIndex');\n\n          break;\n        case fieldMappings.lastMessage:\n          if (this.channelState.lastMessage && !update.lastMessage) {\n            delete this.channelState.lastMessage;\n            updateReasons.add(localKey);\n\n            break;\n          }\n\n          this.channelState.lastMessage = this.channelState.lastMessage || {};\n\n          if (update.lastMessage?.index !== undefined\n            && update.lastMessage.index !== this.channelState.lastMessage.index) {\n            this.channelState.lastMessage.index = update.lastMessage.index;\n            updateReasons.add(localKey);\n          }\n\n          if (update.lastMessage?.timestamp !== undefined\n            && this.channelState.lastMessage?.dateCreated?.getTime() !== update.lastMessage.timestamp.getTime()) {\n            this.channelState.lastMessage.dateCreated = update.lastMessage.timestamp;\n            updateReasons.add(localKey);\n          }\n\n          if (isDeepEqual(this.channelState.lastMessage, {})) {\n            delete this.channelState.lastMessage;\n          }\n\n          break;\n        case fieldMappings.state:\n          const state = update.state || undefined;\n\n          if (state !== undefined) {\n            state.dateUpdated = new Date(state.dateUpdated);\n          }\n\n          if (isDeepEqual(this.channelState.state, state)) {\n            break;\n          }\n\n          this.channelState.state = state;\n          updateReasons.add(localKey);\n\n          break;\n        default:\n          const isDate = update[key] instanceof Date;\n          const keysMatchAsDates = isDate && this.channelState[localKey]?.getTime() === update[key].getTime();\n          const keysMatchAsNonDates = !isDate && this[localKey] === update[key];\n\n          if (keysMatchAsDates || keysMatchAsNonDates) {\n            break;\n          }\n\n          this.channelState[localKey] = update[key];\n          updateReasons.add(localKey);\n      }\n    }\n\n    if (updateReasons.size > 0) {\n      this.emit('updated', { conversation: this, updateReasons: [...updateReasons] });\n    }\n  }\n\n  /**\n   * @private\n   */\n  private _onMessageAdded(message) {\n    for (let participant of this.participants.values()) {\n      if (participant.identity === message.author) {\n        participant._endTyping();\n        break;\n      }\n    }\n    this.emit('messageAdded', message);\n  }\n\n  /**\n   * Add a participant to the Conversation by its Identity.\n   * @param {String} identity - Identity of the Client to add\n   * @param {any} [attributes] Attributes to be attached to the participant\n   * @returns {Promise<void>}\n   */\n  @validateTypesAsync(\n    nonEmptyString,\n    ['undefined', 'string', 'number', 'boolean', 'object', literal(null)]\n  )\n  async add(identity: string, attributes?: any): Promise<void> {\n    return this.participantsEntity.add(identity, attributes);\n  }\n\n  /**\n   * Add a non-chat participant to the Conversation.\n   *\n   * @param {String} proxyAddress Proxy (Twilio) address of the participant\n   * @param {String} address User address of the participant\n   * @param {any} [attributes] Attributes to be attached to the participant\n   * @returns {Promise<void>}\n   */\n  @validateTypesAsync(nonEmptyString, nonEmptyString, ['undefined', 'object'])\n  async addNonChatParticipant(proxyAddress: string, address: string, attributes: Record<string, any> = {}) {\n    return this.participantsEntity.addNonChatParticipant(proxyAddress, address, attributes);\n  }\n\n  /**\n   * Advance Conversation's last read Message index to current read horizon.\n   * Rejects if User is not Participant of Conversation.\n   * Last read Message index is updated only if new index value is higher than previous.\n   * @param {Number} index - Message index to advance to as last read\n   * @returns {Promise<number>} resulting unread messages count in the conversation\n   */\n  @validateTypesAsync(nonNegativeInteger)\n  async advanceLastReadMessageIndex(index: number): Promise<number> {\n    await this._subscribeStreams();\n    return this.services.readHorizon.advanceLastReadMessageIndexForConversation(this.sid, index, this.lastReadMessageIndex);\n  }\n\n  /**\n   * Delete the Conversation and unsubscribe from its events.\n   * @returns {Promise<Conversation>}\n   */\n  async delete(): Promise<Conversation> {\n    await this.services.session.addCommand('destroyChannel', {\n      channelSid: this.sid\n    });\n    return this;\n  }\n\n  /**\n   * Get the custom attributes of this Conversation.\n   * @returns {Promise<any>} attributes of this Conversation\n   */\n  async getAttributes(): Promise<any> {\n    await this._subscribe();\n    return this.attributes;\n  }\n\n  /**\n   * Returns messages from conversation using paginator interface.\n   * @param {Number} [pageSize=30] Number of messages to return in single chunk\n   * @param {Number} [anchor] - Index of newest Message to fetch. From the end by default\n   * @param {('backwards'|'forward')} [direction=backwards] - Query direction. By default it query backwards\n   *                                                          from newer to older. 'forward' will query in opposite direction\n   * @returns {Promise<Paginator<Message>>} page of messages\n   */\n  @validateTypesAsync(\n    ['undefined', nonNegativeInteger],\n    ['undefined', nonNegativeInteger],\n    ['undefined', literal('backwards', 'forward')]\n  )\n  async getMessages(pageSize?: number, anchor?: number, direction?: 'backwards' | 'forward'): Promise<Paginator<Message>> {\n    await this._subscribeStreams();\n    return this.messagesEntity.getMessages(pageSize, anchor, direction);\n  }\n\n  /**\n   * Get a list of all Participants joined to this Conversation.\n   * @returns {Promise<Participant[]>}\n   */\n  async getParticipants(): Promise<Participant[]> {\n    await this._subscribeStreams();\n    return this.participantsEntity.getParticipants();\n  }\n\n  /**\n   * Get conversation participants count.\n   * <br/>\n   * This method is semi-realtime. This means that this data will be eventually correct,\n   * but will also possibly be incorrect for a few seconds. The Conversation system does not\n   * provide real time events for counter values changes.\n   * <br/>\n   * So this is quite useful for any UI badges, but is not recommended\n   * to build any core application logic based on these counters being accurate in real time.\n   * @returns {Promise<number>}\n   */\n  async getParticipantsCount(): Promise<number> {\n    let links = await this.services.session.getSessionLinks();\n    let url = new UriBuilder(links.publicChannelsUrl).path(this.sid).build();\n    let response = await this.services.network.get(url);\n    return response.body.members_count;\n  }\n\n  /**\n   * Get a Participant by its SID.\n   * @param {String} participantSid - Participant sid\n   * @returns {Promise<Participant>}\n   */\n  @validateTypesAsync(nonEmptyString)\n  async getParticipantBySid(participantSid: string): Promise<Participant> {\n    return this.participantsEntity.getParticipantBySid(participantSid);\n  }\n\n  /**\n   * Get a Participant by its identity.\n   * @param {String} identity - Participant identity\n   * @returns {Promise<Participant>}\n   */\n  @validateTypesAsync(nonEmptyString)\n  async getParticipantByIdentity(identity: string): Promise<Participant> {\n    return this.participantsEntity.getParticipantByIdentity(identity);\n  }\n\n  /**\n   * Get total message count in a conversation.\n   * <br/>\n   * This method is semi-realtime. This means that this data will be eventually correct,\n   * but will also possibly be incorrect for a few seconds. The Conversations system does not\n   * provide real time events for counter values changes.\n   * <br/>\n   * So this is quite useful for any UI badges, but is not recommended\n   * to build any core application logic based on these counters being accurate in real time.\n   * @returns {Promise<number>}\n   */\n  async getMessagesCount(): Promise<number> {\n    let links = await this.services.session.getSessionLinks();\n    let url = new UriBuilder(links.publicChannelsUrl).path(this.sid).build();\n    let response = await this.services.network.get(url);\n    return response.body.messages_count;\n  }\n\n  /**\n   * Get unread messages count for the User if they are a Participant of this Conversation.\n   * Rejects if the User is not a Participant of the Conversation.\n   * <br/>\n   * Use this method to obtain the number of unread messages together with\n   * updateLastReadMessageIndex() instead of relying on the\n   * Message indices which may have gaps. See Message.index for details.\n   * <br/>\n   * This method is semi-realtime. This means that this data will be eventually correct,\n   * but will also possibly be incorrect for a few seconds. The Chat system does not\n   * provide real time events for counter values changes.\n   * <br/>\n   * This is quite useful for any â€œunread messages countâ€ badges, but is not recommended\n   * to build any core application logic based on these counters being accurate in real time.\n   * @returns {Promise<number|null>}\n   */\n  async getUnreadMessagesCount(): Promise<number | null> {\n    let links = await this.services.session.getSessionLinks();\n    let url = new UriBuilder(links.myChannelsUrl).arg('ChannelSid', this.sid).build();\n    let response = await this.services.network.get(url);\n    if (response.body.channels.length && response.body.channels[0].channel_sid == this.sid) {\n      if ((typeof response.body.channels[0].unread_messages_count !== 'undefined') && response.body.channels[0].unread_messages_count != null) {\n        return response.body.channels[0].unread_messages_count;\n      }\n      return null;\n    }\n\n    throw new Error('Conversation is not in user conversations list');\n  }\n\n  /**\n   * Join the Conversation and subscribe to its events.\n   * @returns {Promise<Conversation>}\n   */\n  async join(): Promise<Conversation> {\n    await this.services.session.addCommand('joinChannelV2', { channelSid: this.sid });\n    return this;\n  }\n\n  /**\n   * Leave the Conversation.\n   * @returns {Promise<Conversation>}\n   */\n  async leave(): Promise<Conversation> {\n    if (this.channelState.status === 'joined') {\n      await this.services.session.addCommand('leaveChannel', { channelSid: this.sid });\n    }\n\n    return this;\n  }\n\n  /**\n   * Remove a Participant from the Conversation. When a string is passed as the argument, it will assume that the string is an identity.\n   * @param {String|Participant} participant - identity or participant object to remove\n   * @returns {Promise<void>}\n   */\n  @validateTypesAsync([nonEmptyString, Participant])\n  async removeParticipant(participant: string | Participant): Promise<void> {\n    if (participant instanceof Participant) {\n      await this.participantsEntity.removeBySid(participant.sid);\n      return;\n    }\n\n    await this.participantsEntity.removeByIdentity(participant as string);\n  }\n\n  /**\n   * Send a Message in the Conversation.\n   * @param {String|FormData|Conversation#SendMediaOptions|null} message - The message body for text message,\n   * FormData or MediaOptions for media content. Sending FormData supported only with browser engine\n   * @param {any} [messageAttributes] - attributes for the message\n   * @param {Conversation#SendEmailOptions} [emailOptions] - email options for the message\n   * @returns {Promise<number>} new Message's index in the Conversation's messages list\n   */\n  @validateTypesAsync(\n    [\n      'string',\n      literal(null),\n      // Wrapping it into a custom rule is necessary because the FormData class is not available on initialization.\n      custom((value) => [value instanceof FormData, 'an instance of FormData']),\n      objectSchema('media options', {\n        contentType: nonEmptyString,\n        media: custom((value) => {\n          let isValid = (typeof value === 'string' && value.length > 0) || value instanceof Uint8Array || value instanceof ArrayBuffer;\n\n          if (typeof Blob === 'function') {\n            isValid = isValid || value instanceof Blob;\n          }\n\n          return [\n            isValid,\n            'a non-empty string, an instance of Buffer or an instance of Blob'\n          ];\n        })\n      })\n    ],\n    ['undefined', 'string', 'number', 'boolean', 'object', literal(null)],\n    ['undefined', literal(null), objectSchema('email attributes', {\n      subject: [nonEmptyString, 'undefined']\n    })]\n  )\n  async sendMessage(message: string | FormData | Conversation.SendMediaOptions | null, messageAttributes?: any,\n                    emailOptions?: Conversation.SendEmailOptions): Promise<number> {\n    if (typeof message === 'string' || message === null) {\n      let response = await this.messagesEntity.send(message, messageAttributes, emailOptions);\n      return parseToNumber(response.messageId);\n    }\n\n    let response = await this.messagesEntity.sendMedia(message, messageAttributes, emailOptions);\n    return parseToNumber(response.messageId);\n  }\n\n  /**\n   * Set last read Conversation's Message index to last known Message's index in this Conversation.\n   * @returns {Promise<number>} resulting unread messages count in the conversation\n   */\n  async setAllMessagesRead(): Promise<number> {\n    await this._subscribeStreams();\n\n    let messagesPage = await this.getMessages(1);\n\n    if (messagesPage.items.length > 0) {\n      return this.advanceLastReadMessageIndex(messagesPage.items[0].index);\n    }\n\n    return Promise.resolve(0);\n  }\n\n  /**\n   * Set all messages in the conversation unread.\n   * @returns {Promise<number>} resulting unread messages count in the conversation\n   */\n  async setAllMessagesUnread(): Promise<number> {\n    await this._subscribeStreams();\n    return this.services.readHorizon.updateLastReadMessageIndexForConversation(this.sid, null);\n  }\n\n  /**\n   * Set User Notification level for this conversation.\n   * @param {Conversation#NotificationLevel} notificationLevel - The new user notification level\n   * @returns {Promise<void>}\n   */\n  @validateTypesAsync(literal('default', 'muted'))\n  async setUserNotificationLevel(notificationLevel: Conversation.NotificationLevel): Promise<void> {\n    await this.services.session.addCommand('editNotificationLevel', { channelSid: this.sid, notificationLevel: notificationLevel });\n  }\n\n  /**\n   * Send a notification to the server indicating that this Client is currently typing in this Conversation.\n   * Typing ended notification is sent after a while automatically, but by calling again this method you ensure typing ended is not received.\n   * @returns {Promise<void>}\n   */\n  typing(): Promise<void> {\n    return this.services.typingIndicator.send(this.sid);\n  }\n\n  /**\n   * Update the Conversation's attributes.\n   * @param {any} attributes - The new attributes object\n   * @returns {Promise<Conversation>}\n   */\n  @validateTypesAsync(['string', 'number', 'boolean', 'object', literal(null)])\n  async updateAttributes(attributes: any): Promise<Conversation> {\n    await this.services.session.addCommand('editAttributes', {\n      channelSid: this.sid,\n      attributes: JSON.stringify(attributes)\n    });\n\n    return this;\n  }\n\n  /**\n   * Update the Conversation's friendlyName.\n   * @param {String|null} name - The new Conversation friendlyName\n   * @returns {Promise<Conversation>}\n   */\n  @validateTypesAsync(['string', literal(null)])\n  async updateFriendlyName(name: string | null): Promise<Conversation> {\n    if (this.channelState.friendlyName !== name) {\n      await this.services.session.addCommand('editFriendlyName', {\n        channelSid: this.sid,\n        friendlyName: name\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Set Conversation's last read Message index to current read horizon.\n   * @param {Number|null} index - Message index to set as last read.\n   * If null provided, then the behavior is identical to {@link Conversation#setAllMessagesUnread}\n   * @returns {Promise<number>} resulting unread messages count in the conversation\n   */\n  @validateTypesAsync([literal(null), nonNegativeInteger])\n  async updateLastReadMessageIndex(index: number | null): Promise<number> {\n    await this._subscribeStreams();\n    return this.services.readHorizon.updateLastReadMessageIndexForConversation(this.sid, index);\n  }\n\n  /**\n   * Update the Conversation's unique name.\n   * @param {String|null} uniqueName - New unique name for the Conversation. Setting unique name to null removes it.\n   * @returns {Promise<Conversation>}\n   */\n  @validateTypesAsync(['string', literal(null)])\n  async updateUniqueName(uniqueName: string | null): Promise<Conversation> {\n    if (this.channelState.uniqueName !== uniqueName) {\n      if (!uniqueName) {\n        uniqueName = '';\n      }\n\n      await this.services.session.addCommand('editUniqueName', {\n        channelSid: this.sid,\n        uniqueName: uniqueName\n      });\n    }\n\n    return this;\n  }\n}\n\nexport { ConversationDescriptor, Conversation };\n\n/**\n * Fired when a Participant has joined the Conversation.\n * @event Conversation#participantJoined\n * @type {Participant}\n */\n/**\n * Fired when a Participant has left the Conversation.\n * @event Conversation#participantLeft\n * @type {Participant}\n */\n/**\n * Fired when a Participant's fields has been updated.\n * @event Conversation#participantUpdated\n * @type {Object}\n * @property {Participant} participant - Updated Participant\n * @property {Participant#UpdateReason[]} updateReasons - Array of Participant's updated event reasons\n */\n/**\n * Fired when a new Message has been added to the Conversation.\n * @event Conversation#messageAdded\n * @type {Message}\n */\n/**\n * Fired when Message is removed from Conversation's message list.\n * @event Conversation#messageRemoved\n * @type {Message}\n */\n/**\n * Fired when an existing Message's fields are updated with new values.\n * @event Conversation#messageUpdated\n * @type {Object}\n * @property {Message} message - Updated Message\n * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons\n */\n/**\n * Fired when a Participant has stopped typing.\n * @event Conversation#typingEnded\n * @type {Participant}\n */\n/**\n * Fired when a Participant has started typing.\n * @event Conversation#typingStarted\n * @type {Participant}\n */\n/**\n * Fired when a Conversation's attributes or metadata have been updated.\n * @event Conversation#updated\n * @type {Object}\n * @property {Conversation} conversation - Updated Conversation\n * @property {Conversation#UpdateReason[]} updateReasons - Array of Conversation's updated event reasons\n */\n/**\n * Fired when the Conversation was destroyed or currently logged in User has left private Conversation\n * @event Conversation#removed\n * @type {Conversation}\n */\n","import { EventEmitter } from 'events';\nimport { Logger } from '../logger';\nimport { Conversation } from '../conversation';\n\nimport { SyncMap, SyncClient } from 'twilio-sync';\nimport { Session } from '../session';\nimport { SyncList } from '../synclist';\nimport { Users } from './users';\nimport { Network } from '../services/network';\nimport { TypingIndicator } from '../services/typingindicator';\nimport { ReadHorizon } from '../services/readhorizon';\nimport { McsClient } from 'twilio-mcs-client';\nimport { Deferred } from '../util/deferred';\nimport { Participant } from '../participant';\nimport { Message } from '../message';\nimport { isDeepEqual, parseAttributes, parseTime, UriBuilder } from '../util';\n\nconst log = Logger.scope('Conversations');\n\nexport interface ConversationsServices {\n  session: Session;\n  syncClient: SyncClient;\n  syncList: SyncList;\n  users: Users;\n  typingIndicator: TypingIndicator;\n  readHorizon: ReadHorizon;\n  network: Network;\n  mcsClient: McsClient;\n}\n\n/**\n * Represents conversations collection\n * {@see Conversation}\n */\nclass Conversations extends EventEmitter {\n\n  private services: ConversationsServices;\n  public readonly conversations: Map<string, Conversation>;\n  private readonly thumbstones: Set<string>; // sids\n  private syncListFetched: boolean;\n  public readonly syncListRead: Deferred<boolean>;\n\n  constructor(services: ConversationsServices) {\n    super();\n    this.services = services;\n    this.conversations = new Map<string, Conversation>();\n    this.thumbstones = new Set<string>();\n    this.syncListFetched = false;\n    this.syncListRead = new Deferred<boolean>();\n  }\n\n  private getMap(): Promise<SyncMap> {\n    return this.services.session.getMyConversationsId()\n               .then(name => this.services.syncClient.map({ id: name, mode: 'open_existing' }));\n  }\n\n  /**\n   * Add conversation to server\n   * @private\n   * @returns {Promise<Conversation>} Conversation\n   */\n  async addConversation(options): Promise<Conversation> {\n    let attributes;\n    if (typeof options.attributes === 'undefined') {\n      attributes = {};\n    } else {\n      attributes = options.attributes;\n    }\n\n    let response = await this.services.session.addCommand('createConversation', {\n      friendlyName: options.friendlyName,\n      uniqueName: options.uniqueName,\n      attributes: JSON.stringify(attributes)\n    }) as Object;\n\n    let conversationSid = 'conversationSid' in response ? response['conversationSid'] : null;\n    let conversationDocument = 'conversation' in response ? response['conversation'] : null;\n\n    let existingConversation = this.conversations.get(conversationSid);\n    if (existingConversation) {\n      await existingConversation._subscribe();\n      return existingConversation;\n    }\n\n    let conversation = new Conversation(this.services,\n      {\n        channel: conversationDocument,\n\n        entityName: null,\n        uniqueName: null,\n        attributes: null,\n        createdBy: null,\n        friendlyName: null,\n        lastConsumedMessageIndex: null,\n        dateCreated: null,\n        dateUpdated: null\n      },\n      conversationSid);\n\n    this.conversations.set(conversation.sid, conversation);\n    this.registerForEvents(conversation);\n\n    await conversation._subscribe();\n    this.emit('conversationAdded', conversation);\n    return conversation;\n  }\n\n  /**\n   * Fetch conversations list and instantiate all necessary objects\n   */\n  fetchConversations() {\n    this.getMap()\n        .then(async map => {\n          map.on('itemAdded', args => {\n            log.debug('itemAdded: ' + args.item.key);\n            this.upsertConversation('sync', args.item.key, args.item.data);\n          });\n\n          map.on('itemRemoved', args => {\n            log.debug('itemRemoved: ' + args.key);\n            let sid = args.key;\n            if (!this.syncListFetched) {\n              this.thumbstones.add(sid);\n            }\n            let conversation = this.conversations.get(sid);\n            if (conversation) {\n              if (conversation && conversation.status === 'joined' /*|| conversation.status === 'invited'*/) {\n                conversation._setStatus('notParticipating', 'sync');\n                this.emit('conversationLeft', conversation);\n              }\n\n              this.conversations.delete(sid);\n              this.emit('conversationRemoved', conversation);\n              conversation.emit('removed', conversation);\n            }\n          });\n\n          map.on('itemUpdated', args => {\n            log.debug('itemUpdated: ' + args.item.key);\n            this.upsertConversation('sync', args.item.key, args.item.data);\n          });\n\n          let upserts = [];\n\n          let paginator = await this.services.syncList.getPage();\n          let items = paginator.items;\n          items.forEach(item => {\n            upserts.push(this.upsertConversation('synclist', item.channel_sid, item));\n          });\n\n          while (paginator.hasNextPage) {\n            paginator = await paginator.nextPage();\n            paginator.items.forEach(item => {\n              upserts.push(this.upsertConversation('synclist', item.channel_sid, item));\n            });\n          }\n\n          this.syncListRead.set(true);\n\n          return Promise.all(upserts);\n        })\n        .then(() => {\n          this.syncListFetched = true;\n          this.thumbstones.clear();\n          log.debug('Conversations list fetched');\n        })\n        .then(() => this)\n        .catch(e => {\n          if (this.services.syncClient.connectionState != 'disconnected') {\n            log.error('Failed to get conversations list', e);\n          }\n          log.debug('ERROR: Failed to get conversations list', e);\n          throw e;\n        });\n  }\n\n  private _wrapPaginator(page, op) {\n    return op(page.items)\n      .then(items => ({\n        items: items,\n        hasNextPage: page.hasNextPage,\n        hasPrevPage: page.hasPrevPage,\n        nextPage: () => page.nextPage().then(x => this._wrapPaginator(x, op)),\n        prevPage: () => page.prevPage().then(x => this._wrapPaginator(x, op))\n      }));\n  }\n\n  getConversations(args) {\n    return this.getMap()\n               .then(conversationsMap => conversationsMap.getItems(args))\n               .then(page => this._wrapPaginator(page\n                 , items => Promise.all(items.map(item => this.upsertConversation('sync', item.key, item.data))))\n               );\n  }\n\n  getConversation(sid: string): Promise<Conversation> {\n    return this.getMap()\n      .then(conversationsMap => conversationsMap.getItems({ key: sid }))\n      .then(page => page.items.map(item => this.upsertConversation('sync', item.key, item.data)))\n      .then(items => items.length > 0 ? items[0] : null);\n  }\n\n  async getConversationByUniqueName(uniqueName: string): Promise<Conversation> {\n    const links = await this.services.session.getSessionLinks();\n    const url = new UriBuilder(links.myChannelsUrl).path(uniqueName).build();\n    const response = await this.services.network.get(url);\n    const body = response.body;\n\n    const sid = body.channel_sid;\n    const data = {\n      entityName: null,\n      lastConsumedMessageIndex: body.last_consumed_message_index,\n      status: body?.status || 'unknown',\n      friendlyName: body.friendly_name,\n      dateUpdated: body.date_updated,\n      dateCreated: body.date_created,\n      uniqueName: body.unique_name,\n      createdBy: body.created_by,\n      attributes: body.attributes,\n      channel: `${sid}.channel`,\n      notificationLevel: body?.notification_level,\n      sid\n    };\n\n    return this.upsertConversation('sync', sid, data);\n  }\n\n  async getWhisperConversation(sid: string): Promise<Conversation> {\n    const links = await this.services.session.getSessionLinks();\n    const url = new UriBuilder(links.publicChannelsUrl).path(sid).build();\n    const response = await this.services.network.get(url);\n    const body = response.body;\n\n    if (body.type !== 'private') {\n      return;\n    }\n\n    // todo: refactor this after the back-end change.\n\n    // Currently, a conversation that is created using a non-conversations-specific\n    // endpoint (i.e., a chat-specific endpoint) will not have a state property set.\n    // The back-end team will fix this, but only when they get some more time to work\n    // on this. For now, the SDK will assume that the default state is active when\n    // the property is absent from the REST response. The back-end team also mentioned\n    // that the state property will become a proper JSON object, as opposed to a JSON\n    // string, which is also covered in the following code.\n\n    let state: {\n      'state.v1'?: {\n        current?: 'active' | 'inactive' | 'closed';\n      }\n    } | undefined;\n\n    // If the state property is a string, it's expected to be a string that represents\n    // a JSON object.\n\n    if (typeof body.state === 'string') {\n      state = JSON.parse(body.state);\n    }\n\n    // If the state property is already a non-nullable object, then no JSON parsing is\n    // required.\n\n    if (typeof body.state === 'object' && body.state !== null) {\n      state = body.state;\n    }\n\n    if (state?.['state.v1']?.current === 'closed') {\n      return;\n    }\n\n    const data = {\n      entityName: null,\n      lastConsumedMessageIndex: body.last_consumed_message_index,\n      status: body?.status || 'unknown',\n      friendlyName: body.friendly_name,\n      dateUpdated: body.date_updated,\n      dateCreated: body.date_created,\n      uniqueName: body.unique_name,\n      createdBy: body.created_by,\n      attributes: body.attributes,\n      channel: `${sid}.channel`,\n      notificationLevel: body?.notification_level,\n      sid\n    };\n\n    return this.upsertConversation('sync', sid, data);\n  }\n\n  private upsertConversation(source: Conversations.DataSource, sid: string, data): Promise<Conversation> {\n    log.trace('upsertConversation(sid=' + sid + ', data=', data);\n    let conversation = this.conversations.get(sid);\n\n    // Update the Conversation's status if we know about it\n    if (conversation) {\n      log.trace('upsertConversation: conversation ' + sid + ' is known and it\\'s' +\n        ' status is known from source ' + conversation._statusSource() +\n        ' and update came from source ' + source, conversation);\n      if (typeof conversation._statusSource() === 'undefined'\n        || source === conversation._statusSource()\n        || (source === 'synclist' && conversation._statusSource() !== 'sync')\n        || source === 'sync') {\n        if (data.status === 'joined' && conversation.status !== 'joined') {\n          conversation._setStatus('joined', source);\n\n          let updateData: any = {};\n\n          if (typeof data.notificationLevel !== 'undefined') {\n            updateData.notificationLevel = data.notificationLevel;\n          }\n\n          if (typeof data.lastConsumedMessageIndex !== 'undefined') {\n            updateData.lastConsumedMessageIndex = data.lastConsumedMessageIndex;\n          }\n\n          if (!isDeepEqual(updateData, {})) {\n            conversation._update(updateData);\n          }\n\n          conversation._subscribe().then(() => { this.emit('conversationJoined', conversation); });\n        } else if (data.status === 'notParticipating' && conversation.status === 'joined') {\n          conversation._setStatus('notParticipating', source);\n          conversation._update(data);\n          conversation._subscribe().then(() => { this.emit('conversationLeft', conversation); });\n        } else if (data.status === 'notParticipating') {\n          conversation._subscribe();\n        } else {\n          conversation._update(data);\n        }\n      } else {\n        log.trace('upsertConversation: conversation is known from sync and came from chat, ignoring', {\n          sid: sid,\n          data: data.status,\n          conversation: conversation.status\n        });\n\n      }\n      return conversation._subscribe().then(() => conversation);\n    }\n\n    if ((source === 'chat' || source === 'synclist') && this.thumbstones.has(sid)) {\n      // if conversation was deleted, we ignore it\n      log.trace('upsertConversation: conversation is deleted and came again from chat, ignoring', sid);\n      return;\n    }\n\n    // Fetch the Conversation if we don't know about it\n    log.trace('upsertConversation: creating local conversation object with sid ' + sid, data);\n    conversation = new Conversation(this.services, data, sid);\n    this.conversations.set(sid, conversation);\n    return conversation._subscribe().then(() => {\n      this.registerForEvents(conversation);\n      this.emit('conversationAdded', conversation);\n      if (data.status === 'joined') {\n        conversation._setStatus('joined', source);\n        this.emit('conversationJoined', conversation);\n      }\n      return conversation;\n    });\n  }\n\n  private onConversationRemoved(sid: string) {\n    let conversation = this.conversations.get(sid);\n    if (conversation) {\n      this.conversations.delete(sid);\n      this.emit('conversationRemoved', conversation);\n    }\n  }\n\n  private registerForEvents(conversation) {\n    conversation.on('removed', () => this.onConversationRemoved(conversation.sid));\n    conversation.on('updated', (args: Conversation.UpdatedEventArgs) => this.emit('conversationUpdated', args));\n    conversation.on('participantJoined', this.emit.bind(this, 'participantJoined'));\n    conversation.on('participantLeft', this.emit.bind(this, 'participantLeft'));\n    conversation.on('participantUpdated', (args: Participant.UpdatedEventArgs) => this.emit('participantUpdated', args));\n    conversation.on('messageAdded', this.emit.bind(this, 'messageAdded'));\n    conversation.on('messageUpdated', (args: Message.UpdatedEventArgs) => this.emit('messageUpdated', args));\n    conversation.on('messageRemoved', this.emit.bind(this, 'messageRemoved'));\n    conversation.on('typingStarted', this.emit.bind(this, 'typingStarted'));\n    conversation.on('typingEnded', this.emit.bind(this, 'typingEnded'));\n  }\n}\n\nnamespace Conversations {\n  export type DataSource = 'sync' | 'chat' | 'synclist';\n}\n\nexport { Conversation, Conversations };\n","import { EventEmitter } from 'events';\n\nimport { Logger } from './logger';\nimport { Session } from './session';\nimport { SyncClient } from 'twilio-sync';\nimport { isDeepEqual, parseAttributes } from './util';\nimport { validateTypesAsync, literal } from 'twilio-sdk-type-validator';\n\nconst log = Logger.scope('User');\n\ninterface UserState {\n  identity: string;\n  entityName: string;\n  friendlyName: string;\n  attributes: any;\n  online: boolean;\n  notifiable: boolean;\n}\n\nexport interface UserServices {\n  session: Session;\n  syncClient: SyncClient;\n}\n\nnamespace User {\n  export type SubscriptionState = 'initializing' | 'subscribed' | 'unsubscribed';\n\n  export type UpdateReason = 'friendlyName' | 'attributes' | 'reachabilityOnline' | 'reachabilityNotifiable';\n\n  export interface UpdatedEventArgs {\n    user: User;\n    updateReasons: User.UpdateReason[];\n  }\n}\n\n/**\n * @classdesc Extended user information.\n * Note that <code>isOnline</code> and <code>isNotifiable</code> properties are eligible\n * to use only if reachability function is enabled.\n * You may check if it is enabled by reading value of {@link Client}'s <code>reachabilityEnabled</code> property.\n *\n * @property {String} identity - User identity\n * @property {String} friendlyName - User friendly name, null if not set\n * @property {any} attributes - Object with custom attributes for user\n * @property {Boolean} isOnline - User real-time conversation connection status\n * @property {Boolean} isNotifiable - User push notification registration status\n * @property {Boolean} isSubscribed - Check if this user receives real-time status updates\n *\n * @fires User#updated\n * @fires User#userSubscribed\n * @fires User#userUnsubscribed\n *\n * @constructor\n * @param {String} identity - Identity of user\n * @param {String} entityId - id of user's object\n * @param {Object} datasync - datasync service\n * @param {Object} session - session service\n */\nclass User extends EventEmitter {\n\n  private entity: any;\n  private services: UserServices;\n  private state: UserState;\n  private promiseToFetch: Promise<User>;\n  private subscribed: User.SubscriptionState;\n\n  /**\n   * The update reason for <code>updated</code> event emitted on User\n   * @typedef {('friendlyName' | 'attributes' | 'reachabilityOnline' | 'reachabilityNotifiable')} User#UpdateReason\n   */\n\n  constructor(identity: string, entityName: string, services: UserServices) {\n    super();\n\n    this.subscribed = 'initializing';\n    this.setMaxListeners(0);\n\n    this.services = services;\n\n    this.state = {\n      identity: identity,\n      entityName: entityName,\n      friendlyName: null,\n      attributes: {},\n      online: null,\n      notifiable: null\n    };\n  }\n\n  public get identity(): string { return this.state.identity; }\n\n  public set identity(identity: string) { this.state.identity = identity; }\n\n  public set entityName(name: string) { this.state.entityName = name; }\n\n  public get attributes() { return this.state.attributes; }\n\n  public get friendlyName(): string { return this.state.friendlyName; }\n\n  public get isOnline(): boolean { return this.state.online; }\n\n  public get isNotifiable(): boolean { return this.state.notifiable; }\n\n  public get isSubscribed(): boolean { return this.subscribed == 'subscribed'; }\n\n  // Handles service updates\n  _update(key: string, value: any) {\n    let updateReasons: User.UpdateReason[] = [];\n    log.debug('User for', this.state.identity, 'updated:', key, value);\n    switch (key) {\n      case 'friendlyName':\n        if (this.state.friendlyName !== value.value) {\n          updateReasons.push('friendlyName');\n          this.state.friendlyName = value.value;\n        }\n        break;\n      case 'attributes':\n        const updateAttributes = parseAttributes(value.value, `Retrieved malformed attributes from the server for user: ${this.state.identity}`, log);\n        if (!isDeepEqual(this.state.attributes, updateAttributes)) {\n          this.state.attributes = updateAttributes;\n          updateReasons.push('attributes');\n        }\n        break;\n      case 'reachability':\n        if (this.state.online !== value.online) {\n          this.state.online = value.online;\n          updateReasons.push('reachabilityOnline');\n        }\n        if (this.state.notifiable !== value.notifiable) {\n          this.state.notifiable = value.notifiable;\n          updateReasons.push('reachabilityNotifiable');\n        }\n        break;\n      default:\n        return;\n    }\n    if (updateReasons.length > 0) {\n      this.emit('updated', { user: this, updateReasons: updateReasons });\n    }\n  }\n\n  // Fetch reachability info\n  _updateReachabilityInfo(map, update) {\n    if (!this.services.session.reachabilityEnabled) {\n      return Promise.resolve();\n    }\n\n    return map.get('reachability')\n              .then(update)\n              .catch(err => { log.warn('Failed to get reachability info for ', this.state.identity, err); });\n  }\n\n  // Fetch user\n  async _fetch() {\n    if (!this.state.entityName) {\n      return this;\n    }\n\n    this.promiseToFetch = this.services.syncClient.map({ id: this.state.entityName, mode: 'open_existing', includeItems: true })\n                              .then(map => {\n                                this.entity = map;\n                                map.on('itemUpdated', args => {\n                                  log.debug(this.state.entityName + ' (' + this.state.identity + ') itemUpdated: ' + args.item.key);\n                                  return this._update(args.item.key, args.item.data);\n                                });\n                                return Promise.all([\n                                  map.get('friendlyName')\n                                     .then(item => this._update(item.key, item.data)),\n                                  map.get('attributes')\n                                     .then(item => this._update(item.key, item.data)),\n                                  this._updateReachabilityInfo(map,\n                                    item => this._update(item.key, item.data))\n                                ]);\n                              })\n                              .then(() => {\n                                log.debug('Fetched for', this.identity);\n                                this.subscribed = 'subscribed';\n                                this.emit('userSubscribed', this);\n                                return this;\n                              })\n                              .catch(err => {\n                                this.promiseToFetch = null;\n                                throw err;\n                              });\n    return this.promiseToFetch;\n  }\n\n  _ensureFetched() {\n    return this.promiseToFetch || this._fetch();\n  }\n\n  /**\n   * Updates user attributes.\n   * @param {any} attributes new attributes for User.\n   * @returns {Promise<User>}\n   */\n  @validateTypesAsync(['string', 'number', 'boolean', 'object', literal(null)])\n  public async updateAttributes(attributes: any): Promise<User> {\n    if (this.subscribed == 'unsubscribed') {\n      throw new Error('Can\\'t modify unsubscribed object');\n    }\n\n    await this.services.session.addCommand('editUserAttributes', {\n      username: this.state.identity,\n      attributes: JSON.stringify(attributes)\n    });\n\n    return this;\n  }\n\n  /**\n   * Update Users friendlyName.\n   * @param {String|null} friendlyName - Updated friendlyName\n   * @returns {Promise<User>}\n   */\n  @validateTypesAsync(['string', literal(null)])\n  public async updateFriendlyName(friendlyName: string | null): Promise<User> {\n    if (this.subscribed == 'unsubscribed') {\n      throw new Error('Can\\'t modify unsubscribed object');\n    }\n\n    await this.services.session.addCommand('editUserFriendlyName', {\n      username: this.state.identity,\n      friendlyName: friendlyName\n    });\n\n    return this;\n  }\n\n  /**\n   * Removes User from subscription list.\n   * @returns {Promise<void>} Promise of completion\n   */\n  async unsubscribe(): Promise<void> {\n    if (this.promiseToFetch) {\n      await this.promiseToFetch;\n      this.entity.close();\n      this.promiseToFetch = null;\n      this.subscribed = 'unsubscribed';\n      this.emit('userUnsubscribed', this);\n    }\n  }\n}\n\nexport { User };\n\n/**\n * Fired when User's properties or reachability status have been updated.\n * @event User#updated\n * @type {Object}\n * @property {User} user - Updated User\n * @property {User#UpdateReason[]} updateReasons - Array of User's updated event reasons\n */\n/**\n * Fired when Client is subscribed to User.\n * @event User#userSubscribed\n * @type {User}\n */\n/**\n * Fired when Client is unsubscribed from this User.\n * @event User#userUnsubscribed\n * @type {User}\n */\n","import { EventEmitter } from 'events';\nimport { User } from '../user';\nimport { Network } from '../services/network';\nimport { Session } from '../session';\nimport { SyncClient } from 'twilio-sync';\nimport { UriBuilder } from '../util';\n\nexport interface UsersServices {\n  session: Session;\n  network: Network;\n  syncClient: SyncClient;\n}\n\n/**\n * @classdesc Container for known users\n * @fires Users#userUpdated\n */\nclass Users extends EventEmitter {\n\n  private services: UsersServices;\n  private subscribedUsers: Map<string, User>;\n  private fifoStack: any;\n  private fifoStackMaxLength: number;\n  private userUrlPromise: Promise<string>;\n  private userUrl: string;\n  public readonly myself: User;\n\n  constructor(services: UsersServices) {\n    super();\n    this.services = services;\n    this.fifoStack = [];\n    this.fifoStackMaxLength = 100;\n    this.myself = new User(null, null, this.services);\n    this.myself.on('updated', (args: User.UpdatedEventArgs) => this.emit('userUpdated', args));\n    this.myself.on('userSubscribed', () => this.emit('userSubscribed', this.myself));\n    this.myself.on('userUnsubscribed', () => {\n      this.emit('userUnsubscribed', this.myself);\n      this.myself._ensureFetched();\n    });\n    this.services = services;\n    this.subscribedUsers = new Map<string, User>();\n\n    this.userUrlPromise =\n      this.services.session.getSessionLinks()\n        .then((links) => {\n          this.userUrl = links.usersUrl;\n          return this.userUrl;\n        });\n\n    this.services.session.getMaxUserInfosToSubscribe()\n      .then(maxUserInfosToSubscribe => {\n          this.fifoStackMaxLength = maxUserInfosToSubscribe;\n        }\n      );\n\n    this.services.session.getUsersData()\n      .then(data => {\n        this.myself.identity = data.identity;\n        this.myself.entityName = data.user;\n        return this.myself._ensureFetched();\n      });\n  }\n\n  private handleUnsubscribeUser(user: User): void {\n    if (this.subscribedUsers.has(user.identity)) {\n      this.subscribedUsers.delete(user.identity);\n    }\n    let foundItemIndex = -1;\n    let foundItem = this.fifoStack.find((item, index) => {\n      if (item == user.identity) {\n        foundItemIndex = index;\n        return true;\n      }\n      return false;\n    });\n    if (foundItem) {\n      this.fifoStack.splice(foundItemIndex, 1);\n    }\n    this.emit('userUnsubscribed', user);\n  }\n\n  private handleSubscribeUser(user: User): void {\n    if (this.subscribedUsers.has(user.identity)) {\n      return;\n    }\n    if (this.fifoStack.length >= this.fifoStackMaxLength) {\n      this.subscribedUsers.get(this.fifoStack.shift()).unsubscribe();\n    }\n    this.fifoStack.push(user.identity);\n    this.subscribedUsers.set(user.identity, user);\n    this.emit('userSubscribed', user);\n  }\n\n  /**\n   * Gets user, if it's in subscribed list - then return the user object from it,\n   * if not - then subscribes and adds user to the FIFO stack\n   * @returns {Promise<User>} Fully initialized user\n   */\n  async getUser(identity: string, entityName: string = null): Promise<User> {\n    await this.services.session.getUsersData();\n    await this.myself._ensureFetched();\n\n    if (identity == this.myself.identity) {\n      return this.myself;\n    }\n\n    let user = this.subscribedUsers.get(identity);\n    if (!user) {\n      if (!entityName) {\n        entityName = await this.getSyncUniqueName(identity);\n      }\n      user = new User(identity, entityName, this.services);\n      user.on('updated', (args: User.UpdatedEventArgs) => this.emit('userUpdated', args));\n      user.on('userSubscribed', () => this.handleSubscribeUser(user));\n      user.on('userUnsubscribed', () => this.handleUnsubscribeUser(user));\n      await user._ensureFetched();\n    }\n\n    return user;\n  }\n\n  /**\n   * @returns {Promise<Array<User>>} returns list of subscribed User objects {@see User}\n   */\n  async getSubscribedUsers(): Promise<Array<User>> {\n    await this.services.session.getUsersData();\n    await this.myself._ensureFetched();\n    let users = [this.myself];\n    this.subscribedUsers.forEach((user) => users.push(user));\n    return users;\n  }\n\n  /**\n   * @returns {Promise<string>} User's sync unique name\n   */\n  private async getSyncUniqueName(identity: string): Promise<string> {\n    const url = new UriBuilder(this.userUrl).path(identity).build();\n    let response = await this.services.network.get(url);\n    return response.body.sync_unique_name;\n  }\n}\n\nexport { Users };\n","import { Logger } from '../logger';\n\nimport { Notifications } from 'twilio-notifications';\n\nimport { NotificationTypes } from '../interfaces/notificationtypes';\nimport { Transport } from '../interfaces/transport';\nimport { Configuration } from '../configuration';\n\nconst log = Logger.scope('TypingIndicator');\n\nexport interface TypingIndicatorServices {\n  transport: Transport;\n  notificationClient: Notifications;\n}\n\n/**\n * An important note in regards to typing timeout timers. There are two places that the SDK can get the \"typing_timeout\" attribute from. The first\n * place that the attribute appears in is the response received from POST -> /v1/typing REST call. In the body of that response, the value of the\n * \"typing_timeout\" attribute will be exactly the same as defined in the console. The second place that the attribute appears in is from a\n * notification of type \"twilio.ipmsg.typing_indicator\". In this case, the \"typing_timeout\" value will be +1 of that in the console. This\n * intentional. The timeout returned from the POST -> /v1/typing call should be used to disable further calls for that period of time. On contrary,\n * the timeout returned from the notification should be used as the timeout for the \"typingEnded\" event, +1 is to account for latency.\n *\n * @private\n */\n\n/**\n * @class TypingIndicator\n *\n * @constructor\n * @private\n */\nclass TypingIndicator {\n  private readonly services;\n  private readonly config;\n\n  private sentUpdates: Map<string, number>;\n  private getConversation;\n  private serviceTypingTimeout;\n\n  constructor(config: Configuration, services: TypingIndicatorServices, getConversation) {\n    this.config = config;\n    this.services = services;\n    this.getConversation = getConversation;\n\n    this.serviceTypingTimeout = null;\n    this.sentUpdates = new Map();\n  }\n\n  public get typingTimeout(): number {\n    return this.config.typingIndicatorTimeoutOverride\n      || this.serviceTypingTimeout\n      || this.config.typingIndicatorTimeoutDefault;\n  }\n\n  /**\n   * Initialize TypingIndicator controller\n   * Registers for needed message types and sets listeners\n   * @private\n   */\n  initialize() {\n    this.services.notificationClient.subscribe(NotificationTypes.TYPING_INDICATOR, 'twilsock');\n    this.services.notificationClient.on('message', (type, message) => {\n      if (type === NotificationTypes.TYPING_INDICATOR) {\n        this.handleRemoteTyping(message);\n      }\n    });\n  }\n\n  /**\n   * Remote participants typing events handler\n   * @private\n   */\n  handleRemoteTyping(message) {\n    log.trace('Got new typing indicator ', message);\n\n    this.getConversation(message.channel_sid)\n      .then(conversation => {\n        if (!conversation) {\n          return;\n        }\n\n        conversation.participants.forEach(participant => {\n          if (participant.identity !== message.identity) {\n            return;\n          }\n\n          const timeout = this.config.typingIndicatorTimeoutOverride + 1000 || message.typing_timeout * 1000;\n          participant._startTyping(timeout);\n        });\n      })\n      .catch(err => {\n        log.error(err);\n        throw err;\n      });\n  }\n\n  /**\n   * Send typing event for the given conversation sid\n   * @param {String} conversationSid\n   */\n  send(conversationSid: string) {\n    const lastUpdate = this.sentUpdates.get(conversationSid);\n    if (lastUpdate && lastUpdate > (Date.now() - this.typingTimeout)) {\n      return Promise.resolve();\n    }\n\n    this.sentUpdates.set(conversationSid, Date.now());\n    return this._send(conversationSid);\n  }\n\n  private _send(conversationSid: string) {\n    log.trace('Sending typing indicator');\n\n    const url = this.config.typingIndicatorUri;\n    const headers = {\n      'Content-Type': 'application/x-www-form-urlencoded'\n    };\n    const body = 'ChannelSid=' + conversationSid;\n\n    return this.services.transport.post(url, headers, body, this.config.productId)\n      .then(response => {\n        if (response.body.hasOwnProperty('typing_timeout')) {\n          this.serviceTypingTimeout = response.body.typing_timeout * 1000;\n        }\n      }).catch(err => {\n        log.error('Failed to send typing indicator:', err);\n        throw err;\n      });\n  }\n}\n\nexport { TypingIndicator };\n","import { Session } from '../session';\nimport { SessionError } from '../sessionerror';\n\nexport interface ReadHorizonServices {\n  session: Session;\n}\n\nclass ConsumptionReportRequest {\n  entry: ConsumptionReportEntry;\n  promises: ReadHorizonPromise[];\n}\n\nclass ConsumptionReportEntry {\n  channelSid: string;\n  messageIdx: number;\n}\n\nclass ReadHorizonPromise {\n  resolve: any;\n  reject: any;\n}\n\ninterface ConsumptionReportResponseEntry {\n  channelSid: string;\n  unreadMessagesCount?: number;\n}\n\n/**\n * @classdesc Provides read horizon management functionality\n */\nclass ReadHorizon {\n  private readonly services: ReadHorizonServices;\n  private readonly readHorizonRequests: Map<string, ConsumptionReportRequest>;\n  private readHorizonUpdateTimer: any;\n\n  constructor(services: ReadHorizonServices) {\n    this.services = services;\n    this.readHorizonRequests = new Map();\n    this.readHorizonUpdateTimer = null;\n  }\n\n  private getReportInterval(): Promise<number> {\n    return this.services.session.getConsumptionReportInterval().then(\n      seconds => seconds * 1000);\n  }\n\n  private delayedSendReadHorizon(delay) {\n    if (this.readHorizonUpdateTimer !== null) {\n      return;\n    }\n\n    this.sendConsumptionReport(true);\n\n    this.readHorizonUpdateTimer = setTimeout(() => {\n      this.sendConsumptionReport(false);\n    }, delay);\n\n  }\n\n  private sendConsumptionReport(keepTimer: boolean) {\n    let reports = [];\n    let promises = new Map<string, ReadHorizonPromise[]>();\n    this.readHorizonRequests.forEach((request, conversationSid) => {\n      reports.push(request.entry);\n      promises.set(conversationSid, request.promises);\n    });\n    if (reports.length > 0) {\n      this.services.session.addCommand('consumptionReportV2', { report: reports })\n          .then(response => this.processConsumptionReportResponse(response, promises))\n          .catch(err => this.processConsumptionReportError(err, promises));\n    }\n    if (!keepTimer) {\n      this.readHorizonUpdateTimer = null;\n    }\n    this.readHorizonRequests.clear();\n\n  }\n\n  private processConsumptionReportResponse(response: any, promises: Map<string, ReadHorizonPromise[]>) {\n    if (response && response.report && Array.isArray(response.report) && response.report.length > 0) {\n      response.report.forEach(entry => {\n        let responseEntry = entry as ConsumptionReportResponseEntry;\n        if (promises.has(responseEntry.channelSid)) {\n          let unreadMessagesCount = null;\n          if ((typeof responseEntry.unreadMessagesCount !== 'undefined') && responseEntry.unreadMessagesCount != null) {\n            unreadMessagesCount = responseEntry.unreadMessagesCount;\n          }\n          promises.get(responseEntry.channelSid).forEach(promise => promise.resolve(unreadMessagesCount));\n          promises.delete(responseEntry.channelSid);\n        }\n      });\n    }\n\n    this.processConsumptionReportError(new SessionError('Error while setting LastReadMessageIndex', null), promises);\n  }\n\n  private processConsumptionReportError(err: SessionError, promises: Map<string, ReadHorizonPromise[]>) {\n    promises.forEach(conversationPromises => conversationPromises.forEach(promise => promise.reject(err)));\n  }\n\n  /**\n   * Updates read horizon value without any checks\n   */\n  updateLastReadMessageIndexForConversation(conversationSid: string, messageIdx: number): Promise<number> {\n    return new Promise<number>((resolve, reject) => {\n      this.addPendingConsumptionHorizonRequest(conversationSid, { channelSid: conversationSid, messageIdx }, { resolve, reject });\n      this.getReportInterval().then(delay => this.delayedSendReadHorizon(delay));\n    });\n  }\n\n  /**\n   * Move read horizon forward\n   */\n  advanceLastReadMessageIndexForConversation(\n    conversationSid: string,\n    messageIdx: number,\n    currentConversationLastReadIndex: number\n  ): Promise<number> {\n    let currentHorizon = this.readHorizonRequests.get(conversationSid);\n    return new Promise<number>((resolve, reject) => {\n      if (currentHorizon && currentHorizon.entry) {\n        if (currentHorizon.entry.messageIdx >= messageIdx) {\n          this.addPendingConsumptionHorizonRequest(conversationSid, currentHorizon.entry, { resolve, reject });\n        } else {\n          this.addPendingConsumptionHorizonRequest(conversationSid, { channelSid: conversationSid, messageIdx }, { resolve, reject });\n        }\n      } else {\n        if ((currentConversationLastReadIndex !== null) && messageIdx < currentConversationLastReadIndex) {\n          this.addPendingConsumptionHorizonRequest(\n            conversationSid,\n            { channelSid: conversationSid, messageIdx: currentConversationLastReadIndex },\n            { resolve, reject });\n        } else {\n          this.addPendingConsumptionHorizonRequest(conversationSid, { channelSid: conversationSid, messageIdx }, { resolve, reject });\n        }\n      }\n      this.getReportInterval().then(delay => this.delayedSendReadHorizon(delay));\n    });\n  }\n\n  private addPendingConsumptionHorizonRequest(conversationSid: string, entry: ConsumptionReportEntry, promise: ReadHorizonPromise) {\n    if (this.readHorizonRequests.has(conversationSid)) {\n      let request = this.readHorizonRequests.get(conversationSid);\n      request.entry = entry;\n      request.promises.push(promise);\n    } else {\n      this.readHorizonRequests.set(conversationSid, { entry, promises: [promise] });\n    }\n  }\n}\n\nexport { ReadHorizon };\n","'use strict';\n\nnamespace PushNotification {\n  export type Type = 'twilio.conversations.new_message' | 'twilio.conversations.added_to_conversation'\n    | 'twilio.conversations.removed_from_conversation';\n\n  export interface Descriptor {\n    title: string;\n    body: string;\n    sound: string;\n    badge: number;\n    action: string;\n    type: PushNotification.Type;\n    data: Object;\n  }\n}\n\n/**\n * @classdesc Push notification representation within Conversations Client\n * @property {String} [action] - Notification action (`click_action` in FCM/GCM terms and `category` in APN terms)\n * @property {Number} [badge] - Number for the badge\n * @property {String} body - Notification text\n * @property {PushNotification#ConversationData} data - Additional Conversation data\n * @property {String} [sound] - Notification sound\n * @property {String} [title] - Notification title\n * @property {PushNotification#NotificationType} type - Notification type\n */\nclass PushNotification {\n  public readonly title: string;\n  public readonly body: string;\n  public readonly sound: string;\n  public readonly badge: number;\n  public readonly action: string;\n  public readonly type: PushNotification.Type;\n  public readonly data: Object;\n\n  /**\n   * Conversation push notification type\n   * @typedef {('twilio.conversations.new_message' | 'twilio.conversations.added_to_conversation'\n   | 'twilio.conversations.removed_from_conversation')} PushNotification#NotificationType\n   */\n\n  /**\n   * Additional Conversations data for given Push Notification\n   * @typedef {Object} PushNotification#ConversationData\n   * @property {String} [conversationSid] - SID of Conversation\n   * @property {Number} [messageIndex] - Index of Message in Conversation\n   * @property {String} [messageSid] - SID of Message\n   */\n\n  /**\n   * @param {PushNotification.Descriptor} data - initial data for PushNotification\n   */\n  constructor(data: PushNotification.Descriptor) {\n    this.title = data.title || null;\n    this.body = data.body || null;\n    this.sound = data.sound || null;\n    this.badge = data.badge || null;\n    this.action = data.action || null;\n    this.type = data.type || null;\n    this.data = data.data || {};\n  }\n\n}\n\nexport { PushNotification };\n","import { EventEmitter } from 'events';\nimport { Logger } from './logger';\nimport { Configuration } from './configuration';\n\nimport { User } from './user';\nimport { Network } from './services/network';\n\nimport { Transport } from './interfaces/transport';\nimport { NotificationTypes } from './interfaces/notificationtypes';\n\nimport { SyncList } from './synclist';\nimport { Twilsock as TwilsockClient } from 'twilsock';\nimport { ChannelType, ConnectionState as NotificationConnectionState, Notifications as NotificationClient } from 'twilio-notifications';\nimport { SyncClient } from 'twilio-sync';\nimport { McsClient } from 'twilio-mcs-client';\n\nimport { Session } from './session';\nimport { Conversation, Conversations as ConversationsEntity } from './data/conversations';\n\nimport { Users } from './data/users';\nimport { TypingIndicator } from './services/typingindicator';\nimport { ReadHorizon } from './services/readhorizon';\nimport { Paginator } from './interfaces/paginator';\nimport { PushNotification } from './pushnotification';\nimport { deepClone, parseToNumber } from './util';\nimport { Participant } from './participant';\nimport { Message } from './message';\nimport { TelemetryEventDescription, TelemetryPoint } from 'twilsock/lib/services/telemetrytracker';\nimport { validateTypesAsync, validateTypes, custom, literal, nonEmptyString, pureObject, stringifyReceivedType, objectSchema } from 'twilio-sdk-type-validator';\nimport { version } from '../package.json';\n\nconst log = Logger.scope('Client');\n\nconst SDK_VERSION = version;\n\nclass ClientServices {\n  session: Session;\n  twilsockClient: TwilsockClient;\n  users: Users;\n  notificationClient: NotificationClient;\n  //publicChannels: PublicConversations;\n  //myConversations: UserConversations;\n  network: Network;\n  typingIndicator: TypingIndicator;\n  syncClient: SyncClient;\n  readHorizon: ReadHorizon;\n  syncList: SyncList;\n  mcsClient: McsClient;\n  transport: Transport;\n}\n\nnamespace Client {\n  export type ConnectionState = NotificationConnectionState;\n\n  export type NotificationsChannelType = ChannelType;\n\n  export type LogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'silent' | null;\n\n  export interface Options {\n    region?: string;\n    logLevel?: Client.LogLevel;\n    productId?: string;\n    twilsockClient?: TwilsockClient;\n    transport?: Transport;\n    notificationsClient?: NotificationClient;\n    syncClient?: SyncClient;\n    typingIndicatorTimeoutOverride?: number;\n    consumptionReportIntervalOverride?: string;\n    httpCacheIntervalOverride?: string;\n    userInfosToSubscribeOverride?: number;\n    retryWhenThrottledOverride?: boolean;\n    backoffConfigOverride?: any;\n    Chat?: any;\n    Sync?: any;\n    Notification?: any;\n    Twilsock?: any;\n    clientMetadata?: any;\n  }\n\n  export interface CreateConversationOptions {\n    attributes?: any;\n    friendlyName?: string;\n    uniqueName?: string;\n  }\n}\n\n/**\n * A Client is a starting point to access Twilio Conversations functionality.\n *\n * @property {Client#ConnectionState} connectionState - Client connection state\n * @property {Boolean} reachabilityEnabled - Client reachability state\n * @property {User} user - Information for logged in user\n * @property {String} version - Current version of Conversations client\n *\n * @fires Client#connectionError\n * @fires Client#connectionStateChanged\n * @fires Client#conversationAdded\n * @fires Client#conversationJoined\n * @fires Client#conversationLeft\n * @fires Client#conversationRemoved\n * @fires Client#conversationUpdated\n * @fires Client#participantJoined\n * @fires Client#participantLeft\n * @fires Client#participantUpdated\n * @fires Client#messageAdded\n * @fires Client#messageRemoved\n * @fires Client#messageUpdated\n * @fires Client#pushNotification\n * @fires Client#tokenAboutToExpire\n * @fires Client#tokenExpired\n * @fires Client#typingEnded\n * @fires Client#typingStarted\n * @fires Client#userSubscribed\n * @fires Client#userUnsubscribed\n * @fires Client#userUpdated\n */\nclass Client extends EventEmitter {\n  public connectionState: Client.ConnectionState = 'connecting';\n  private sessionPromise: Promise<any> = null;\n  private conversationsPromise: Promise<any> = null;\n  private fpaToken: string;\n  private config: Configuration;\n  private conversations: any;\n  private options: any;\n  private services: ClientServices;\n  public static readonly version: string = SDK_VERSION;\n  public readonly version: string = SDK_VERSION;\n  private static readonly supportedPushChannels: Client.NotificationsChannelType[] = ['fcm', 'apn'];\n  private static readonly supportedPushDataFields = {\n    'conversation_sid': 'conversationSid',\n    'message_sid': 'messageSid',\n    'message_index': 'messageIndex'\n  };\n\n  /**\n   * These options can be passed to Client constructor.\n   * @typedef {Object} Client#ClientOptions\n   * @property {String} [logLevel='error'] - The level of logging to enable. Valid options\n   *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']\n   */\n\n  /**\n   * These options can be passed to {@link Client#createConversation}.\n   * @typedef {Object} Client#CreateConversationOptions\n   * @property {any} [attributes] - Any custom attributes to attach to the Conversation\n   * @property {String} [friendlyName] - The non-unique display name of the Conversation\n   * @property {String} [uniqueName] - The unique identifier of the Conversation\n   */\n\n  /**\n   * Connection state of Client.\n   * @typedef {('connecting'|'connected'|'disconnecting'|'disconnected'|'denied')} Client#ConnectionState\n   */\n\n  /**\n   * Notifications channel type.\n   * @typedef {('fcm'|'apn')} Client#NotificationsChannelType\n   */\n\n  private constructor(token: string, options?: Client.Options) {\n    super();\n\n    this.options = (options || {}) as any;\n    if (!this.options.disableDeepClone) {\n      let options = {\n        ...this.options,\n        transport: undefined,\n        twilsockClient: undefined\n      };\n\n      options = deepClone(options);\n      options.transport = this.options.transport;\n      options.twilsockClient = this.options.twilsockClient;\n\n      this.options = options;\n    }\n    this.options.logLevel = this.options.logLevel || 'silent';\n    log.setLevel(this.options.logLevel);\n\n    const productId = this.options.productId = 'ip_messaging';\n\n    // Filling ClientMetadata\n    this.options.clientMetadata = this.options.clientMetadata || {};\n    if (!this.options.clientMetadata.hasOwnProperty('type')) {\n      this.options.clientMetadata.type = 'conversations';\n    }\n    if (!this.options.clientMetadata.hasOwnProperty('sdk')) {\n      this.options.clientMetadata.sdk = 'JS';\n      this.options.clientMetadata.sdkv = SDK_VERSION;\n    }\n\n    // Enable session local storage for Sync\n    this.options.Sync = this.options.Sync || {};\n    if (typeof this.options.Sync.enableSessionStorage === 'undefined') {\n      this.options.Sync.enableSessionStorage = true;\n    }\n    if (this.options.region) {\n      this.options.Sync.region = this.options.region;\n    }\n\n    if (!token) {\n      throw new Error('A valid Twilio token should be provided');\n    }\n\n    this.services = new ClientServices();\n    this.config = new Configuration(this.options);\n\n    this.options.twilsockClient = this.options.twilsockClient || new TwilsockClient(token, productId, this.options);\n    this.options.transport = this.options.transport || this.options.twilsockClient;\n    this.options.notificationsClient = this.options.notificationsClient || new NotificationClient(token, this.options);\n    this.options.syncClient = this.options.syncClient || new SyncClient(token, this.options);\n\n    this.services.syncClient = this.options.syncClient;\n    this.services.transport = this.options.transport;\n    this.services.twilsockClient = this.options.twilsockClient;\n    this.services.notificationClient = this.options.notificationsClient;\n    this.services.session = new Session(this.services, this.config);\n    this.sessionPromise = this.services.session.initialize();\n\n    this.services.network = new Network(this.config, this.services);\n\n    this.services.users = new Users({\n      session: this.services.session,\n      network: this.services.network,\n      syncClient: this.services.syncClient\n    });\n    this.services.users.on('userSubscribed', this.emit.bind(this, 'userSubscribed'));\n    this.services.users.on('userUpdated',\n      (args: User.UpdatedEventArgs) => this.emit('userUpdated', args));\n    this.services.users.on('userUnsubscribed', this.emit.bind(this, 'userUnsubscribed'));\n\n    this.services.twilsockClient.on('tokenAboutToExpire', ttl => this.emit('tokenAboutToExpire', ttl));\n    this.services.twilsockClient.on('tokenExpired', () => this.emit('tokenExpired'));\n    this.services.twilsockClient.on('connectionError', (error) => this.emit('connectionError', error));\n\n    this.services.readHorizon = new ReadHorizon(this.services);\n    this.services.typingIndicator = new TypingIndicator(this.config, {\n      transport: this.services.twilsockClient,\n      notificationClient: this.services.notificationClient\n    }, this.getConversationBySid.bind(this));\n\n    this.services.syncList = new SyncList(this.services);\n\n    this.conversations = new ConversationsEntity(this.services);\n\n    this.conversationsPromise = this.sessionPromise.then(() => {\n      this.conversations.on('conversationAdded', this.emit.bind(this, 'conversationAdded'));\n      this.conversations.on('conversationRemoved', this.emit.bind(this, 'conversationRemoved'));\n      this.conversations.on('conversationJoined', this.emit.bind(this, 'conversationJoined'));\n      this.conversations.on('conversationLeft', this.emit.bind(this, 'conversationLeft'));\n      this.conversations.on('conversationUpdated',\n        (args: Conversation.UpdatedEventArgs) => this.emit('conversationUpdated', args));\n\n      this.conversations.on('participantJoined', this.emit.bind(this, 'participantJoined'));\n      this.conversations.on('participantLeft', this.emit.bind(this, 'participantLeft'));\n      this.conversations.on('participantUpdated',\n        (args: Participant.UpdatedEventArgs) => this.emit('participantUpdated', args));\n\n      this.conversations.on('messageAdded', this.emit.bind(this, 'messageAdded'));\n      this.conversations.on('messageUpdated',\n        (args: Message.UpdatedEventArgs) => this.emit('messageUpdated', args));\n      this.conversations.on('messageRemoved', this.emit.bind(this, 'messageRemoved'));\n\n      this.conversations.on('typingStarted', this.emit.bind(this, 'typingStarted'));\n      this.conversations.on('typingEnded', this.emit.bind(this, 'typingEnded'));\n\n      return this.conversations.fetchConversations();\n    }).then(() => this.conversations);\n\n    this.services.notificationClient.on('connectionStateChanged', (state: Client.ConnectionState) => {\n      let changedConnectionState = null;\n      switch (state) {\n        case 'connected':\n          changedConnectionState = 'connected';\n          break;\n        case 'denied':\n          changedConnectionState = 'denied';\n          break;\n        case 'disconnecting':\n          changedConnectionState = 'disconnecting';\n          break;\n        case 'disconnected':\n          changedConnectionState = 'disconnected';\n          break;\n        default:\n          changedConnectionState = 'connecting';\n      }\n      if (changedConnectionState !== this.connectionState) {\n        this.connectionState = changedConnectionState;\n        this.emit('connectionStateChanged', this.connectionState);\n      }\n    });\n\n    this.fpaToken = token;\n  }\n\n  /**\n   * Factory method to create Conversations client instance.\n   *\n   * @param {String} token - Access token\n   * @param {Client#ClientOptions} [options] - Options to customize the Client\n   * @returns {Promise<Client>}\n   */\n  @validateTypesAsync('string', ['undefined', pureObject])\n  static async create(token: string, options?: Client.Options): Promise<Client> {\n    let client = new Client(token, options);\n\n    const startupEvent = 'conversations.client.startup';\n\n    client.services.twilsockClient.addPartialTelemetryEvent(new TelemetryEventDescription(\n      startupEvent,\n      'Conversations client startup',\n      new Date()\n    ), startupEvent, TelemetryPoint.Start);\n\n    await client.initialize();\n\n    client.services.twilsockClient.addPartialTelemetryEvent(\n      new TelemetryEventDescription('', '', new Date()),\n      startupEvent,\n      TelemetryPoint.End);\n\n    return client;\n  }\n\n  public get user(): User { return this.services.users.myself; }\n\n  public get reachabilityEnabled(): boolean { return this.services.session.reachabilityEnabled; }\n\n  public get token(): string { return this.fpaToken; }\n\n  private subscribeToPushNotifications(channelType: Client.NotificationsChannelType) {\n    let subscriptions: Promise<any>[] = [];\n    [NotificationTypes.NEW_MESSAGE,\n      NotificationTypes.ADDED_TO_CONVERSATION,\n      NotificationTypes.REMOVED_FROM_CONVERSATION,\n      NotificationTypes.TYPING_INDICATOR,\n      NotificationTypes.CONSUMPTION_UPDATE]\n      .forEach(messageType => {\n        subscriptions.push(this.services.notificationClient.subscribe(messageType, channelType));\n      });\n    return Promise.all(subscriptions);\n  }\n\n  private unsubscribeFromPushNotifications(channelType: Client.NotificationsChannelType) {\n    let subscriptions: Promise<any>[] = [];\n    [NotificationTypes.NEW_MESSAGE,\n      NotificationTypes.ADDED_TO_CONVERSATION,\n      NotificationTypes.REMOVED_FROM_CONVERSATION,\n      NotificationTypes.TYPING_INDICATOR,\n      NotificationTypes.CONSUMPTION_UPDATE]\n      .forEach(messageType => {\n        subscriptions.push(this.services.notificationClient.unsubscribe(messageType, channelType));\n      });\n    return Promise.all(subscriptions);\n  }\n\n  private async initialize() {\n    await this.sessionPromise;\n\n    Client.supportedPushChannels.forEach(channelType => this.subscribeToPushNotifications(channelType));\n\n    let links = await this.services.session.getSessionLinks();\n\n    let options = Object.assign(this.options);\n    options.transport = null;\n    this.services.mcsClient = new McsClient(this.fpaToken, links.mediaServiceUrl, options);\n\n    await this.services.typingIndicator.initialize();\n  }\n\n  /**\n   * Gracefully shutting down library instance.\n   * @public\n   * @returns {Promise<void>}\n   */\n  async shutdown(): Promise<void> {\n    await this.services.twilsockClient.disconnect();\n  }\n\n  /**\n   * Update the token used by the Client and re-register with Conversations services.\n   * @param {String} token - Access token\n   * @public\n   * @returns {Promise<Client>}\n   */\n  @validateTypesAsync(nonEmptyString)\n  async updateToken(token: string): Promise<Client> {\n    log.info('updateToken');\n\n    if (this.fpaToken === token) {\n      return this;\n    }\n\n    await this.services.twilsockClient.updateToken(token)\n      .then(() => this.fpaToken = token)\n      .then(() => this.services.mcsClient.updateToken(token))\n      .then(() => this.sessionPromise);\n\n    return this;\n  }\n\n  /**\n   * Get a known Conversation by its SID.\n   * @param {String} conversationSid - Conversation sid\n   * @returns {Promise<Conversation>}\n   */\n  @validateTypesAsync(nonEmptyString)\n  async getConversationBySid(conversationSid: string): Promise<Conversation> {\n    await this.conversations.syncListRead.promise;\n    let conversation = await this.conversations.getConversation(conversationSid);\n\n    if (!conversation) {\n      conversation = await this.conversations.getWhisperConversation(conversationSid);\n    }\n\n    if (!conversation) {\n      throw new Error(`Conversation with SID ${conversationSid} is not found.`);\n    }\n\n    return conversation;\n  }\n\n  /**\n   * Get a known Conversation by its unique identifier name.\n   * @param {String} uniqueName - The unique identifier name of the Conversation to get\n   * @returns {Promise<Conversation>}\n   */\n  @validateTypesAsync(nonEmptyString)\n  async getConversationByUniqueName(uniqueName: string): Promise<Conversation> {\n    await this.conversations.syncListRead.promise;\n    const conversation = await this.conversations.getConversationByUniqueName(uniqueName);\n\n    if (!conversation) {\n      throw new Error(`Conversation with unique name ${uniqueName} is not found.`);\n    }\n\n    return conversation;\n  }\n\n  /**\n   * Get the current list of all subscribed Conversations.\n   * @returns {Promise<Paginator<Conversation>>}\n   */\n  getSubscribedConversations(args?): Promise<Paginator<Conversation>> {\n    return this.conversationsPromise.then(conversations => conversations.getConversations(args));\n  }\n\n  /**\n   * Create a Conversation on the server and subscribe to its events.\n   * The default is a Conversation with an empty friendlyName.\n   * @param {Client#CreateConversationOptions} [options] - Options for the Conversation\n   * @returns {Promise<Conversation>}\n   */\n  @validateTypesAsync([\n    'undefined',\n    objectSchema('conversation options', {\n      friendlyName: ['string', 'undefined'],\n      isPrivate: ['boolean', 'undefined'],\n      uniqueName: ['string', 'undefined']\n    })\n  ])\n  createConversation(options?: Client.CreateConversationOptions): Promise<Conversation> {\n    options = options || {};\n    return this.conversationsPromise.then(conversationsEntity => conversationsEntity.addConversation(options));\n  }\n\n  /**\n   * Registers for push notifications.\n   * @param {Client#NotificationsChannelType} channelType - 'apn' and 'fcm' are supported\n   * @param {string} registrationId - Push notification id provided by the platform\n   * @returns {Promise<void>}\n   */\n  @validateTypesAsync(literal('fcm', 'apn'), 'string')\n  async setPushRegistrationId(channelType: Client.NotificationsChannelType, registrationId: string): Promise<void> {\n    await this.subscribeToPushNotifications(channelType)\n      .then(() => {\n        return this.services.notificationClient.setPushRegistrationId(registrationId, channelType);\n      });\n  }\n\n  /**\n   * Unregisters from push notifications.\n   * @param {Client#NotificationsChannelType} channelType - 'apn' and 'fcm' are supported\n   * @returns {Promise<void>}\n   */\n  @validateTypesAsync(literal('fcm', 'apn'))\n  async unsetPushRegistrationId(channelType: Client.NotificationsChannelType): Promise<void> {\n    if (Client.supportedPushChannels.indexOf(channelType) === -1) {\n      throw new Error('Invalid or unsupported channelType: ' + channelType);\n    }\n    await this.unsubscribeFromPushNotifications(channelType);\n  }\n\n  private static parsePushNotificationChatData(data: Object): Object {\n    let result: Object = {};\n    for (let key in Client.supportedPushDataFields) {\n      if (typeof data[key] !== 'undefined' && data[key] !== null) {\n        if (key === 'message_index') {\n          if (parseToNumber(data[key]) !== null) {\n            result[Client.supportedPushDataFields[key]] = Number(data[key]);\n          }\n        } else {\n          result[Client.supportedPushDataFields[key]] = data[key];\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Static method for push notification payload parsing. Returns parsed push as {@link PushNotification} object\n   * @param {Object} notificationPayload - Push notification payload\n   * @returns {PushNotification|Error}\n   */\n  @validateTypes(pureObject)\n  static parsePushNotification(notificationPayload): PushNotification {\n    log.debug('parsePushNotification, notificationPayload=', notificationPayload);\n\n    // APNS specifics\n    if (typeof notificationPayload.aps !== 'undefined') {\n      if (!notificationPayload.twi_message_type) {\n        throw new Error('Provided push notification payload does not contain Programmable Chat push notification type');\n      }\n\n      let data = Client.parsePushNotificationChatData(notificationPayload);\n\n      let apsPayload = notificationPayload.aps;\n      let body: string = null;\n      let title: string = null;\n      if (typeof apsPayload.alert === 'string') {\n        body = apsPayload.alert || null;\n      } else {\n        body = apsPayload.alert.body || null;\n        title = apsPayload.alert.title || null;\n      }\n\n      return new PushNotification({\n        title: title,\n        body: body,\n        sound: apsPayload.sound || null,\n        badge: apsPayload.badge || null,\n        action: apsPayload.category || null,\n        type: notificationPayload.twi_message_type,\n        data: data\n      });\n    }\n\n    // FCM specifics\n    if (typeof notificationPayload.data !== 'undefined') {\n      let dataPayload = notificationPayload.data;\n      if (!dataPayload.twi_message_type) {\n        throw new Error('Provided push notification payload does not contain Programmable Chat push notification type');\n      }\n\n      let data = Client.parsePushNotificationChatData(notificationPayload.data);\n      return new PushNotification({\n        title: dataPayload.twi_title || null,\n        body: dataPayload.twi_body || null,\n        sound: dataPayload.twi_sound || null,\n        badge: null,\n        action: dataPayload.twi_action || null,\n        type: dataPayload.twi_message_type,\n        data: data\n      });\n    }\n\n    throw new Error('Provided push notification payload is not Programmable Chat notification');\n  }\n\n  public parsePushNotification = Client.parsePushNotification;\n\n  /**\n   * Handle push notification payload parsing and emits event {@link Client#event:pushNotification} on this {@link Client} instance.\n   * @param {Object} notificationPayload - Push notification payload\n   * @returns {Promise<void>}\n   */\n  @validateTypesAsync(pureObject)\n  async handlePushNotification(notificationPayload): Promise<void> {\n    log.debug('handlePushNotification, notificationPayload=', notificationPayload);\n    this.emit('pushNotification', Client.parsePushNotification(notificationPayload));\n  }\n\n  /**\n   * Gets user for given identity, if it's in subscribed list - then return the user object from it,\n   * if not - then subscribes and adds user to the subscribed list.\n   * @param {String} identity - Identity of User\n   * @returns {Promise<User>} Fully initialized user\n   */\n  @validateTypesAsync(nonEmptyString)\n  public getUser(identity: string): Promise<User> {\n    return this.services.users.getUser(identity);\n  }\n\n  /**\n   * @returns {Promise<Array<User>>} List of subscribed User objects\n   */\n  public async getSubscribedUsers(): Promise<Array<User>> {\n    return this.services.users.getSubscribedUsers();\n  }\n}\n\nexport { Client };\n\n/**\n * Fired when a Conversation becomes visible to the Client. The event is also triggered when the client creates a new Conversation.\n * Fired for all conversations Client has joined.\n * @event Client#conversationAdded\n * @type {Conversation}\n */\n/**\n * Fired when the Client joins a Conversation.\n * @event Client#conversationJoined\n * @type {Conversation}\n */\n/**\n * Fired when the Client leaves a Conversation.\n * @event Client#conversationLeft\n * @type {Conversation}\n */\n/**\n * Fired when a Conversation is no longer visible to the Client.\n * @event Client#conversationRemoved\n * @type {Conversation}\n */\n/**\n * Fired when a Conversation's attributes or metadata have been updated.\n * During Conversation's {@link Client.create| creation and initialization} this event might be fired multiple times\n * for same joined or created Conversation as new data is arriving from different sources.\n * @event Client#conversationUpdated\n * @type {Object}\n * @property {Conversation} conversation - Updated Conversation\n * @property {Conversation#UpdateReason[]} updateReasons - Array of Conversation's updated event reasons\n */\n/**\n * Fired when Client's connection state has been changed.\n * @event Client#connectionStateChanged\n * @type {Client#ConnectionState}\n */\n/**\n * Fired when a Participant has joined the Conversation.\n * @event Client#participantJoined\n * @type {Participant}\n */\n/**\n * Fired when a Participant has left the Conversation.\n * @event Client#participantLeft\n * @type {Participant}\n */\n/**\n * Fired when a Participant's fields has been updated.\n * @event Client#participantUpdated\n * @type {Object}\n * @property {Participant} participant - Updated Participant\n * @property {Participant#UpdateReason[]} updateReasons - Array of Participant's updated event reasons\n */\n/**\n * Fired when a new Message has been added to the Conversation on the server.\n * @event Client#messageAdded\n * @type {Message}\n */\n/**\n * Fired when Message is removed from Conversation's message list.\n * @event Client#messageRemoved\n * @type {Message}\n */\n/**\n * Fired when an existing Message's fields are updated with new values.\n * @event Client#messageUpdated\n * @type {Object}\n * @property {Message} message - Updated Message\n * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons\n */\n/**\n * Fired when token is about to expire and needs to be updated.\n * @event Client#tokenAboutToExpire\n * @type {void}\n */\n/**\n * Fired when token is expired.\n * @event Client#tokenExpired\n * @type {void}\n */\n/**\n * Fired when a Participant has stopped typing.\n * @event Client#typingEnded\n * @type {Participant}\n */\n/**\n * Fired when a Participant has started typing.\n * @event Client#typingStarted\n * @type {Participant}\n */\n/**\n * Fired when client received (and parsed) push notification via one of push channels (apn or fcm).\n * @event Client#pushNotification\n * @type {PushNotification}\n */\n/**\n * Fired when the Client is subscribed to a User.\n * @event Client#userSubscribed\n * @type {User}\n */\n/**\n * Fired when the Client is unsubscribed from a User.\n * @event Client#userUnsubscribed\n * @type {User}\n */\n/**\n * Fired when the User's properties or reachability status have been updated.\n * @event Client#userUpdated\n * @type {Object}\n * @property {User} user - Updated User\n * @property {User#UpdateReason[]} updateReasons - Array of User's updated event reasons\n */\n/**\n * Fired when connection is interrupted by unexpected reason\n * @event Client#connectionError\n * @type {Object}\n * @property {Boolean} terminal - twilsock will stop connection attempts\n * @property {String} message - root cause\n * @property {Number} [httpStatusCode] - http status code if available\n * @property {Number} [errorCode] - Twilio public error code if available\n */\n"]},"metadata":{},"sourceType":"script"}