{"ast":null,"code":"import _slicedToArray from \"/Users/shouryagupta/Desktop/MS Engage 21/MSEngage21_VC/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { SparseFillEmptyRows } from '@tensorflow/tfjs-core';\nimport { sparseFillEmptyRowsImplCPU } from '../kernel_utils/shared';\nexport function sparseFillEmptyRows(args) {\n  const inputs = args.inputs,\n        backend = args.backend;\n  const indices = inputs.indices,\n        values = inputs.values,\n        denseShape = inputs.denseShape,\n        defaultValue = inputs.defaultValue;\n\n  if (denseShape.shape.length !== 1) {\n    throw new Error(\"Dense shape must be a vector, saw:\\n         \".concat(denseShape.shape));\n  }\n\n  if (indices.shape.length !== 2) {\n    throw new Error(\"Indices must be a matrix, saw:\\n         \".concat(indices.shape));\n  }\n\n  if (values.shape.length !== 1) {\n    throw new Error(\"Values must be a vector, saw:\\n         \".concat(values.shape));\n  }\n\n  if (defaultValue.shape.length !== 0) {\n    throw new Error(\"Default value must be a scalar, saw:\\n        \".concat(defaultValue.shape));\n  }\n\n  const $indices = backend.readSync(indices.dataId);\n  const $values = backend.readSync(values.dataId);\n  const $denseShape = backend.readSync(denseShape.dataId);\n  const $defaultValue = backend.readSync(defaultValue.dataId)[0];\n\n  const _sparseFillEmptyRowsI = sparseFillEmptyRowsImplCPU($indices, indices.shape, indices.dtype, $values, values.dtype, $denseShape, $defaultValue),\n        _sparseFillEmptyRowsI2 = _slicedToArray(_sparseFillEmptyRowsI, 5),\n        outputIndices = _sparseFillEmptyRowsI2[0],\n        outputIndicesShape = _sparseFillEmptyRowsI2[1],\n        outputValues = _sparseFillEmptyRowsI2[2],\n        emptyRowIndicator = _sparseFillEmptyRowsI2[3],\n        reverseIndexMap = _sparseFillEmptyRowsI2[4];\n\n  return [backend.makeTensorInfo(outputIndicesShape, indices.dtype, outputIndices), backend.makeTensorInfo([outputIndicesShape[0]], values.dtype, outputValues), backend.makeTensorInfo([emptyRowIndicator.length], 'bool', new Uint8Array(emptyRowIndicator.map(value => Number(value)))), backend.makeTensorInfo([reverseIndexMap.length], indices.dtype, new Int32Array(reverseIndexMap))];\n}\nexport const sparseFillEmptyRowsConfig = {\n  kernelName: SparseFillEmptyRows,\n  backendName: 'webgl',\n  kernelFunc: sparseFillEmptyRows\n};","map":{"version":3,"sources":["../../src/kernels/SparseFillEmptyRows.ts"],"names":[],"mappings":";;AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAkC,mBAAlC,QAA+G,uBAA/G;AAGA,SAAQ,0BAAR,QAAyC,wBAAzC;AAEA,OAAM,SAAU,mBAAV,CAA8B,IAA9B,EAGL;AAAA,QACQ,MADR,GAC2B,IAD3B,CACQ,MADR;AAAA,QACgB,OADhB,GAC2B,IAD3B,CACgB,OADhB;AAAA,QAEQ,OAFR,GAEqD,MAFrD,CAEQ,OAFR;AAAA,QAEiB,MAFjB,GAEqD,MAFrD,CAEiB,MAFjB;AAAA,QAEyB,UAFzB,GAEqD,MAFrD,CAEyB,UAFzB;AAAA,QAEqC,YAFrC,GAEqD,MAFrD,CAEqC,YAFrC;;AAGC,MAAI,UAAU,CAAC,KAAX,CAAiB,MAAjB,KAA4B,CAAhC,EAAmC;AACjC,UAAM,IAAI,KAAJ,wDACC,UAAU,CAAC,KADZ,EAAN;AAED;;AACD,MAAI,OAAO,CAAC,KAAR,CAAc,MAAd,KAAyB,CAA7B,EAAgC;AAC9B,UAAM,IAAI,KAAJ,oDACC,OAAO,CAAC,KADT,EAAN;AAED;;AACD,MAAI,MAAM,CAAC,KAAP,CAAa,MAAb,KAAwB,CAA5B,EAA+B;AAC7B,UAAM,IAAI,KAAJ,mDACC,MAAM,CAAC,KADR,EAAN;AAED;;AACD,MAAI,YAAY,CAAC,KAAb,CAAmB,MAAnB,KAA8B,CAAlC,EAAqC;AACnC,UAAM,IAAI,KAAJ,yDACA,YAAY,CAAC,KADb,EAAN;AAED;;AAED,QAAM,QAAQ,GAAG,OAAO,CAAC,QAAR,CAAiB,OAAO,CAAC,MAAzB,CAAjB;AACA,QAAM,OAAO,GAAG,OAAO,CAAC,QAAR,CAAiB,MAAM,CAAC,MAAxB,CAAhB;AACA,QAAM,WAAW,GAAG,OAAO,CAAC,QAAR,CAAiB,UAAU,CAAC,MAA5B,CAApB;AACA,QAAM,aAAa,GACf,OAAO,CAAC,QAAR,CAAiB,YAAY,CAAC,MAA9B,EAAsC,CAAtC,CADJ;;AAvBD,gCA4BK,0BAA0B,CACtB,QADsB,EACZ,OAAO,CAAC,KADI,EACG,OAAO,CAAC,KADX,EACkB,OADlB,EAC2B,MAAM,CAAC,KADlC,EAEtB,WAFsB,EAET,aAFS,CA5B/B;AAAA;AAAA,QA0BQ,aA1BR;AAAA,QA0BuB,kBA1BvB;AAAA,QA0B2C,YA1B3C;AAAA,QA2BQ,iBA3BR;AAAA,QA2B2B,eA3B3B;;AA+BC,SAAO,CACL,OAAO,CAAC,cAAR,CAAuB,kBAAvB,EAA2C,OAAO,CAAC,KAAnD,EAA0D,aAA1D,CADK,EAEL,OAAO,CAAC,cAAR,CACI,CAAC,kBAAkB,CAAC,CAAD,CAAnB,CADJ,EAC6B,MAAM,CAAC,KADpC,EAC2C,YAD3C,CAFK,EAIL,OAAO,CAAC,cAAR,CACI,CAAC,iBAAiB,CAAC,MAAnB,CADJ,EACgC,MADhC,EAEI,IAAI,UAAJ,CACI,iBAAiB,CAAC,GAAlB,CAAuB,KAAD,IAAoB,MAAM,CAAC,KAAD,CAAhD,CADJ,CAFJ,CAJK,EAQL,OAAO,CAAC,cAAR,CACI,CAAC,eAAe,CAAC,MAAjB,CADJ,EAC8B,OAAO,CAAC,KADtC,EAEI,IAAI,UAAJ,CAAe,eAAf,CAFJ,CARK,CAAP;AAYD;AAED,OAAO,MAAM,yBAAyB,GAAiB;AACrD,EAAA,UAAU,EAAE,mBADyC;AAErD,EAAA,WAAW,EAAE,OAFwC;AAGrD,EAAA,UAAU,EAAE;AAHyC,CAAhD","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, SparseFillEmptyRows, SparseFillEmptyRowsInputs, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {sparseFillEmptyRowsImplCPU} from '../kernel_utils/shared';\n\nexport function sparseFillEmptyRows(args: {\n  inputs: SparseFillEmptyRowsInputs,\n  backend: MathBackendWebGL\n}): [TensorInfo, TensorInfo, TensorInfo, TensorInfo] {\n  const {inputs, backend} = args;\n  const {indices, values, denseShape, defaultValue} = inputs;\n  if (denseShape.shape.length !== 1) {\n    throw new Error(`Dense shape must be a vector, saw:\n         ${denseShape.shape}`);\n  }\n  if (indices.shape.length !== 2) {\n    throw new Error(`Indices must be a matrix, saw:\n         ${indices.shape}`);\n  }\n  if (values.shape.length !== 1) {\n    throw new Error(`Values must be a vector, saw:\n         ${values.shape}`);\n  }\n  if (defaultValue.shape.length !== 0) {\n    throw new Error(`Default value must be a scalar, saw:\n        ${defaultValue.shape}`);\n  }\n\n  const $indices = backend.readSync(indices.dataId) as TypedArray;\n  const $values = backend.readSync(values.dataId) as TypedArray;\n  const $denseShape = backend.readSync(denseShape.dataId) as TypedArray;\n  const $defaultValue =\n      backend.readSync(defaultValue.dataId)[0] as number;\n\n  const [outputIndices, outputIndicesShape, outputValues,\n         emptyRowIndicator, reverseIndexMap] =\n      sparseFillEmptyRowsImplCPU(\n          $indices, indices.shape, indices.dtype, $values, values.dtype,\n          $denseShape, $defaultValue);\n  return [\n    backend.makeTensorInfo(outputIndicesShape, indices.dtype, outputIndices),\n    backend.makeTensorInfo(\n        [outputIndicesShape[0]], values.dtype, outputValues),\n    backend.makeTensorInfo(\n        [emptyRowIndicator.length], 'bool',\n        new Uint8Array(\n            emptyRowIndicator.map((value: boolean) => Number(value)))),\n    backend.makeTensorInfo(\n        [reverseIndexMap.length], indices.dtype,\n        new Int32Array(reverseIndexMap)),\n  ];\n}\n\nexport const sparseFillEmptyRowsConfig: KernelConfig = {\n  kernelName: SparseFillEmptyRows,\n  backendName: 'webgl',\n  kernelFunc: sparseFillEmptyRows as {} as KernelFunc,\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}