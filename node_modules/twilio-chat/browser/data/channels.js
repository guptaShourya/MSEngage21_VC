"use strict";

var _toConsumableArray2 = require("babel-runtime/helpers/toConsumableArray");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _assign = require("babel-runtime/core-js/object/assign");

var _assign2 = _interopRequireDefault(_assign);

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _set = require("babel-runtime/core-js/set");

var _set2 = _interopRequireDefault(_set);

var _map = require("babel-runtime/core-js/map");

var _map2 = _interopRequireDefault(_map);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Object.defineProperty(exports, "__esModule", { value: true });
exports.Channels = exports.Channel = void 0;
var events_1 = require("events");
var logger_1 = require("../logger");
var channel_1 = require("../channel");
Object.defineProperty(exports, "Channel", { enumerable: true, get: function get() {
        return channel_1.Channel;
    } });
var deferred_1 = require("../util/deferred");
var util_1 = require("../util");
var log = logger_1.Logger.scope('Channels');
/**
 * Represents channels collection
 * {@see Channel}
 */

var Channels = function (_events_1$EventEmitte) {
    (0, _inherits3.default)(Channels, _events_1$EventEmitte);

    function Channels(configuration, services) {
        (0, _classCallCheck3.default)(this, Channels);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Channels.__proto__ || (0, _getPrototypeOf2.default)(Channels)).call(this));

        _this.configuration = configuration;
        _this.services = services;
        _this.channels = new _map2.default();
        _this.tombstones = new _set2.default();
        _this.myChannelsFetched = false;
        _this.myChannelsRead = new deferred_1.Deferred();
        return _this;
    }

    (0, _createClass3.default)(Channels, [{
        key: "getMap",
        value: function () {
            var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                _context.next = 2;
                                return this.services.syncClient.map({
                                    id: this.configuration.myConversations,
                                    mode: 'open_existing'
                                });

                            case 2:
                                return _context.abrupt("return", _context.sent);

                            case 3:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));

            function getMap() {
                return _ref.apply(this, arguments);
            }

            return getMap;
        }()
        /**
         * Add channel to server
         * @private
         * @returns {Promise<Channel>} Channel
         */

    }, {
        key: "addChannel",
        value: function () {
            var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(options) {
                var attributes, response, channelSid, channelDocument, links, existingChannel, channel;
                return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                attributes = void 0;

                                if (typeof options.attributes === 'undefined') {
                                    attributes = {};
                                } else {
                                    attributes = options.attributes;
                                }
                                _context2.next = 4;
                                return this.services.commandExecutor.mutateResource('post', this.configuration.links.conversations, {
                                    type: options.isPrivate ? 'private' : 'public',
                                    unique_name: options.uniqueName,
                                    friendly_name: options.friendlyName,
                                    attributes: attributes !== undefined ? (0, _stringify2.default)(attributes) : undefined
                                });

                            case 4:
                                response = _context2.sent;
                                channelSid = response.sid || null;
                                channelDocument = response.sync_objects.conversation || null;
                                links = (0, _assign2.default)({ self: response.url }, response.links);
                                existingChannel = this.channels.get(channelSid);

                                if (!existingChannel) {
                                    _context2.next = 13;
                                    break;
                                }

                                _context2.next = 12;
                                return existingChannel._subscribe();

                            case 12:
                                return _context2.abrupt("return", existingChannel);

                            case 13:
                                channel = new channel_1.Channel({
                                    channel: channelDocument,
                                    entityName: null,
                                    uniqueName: null,
                                    attributes: null,
                                    createdBy: null,
                                    friendlyName: null,
                                    lastConsumedMessageIndex: null,
                                    type: options.isPrivate ? 'private' : 'public',
                                    dateCreated: null,
                                    dateUpdated: null
                                }, channelSid, links, this.configuration, this.services);

                                this.channels.set(channel.sid, channel);
                                this.registerForEvents(channel);
                                _context2.next = 18;
                                return channel._subscribe();

                            case 18:
                                this.emit('channelAdded', channel);
                                return _context2.abrupt("return", channel);

                            case 20:
                            case "end":
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));

            function addChannel(_x) {
                return _ref2.apply(this, arguments);
            }

            return addChannel;
        }()
        /**
         * Fetch channels list and instantiate all necessary objects
         */

    }, {
        key: "fetchChannels",
        value: function () {
            var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
                var _this2 = this;

                var map, myChannels, upserts, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, channel, errorMessage;

                return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                _context3.prev = 0;
                                _context3.next = 3;
                                return this.getMap();

                            case 3:
                                map = _context3.sent;

                                map.on('itemAdded', function (args) {
                                    log.debug("itemAdded: " + args.item.key);
                                    _this2.upsertChannel('sync', args.item.key, args.item.data);
                                });
                                map.on('itemRemoved', function (args) {
                                    log.debug("itemRemoved: " + args.key);
                                    var sid = args.key;
                                    if (!_this2.myChannelsFetched) {
                                        _this2.tombstones.add(sid);
                                    }
                                    var channel = _this2.channels.get(sid);
                                    if (!channel) {
                                        return;
                                    }
                                    if (channel.status === 'joined' || channel.status === 'invited') {
                                        channel._setStatus('notParticipating', 'sync');
                                        _this2.emit('channelLeft', channel);
                                    }
                                    if (channel.isPrivate) {
                                        _this2.channels.delete(sid);
                                        _this2.emit('channelRemoved', channel);
                                        channel.emit('removed', channel);
                                    }
                                });
                                map.on('itemUpdated', function (args) {
                                    log.debug("itemUpdated: " + args.item.key);
                                    _this2.upsertChannel('sync', args.item.key, args.item.data);
                                });
                                _context3.next = 9;
                                return this._fetchMyChannels();

                            case 9:
                                myChannels = _context3.sent;
                                upserts = [];
                                _iteratorNormalCompletion = true;
                                _didIteratorError = false;
                                _iteratorError = undefined;
                                _context3.prev = 14;

                                for (_iterator = (0, _getIterator3.default)(myChannels); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                    channel = _step.value;

                                    upserts.push(this.upsertChannel('rest', channel.channel_sid, channel));
                                }
                                _context3.next = 22;
                                break;

                            case 18:
                                _context3.prev = 18;
                                _context3.t0 = _context3["catch"](14);
                                _didIteratorError = true;
                                _iteratorError = _context3.t0;

                            case 22:
                                _context3.prev = 22;
                                _context3.prev = 23;

                                if (!_iteratorNormalCompletion && _iterator.return) {
                                    _iterator.return();
                                }

                            case 25:
                                _context3.prev = 25;

                                if (!_didIteratorError) {
                                    _context3.next = 28;
                                    break;
                                }

                                throw _iteratorError;

                            case 28:
                                return _context3.finish(25);

                            case 29:
                                return _context3.finish(22);

                            case 30:
                                this.myChannelsRead.set(true);
                                _context3.next = 33;
                                return _promise2.default.all(upserts);

                            case 33:
                                this.myChannelsFetched = true;
                                this.tombstones.clear();
                                log.debug('The channels list has been successfully fetched');
                                return _context3.abrupt("return", this);

                            case 39:
                                _context3.prev = 39;
                                _context3.t1 = _context3["catch"](0);
                                errorMessage = 'Failed to fetch the channels list';

                                if (this.services.syncClient.connectionState !== 'disconnected') {
                                    log.error(errorMessage, _context3.t1);
                                }
                                log.debug("ERROR: " + errorMessage, _context3.t1);
                                throw _context3.t1;

                            case 45:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3, this, [[0, 39], [14, 18, 22, 30], [23,, 25, 29]]);
            }));

            function fetchChannels() {
                return _ref3.apply(this, arguments);
            }

            return fetchChannels;
        }()
    }, {
        key: "_wrapPaginator",
        value: function _wrapPaginator(page, op) {
            var _this3 = this;

            return op(page.items).then(function (items) {
                return {
                    items: items,
                    hasNextPage: page.hasNextPage,
                    hasPrevPage: page.hasPrevPage,
                    nextPage: function nextPage() {
                        return page.nextPage().then(function (x) {
                            return _this3._wrapPaginator(x, op);
                        });
                    },
                    prevPage: function prevPage() {
                        return page.prevPage().then(function (x) {
                            return _this3._wrapPaginator(x, op);
                        });
                    }
                };
            });
        }
    }, {
        key: "getChannels",
        value: function getChannels(args) {
            var _this4 = this;

            return this.getMap().then(function (channelsMap) {
                return channelsMap.getItems(args);
            }).then(function (page) {
                return _this4._wrapPaginator(page, function (items) {
                    return _promise2.default.all(items.map(function (item) {
                        return _this4.upsertChannel('sync', item.key, item.data);
                    }));
                });
            });
        }
    }, {
        key: "getChannel",
        value: function getChannel(sid) {
            var _this5 = this;

            return this.getMap().then(function (channelsMap) {
                return channelsMap.getItems({ key: sid });
            }).then(function (page) {
                return page.items.map(function (item) {
                    return _this5.upsertChannel('sync', item.key, item.data);
                });
            }).then(function (items) {
                return items.length > 0 ? items[0] : null;
            });
        }
    }, {
        key: "pushChannel",
        value: function pushChannel(descriptor) {
            var sid = descriptor.sid;
            var data = {
                entityName: null,
                lastConsumedMessageIndex: descriptor.lastConsumedMessageIndex,
                type: descriptor.type,
                status: descriptor.status,
                friendlyName: descriptor.friendlyName,
                dateUpdated: descriptor.dateUpdated,
                dateCreated: descriptor.dateCreated,
                uniqueName: descriptor.uniqueName,
                createdBy: descriptor.createdBy,
                attributes: descriptor.attributes,
                channel: descriptor.channel,
                notificationLevel: descriptor.notificationLevel,
                sid: sid
            };
            return this.upsertChannel('chat', sid, data);
        }
    }, {
        key: "_updateChannel",
        value: function _updateChannel(source, channel, data) {
            var _this6 = this;

            var areSourcesDifferent = channel._statusSource() !== undefined && source !== channel._statusSource();
            var isChannelSourceSync = source !== 'rest' || channel._statusSource() === 'sync';
            if (areSourcesDifferent && isChannelSourceSync && source !== 'sync') {
                log.trace('upsertChannel: the channel is known from sync and it came from chat, ignoring', {
                    sid: channel.sid,
                    data: data.status,
                    channel: channel.status
                });
                return;
            }
            if (['joined', 'invited'].includes(data.status) && channel.status !== data.status) {
                channel._setStatus(data.status, source);
                var updateData = {};
                if (data.notificationLevel !== undefined) {
                    updateData.notificationLevel = data.notificationLevel;
                }
                if (data.lastConsumedMessageIndex !== undefined) {
                    updateData.lastConsumedMessageIndex = data.lastConsumedMessageIndex;
                }
                if (!util_1.isDeepEqual(updateData, {})) {
                    channel._update(updateData);
                }
                channel._subscribe().then(function () {
                    _this6.emit(data.status === 'joined' ? 'channelJoined' : 'channelInvited', channel);
                });
                return;
            }
            if (['joined', 'invited'].includes(channel.status) && data.status === 'notParticipating') {
                channel._setStatus('notParticipating', source);
                channel._update(data);
                channel._subscribe().then(function () {
                    _this6.emit('channelLeft', channel);
                });
                return;
            }
            if (data.type === 'private' && data.status === 'notParticipating') {
                channel._subscribe();
                return;
            }
            channel._update(data);
        }
    }, {
        key: "upsertChannel",
        value: function upsertChannel(source, sid, data) {
            var _this7 = this;

            log.trace("upsertChannel called for " + sid, data);
            var channel = this.channels.get(sid);
            // If the channel is known, update it
            if (channel) {
                log.trace("upsertChannel: the channel " + channel.sid + " is known;" + ("its status is known from source " + channel._statusSource() + " ") + ("and the update came from source " + source), channel);
                this._updateChannel(source, channel, data);
                return channel._subscribe().then(function () {
                    return channel;
                });
            }
            // If the channel is deleted, ignore it
            if (['chat', 'rest'].includes(source) && this.tombstones.has(sid)) {
                log.trace('upsertChannel: the channel is deleted but reappeared again from chat, ignoring', sid);
                return;
            }
            // If the channel is unknown, fetch it
            log.trace("upsertChannel: creating a local channel object with sid " + sid, data);
            var baseLink = this.configuration.links.conversations + "/" + sid;
            var links = {
                self: baseLink,
                messages: baseLink + "/Messages",
                participants: baseLink + "/Participants",
                invites: baseLink + "/Invites"
            };
            var newChannel = new channel_1.Channel(data, sid, links, this.configuration, this.services);
            this.channels.set(sid, newChannel);
            return newChannel._subscribe().then(function () {
                _this7.registerForEvents(newChannel);
                _this7.emit('channelAdded', newChannel);
                if (['joined', 'invited'].includes(data.status)) {
                    newChannel._setStatus(data.status, source);
                    _this7.emit(data.status === 'joined' ? 'channelJoined' : 'channelInvited', newChannel);
                }
                return newChannel;
            });
        }
    }, {
        key: "onChannelRemoved",
        value: function onChannelRemoved(sid) {
            var channel = this.channels.get(sid);
            if (channel) {
                this.channels.delete(sid);
                this.emit('channelRemoved', channel);
            }
        }
    }, {
        key: "registerForEvents",
        value: function registerForEvents(channel) {
            var _this8 = this;

            channel.on('removed', function () {
                return _this8.onChannelRemoved(channel.sid);
            });
            channel.on('updated', function (args) {
                return _this8.emit('channelUpdated', args);
            });
            channel.on('memberJoined', this.emit.bind(this, 'memberJoined'));
            channel.on('memberLeft', this.emit.bind(this, 'memberLeft'));
            channel.on('memberUpdated', function (args) {
                return _this8.emit('memberUpdated', args);
            });
            channel.on('messageAdded', this.emit.bind(this, 'messageAdded'));
            channel.on('messageUpdated', function (args) {
                return _this8.emit('messageUpdated', args);
            });
            channel.on('messageRemoved', this.emit.bind(this, 'messageRemoved'));
            channel.on('typingStarted', this.emit.bind(this, 'typingStarted'));
            channel.on('typingEnded', this.emit.bind(this, 'typingEnded'));
        }
    }, {
        key: "_fetchMyChannels",
        value: function () {
            var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4() {
                var channels, pageToken, url, response, preProcessedChannels;
                return _regenerator2.default.wrap(function _callee4$(_context4) {
                    while (1) {
                        switch (_context4.prev = _context4.next) {
                            case 0:
                                channels = [];
                                pageToken = null;

                            case 2:
                                url = new util_1.UriBuilder(this.configuration.links.myConversations);

                                if (pageToken) {
                                    url.arg('PageToken', pageToken);
                                }
                                _context4.next = 6;
                                return this.services.network.get(url.build());

                            case 6:
                                response = _context4.sent;
                                preProcessedChannels = response.body.conversations.map(function (channelDescriptor) {
                                    return {
                                        descriptor: channelDescriptor,
                                        channel_sid: channelDescriptor.conversation_sid,
                                        status: channelDescriptor.status,
                                        channel: channelDescriptor.sync_objects.conversation,
                                        messages: channelDescriptor.sync_objects.messages,
                                        roster: channelDescriptor.conversation_sid + ".roster",
                                        lastConsumedMessageIndex: channelDescriptor.last_consumed_message_index,
                                        notificationLevel: channelDescriptor.notification_level
                                    };
                                });

                                pageToken = response.body.meta.next_token;
                                channels = [].concat((0, _toConsumableArray3.default)(channels), (0, _toConsumableArray3.default)(preProcessedChannels));

                            case 10:
                                if (pageToken) {
                                    _context4.next = 2;
                                    break;
                                }

                            case 11:
                                return _context4.abrupt("return", channels);

                            case 12:
                            case "end":
                                return _context4.stop();
                        }
                    }
                }, _callee4, this);
            }));

            function _fetchMyChannels() {
                return _ref4.apply(this, arguments);
            }

            return _fetchMyChannels;
        }()
    }]);
    return Channels;
}(events_1.EventEmitter);

exports.Channels = Channels;