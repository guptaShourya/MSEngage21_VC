"use strict";

var _assign = require("babel-runtime/core-js/object/assign");

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Object.defineProperty(exports, "__esModule", { value: true });
exports.Configuration = void 0;
var iso8601_duration_1 = require("iso8601-duration");
var TYPING_TIMEOUT = 5;
var HTTP_CACHE_LIFETIME = 'PT5S';
var CONSUMPTION_HORIZON_SENDING_INTERVAL = 'PT5S';
var USER_INFOS_TO_SUBSCRIBE = 100;
var MINIMUM_RETRY_DELAY = 1000;
var MAXIMUM_RETRY_DELAY = 4000;
var MAXIMUM_ATTEMPTS_COUNT = 3;
var RETRY_WHEN_THROTTLED = true;

var Configuration = function Configuration() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var configurationResponse = arguments[1];
    var logger = arguments[2];
    (0, _classCallCheck3.default)(this, Configuration);

    this.typingIndicatorTimeoutDefault = TYPING_TIMEOUT * 1000;
    var constructorOptions = options.Chat || options.IPMessaging || options || {};
    this.productId = constructorOptions.productId;
    this.links = {
        myConversations: configurationResponse.links.my_conversations,
        conversations: configurationResponse.links.conversations,
        users: configurationResponse.links.users,
        currentUser: configurationResponse.links.current_user,
        typing: configurationResponse.links.typing,
        mediaService: configurationResponse.links.media_service,
        messagesReceipts: configurationResponse.links.messages_receipts
    };
    this.typingIndicatorTimeoutOverride = constructorOptions.typingIndicatorTimeoutOverride;
    this.backoffConfiguration = (0, _assign2.default)({ min: MINIMUM_RETRY_DELAY, max: MAXIMUM_RETRY_DELAY, maxAttemptsCount: MAXIMUM_ATTEMPTS_COUNT }, constructorOptions.backoffConfigOverride);
    this.retryWhenThrottled = constructorOptions.retryWhenThrottledOverride !== undefined ? constructorOptions.retryWhenThrottledOverride : RETRY_WHEN_THROTTLED;
    this.userInfosToSubscribe = constructorOptions.userInfosToSubscribeOverride || configurationResponse.options.user_infos_to_subscribe || USER_INFOS_TO_SUBSCRIBE;
    this.reachabilityEnabled = configurationResponse.options.reachability_enabled;
    this.userIdentity = configurationResponse.identity;
    this.userInfo = configurationResponse.sync_objects.my_user_info;
    this.myConversations = configurationResponse.sync_objects.my_conversations;
    var httpCacheInterval = constructorOptions.httpCacheIntervalOverride || configurationResponse.options.http_cache_interval || HTTP_CACHE_LIFETIME;
    try {
        this.httpCacheInterval = iso8601_duration_1.toSeconds(iso8601_duration_1.parse(httpCacheInterval));
    } catch (_a) {
        logger.error("Failed to parse http cache interval " + httpCacheInterval + ", using default value " + HTTP_CACHE_LIFETIME);
        this.httpCacheInterval = iso8601_duration_1.toSeconds(iso8601_duration_1.parse(HTTP_CACHE_LIFETIME));
    }
    var consumptionReportInterval = constructorOptions.consumptionReportIntervalOverride || configurationResponse.options.consumption_report_interval || CONSUMPTION_HORIZON_SENDING_INTERVAL;
    try {
        this.consumptionReportInterval = iso8601_duration_1.toSeconds(iso8601_duration_1.parse(consumptionReportInterval));
    } catch (_b) {
        logger.error("Failed to parse consumption report interval " + consumptionReportInterval + ", using default value " + CONSUMPTION_HORIZON_SENDING_INTERVAL);
        this.consumptionReportInterval = iso8601_duration_1.toSeconds(iso8601_duration_1.parse(CONSUMPTION_HORIZON_SENDING_INTERVAL));
    }
};

exports.Configuration = Configuration;