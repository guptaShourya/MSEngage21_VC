"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Media = void 0;
/**
 * @classdesc A Media represents a metadata information for the media upload
 * @property {String} sid - The server-assigned unique identifier for Media
 * @property {String} serviceSid - Service instance id which Media belongs/uploaded to
 * @property {Date} dateCreated - When the Media was created
 * @property {Date} dateUpdated - When the Media was updated
 * @property {Number} size - Size of media, bytes
 * @property {String} contentType - content type of media
 * @property {String} fileName - file name, if present, null otherwise
 * @property {MediaCategory} category - attachment category
 */
class Media {
    constructor(config, network, data) {
        this.config = config;
        this.network = network;
        this._update(data);
    }
    get sid() { return this.state.sid; }
    get serviceSid() { return this.state.serviceSid; }
    get dateCreated() { return this.state.dateCreated; }
    get dateUpdated() { return this.state.dateUpdated; }
    get contentType() { return this.state.contentType; }
    get size() { return this.state.size; }
    /** @deprecated Use filename instead */
    get fileName() { return this.state.filename; }
    get filename() { return this.state.filename; }
    get category() { return this.state.category; }
    /**
     * Returns direct content URL to uploaded binary. This URL will expire after some time.
     * This function gets a new URL every time, preventing it from expiring but putting additional load on backend.
     * See getCachedContentUrl() for a function that reduces the amount of network requests.
     *
     * It is reasonable to build your own refresh logic upon these two functions: as soon as URL returned
     * by getCachedContentUrl() returns 40x status you should call getContentUrl() to refresh it.
     *
     * @returns {Promise<string>}
     */
    async getContentUrl() {
        let response = await this.network.get(`${this.config.baseUrl}/${this.sid}`);
        this._update(response.body);
        return Promise.resolve(this.state.contentDirectUrl);
    }
    /**
     * Returns direct content URL to uploaded binary. This URL will expire after some time.
     * This function does not support getting a new URL however. Once set it will remain the same.
     * Use getContentUrl() to query a new one.
     *
     * It is reasonable to build your own refresh logic upon these two functions: as soon as URL returned
     * by getCachedContentUrl() returns 40x status you should call getContentUrl() to refresh it.
     *
     * @returns {Promise<string>}
     */
    async getCachedContentUrl() {
        if (this.state.contentDirectUrl) {
            return Promise.resolve(this.state.contentDirectUrl);
        }
        return await this.getContentUrl();
    }
    _update(data) {
        var _a, _b, _c;
        this.state = {
            sid: data.sid,
            serviceSid: data.service_sid,
            channelSid: data.channel_sid,
            messageSid: data.message_sid,
            dateCreated: data.date_created ? new Date(data.date_created) : null,
            dateUploadUpdated: data.date_upload_updated ? new Date(data.date_upload_updated) : null,
            dateUpdated: data.date_updated ? new Date(data.date_updated) : null,
            size: data.size,
            contentType: data.content_type,
            author: data.author,
            url: data.url,
            contentUrl: data.links.content,
            contentDirectUrl: data.links.content_direct_temporary,
            filename: (_a = data.filename) !== null && _a !== void 0 ? _a : null,
            category: (_b = data.category) !== null && _b !== void 0 ? _b : 'media',
            isMultipartUpstream: (_c = data.is_multipart_upstream) !== null && _c !== void 0 ? _c : false,
        };
    }
}
exports.Media = Media;
