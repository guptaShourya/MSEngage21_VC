"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandExecutor = void 0;
const uuid_1 = require("uuid");
const operation_retrier_1 = require("operation-retrier");
const trimSlashes = (url) => url.replace(/(^\/+|\/+$)/g, '');
const isMutationConflictResponse = (response) => response.status.code === 202;
class CommandExecutor {
    constructor(_serviceUrl, _services, _productId) {
        this._serviceUrl = _serviceUrl;
        this._services = _services;
        this._productId = _productId;
    }
    _preProcessUrl(url) {
        const trimmedUrl = trimSlashes(url);
        if (/^https?:\/\//.test(url)) {
            return trimmedUrl;
        }
        return `${trimSlashes(this._serviceUrl)}/${trimmedUrl}`;
    }
    async _makeRequest(method, url, requestBody, headers) {
        const preProcessedUrl = this._preProcessUrl(url);
        const finalHeaders = Object.assign({ 'Content-Type': 'application/json; charset=utf-8' }, (headers || {}));
        let response;
        switch (method) {
            case 'get':
                let getUrl = preProcessedUrl;
                if (requestBody) {
                    getUrl +=
                        '?' +
                            Object.entries(requestBody)
                                .map((entry) => entry.map(encodeURIComponent).join('='))
                                .join('&');
                }
                response = await this._services.transport.get(getUrl, finalHeaders, this._productId);
                break;
            case 'post':
                response = await this._services.transport.post(preProcessedUrl, finalHeaders, JSON.stringify(requestBody), this._productId);
                break;
            case 'delete':
                response = await this._services.transport.delete(preProcessedUrl, finalHeaders, this._productId);
                break;
        }
        if (response.status.code < 200 || response.status.code >= 300) {
            throw new Error(`Request responded with a non-success code ${response.status.code}`);
        }
        return response;
    }
    async fetchResource(url, requestBody) {
        const maxAttemptsCount = 6;
        let result;
        try {
            result = await new operation_retrier_1.Retrier({ min: 50, max: 1600, maxAttemptsCount })
                .run(() => this._makeRequest('get', url, requestBody));
        }
        catch (_a) {
            throw new Error(`Fetch resource from "${url}" failed.`);
        }
        return result.body;
    }
    async mutateResource(method, url, requestBody) {
        const result = await this._makeRequest(method, url, requestBody, {
            'X-Twilio-Mutation-Id': uuid_1.v4()
        });
        if (isMutationConflictResponse(result)) {
            return await this.fetchResource(result.body.resource_url);
        }
        return result.body;
    }
}
exports.CommandExecutor = CommandExecutor;
