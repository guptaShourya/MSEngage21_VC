"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Users = void 0;
const events_1 = require("events");
const user_1 = require("../user");
const userdescriptors_1 = require("./userdescriptors");
/**
 * @classdesc Container for known users
 * @fires Users#userUpdated
 */
class Users extends events_1.EventEmitter {
    constructor(configuration, services) {
        super();
        this.configuration = configuration;
        this.services = services;
        const userLinks = {
            self: `${configuration.links.users}/${configuration.userIdentity}`
        };
        this.fifoStack = [];
        this.myself = new user_1.User(this.configuration.userIdentity, this.configuration.userInfo, userLinks, this.configuration, this.services);
        this.myself.on('updated', (args) => this.emit('userUpdated', args));
        this.myself.on('userSubscribed', () => this.emit('userSubscribed', this.myself));
        this.myself.on('userUnsubscribed', () => {
            this.emit('userUnsubscribed', this.myself);
            this.myself._ensureFetched();
        });
        this.subscribedUsers = new Map();
        this.userDescriptors = new userdescriptors_1.UserDescriptors(this.configuration, Object.assign(Object.assign({}, this.services), { users: this }));
    }
    handleUnsubscribeUser(user) {
        if (this.subscribedUsers.has(user.identity)) {
            this.subscribedUsers.delete(user.identity);
        }
        let foundItemIndex = -1;
        let foundItem = this.fifoStack.find((item, index) => {
            if (item == user.identity) {
                foundItemIndex = index;
                return true;
            }
            return false;
        });
        if (foundItem) {
            this.fifoStack.splice(foundItemIndex, 1);
        }
        this.emit('userUnsubscribed', user);
    }
    handleSubscribeUser(user) {
        if (this.subscribedUsers.has(user.identity)) {
            return;
        }
        if (this.fifoStack.length >= this.configuration.userInfosToSubscribe) {
            this.subscribedUsers.get(this.fifoStack.shift()).unsubscribe();
        }
        this.fifoStack.push(user.identity);
        this.subscribedUsers.set(user.identity, user);
        this.emit('userSubscribed', user);
    }
    /**
     * Gets user, if it's in subscribed list - then return the user object from it,
     * if not - then subscribes and adds user to the FIFO stack
     * @returns {Promise<User>} Fully initialized user
     */
    async getUser(identity, entityName = null) {
        await this.myself._ensureFetched();
        if (identity == this.myself.identity) {
            return this.myself;
        }
        let user = this.subscribedUsers.get(identity);
        if (!user) {
            if (!entityName) {
                let userDescriptor = await this.getUserDescriptor(identity);
                entityName = userDescriptor._getDescriptor().sync_objects.user_info_map;
            }
            const userLinks = {
                self: `${this.configuration.links.users}/${identity}`
            };
            user = new user_1.User(identity, entityName, userLinks, this.configuration, this.services);
            user.on('updated', (args) => this.emit('userUpdated', args));
            user.on('userSubscribed', () => this.handleSubscribeUser(user));
            user.on('userUnsubscribed', () => this.handleUnsubscribeUser(user));
            await user._ensureFetched();
        }
        return user;
    }
    /**
     * @returns {Promise<UserDescriptor>} User descriptor
     */
    async getUserDescriptor(identity) {
        return this.userDescriptors.getUserDescriptor(identity);
    }
    /**
     * @returns {Promise<Paginator<UserDescriptor>>} Users descriptors page for given channel sid
     */
    async getChannelUserDescriptors(channelSid) {
        return this.userDescriptors.getChannelUserDescriptors(channelSid);
    }
    /**
     * @returns {Promise<Array<User>>} returns list of subscribed User objects {@see User}
     */
    async getSubscribedUsers() {
        await this.myself._ensureFetched();
        const users = [this.myself];
        this.subscribedUsers.forEach((user) => users.push(user));
        return users;
    }
}
exports.Users = Users;
