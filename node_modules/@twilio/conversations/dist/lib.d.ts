/// <reference types="node" />
import { EventEmitter } from "events";
import { SyncClient } from "twilio-sync";
import { Twilsock as TwilsockClient } from "twilsock";
import { ChannelType, Notifications } from "twilio-notifications";
import { ConnectionState as NotificationConnectionState } from "twilio-notifications";
import { Notifications as NotificationClient } from "twilio-notifications";
import { McsClient } from "twilio-mcs-client";
declare class Configuration {
    token: string;
    readonly typingIndicatorTimeoutOverride?: number;
    readonly httpCacheIntervalOverride?: string;
    readonly consumptionReportIntervalOverride?: number;
    readonly userInfosToSubscribeOverride?: number;
    readonly retryWhenThrottledOverride?: boolean;
    readonly backoffConfigOverride?: any;
    readonly typingIndicatorUri: string;
    readonly productId: string;
    private baseUrl;
    private region;
    constructor(options: any);
    get typingIndicatorTimeoutDefault(): number;
    get httpCacheIntervalDefault(): string;
    get consumptionReportIntervalDefault(): string;
    get userInfosToSubscribeDefault(): number;
    get retryWhenThrottledDefault(): boolean;
    get backoffConfigDefault(): any;
}
interface SessionLinks {
    publicChannelsUrl: string;
    myChannelsUrl: string;
    typingUrl: string;
    syncListUrl: string;
    usersUrl: string;
    mediaServiceUrl: string;
    messagesReceiptsUrl: string;
}
interface SessionServices {
    syncClient: SyncClient;
}
/**
 *  Constructs the instance of Session
 *
 *  @classdesc Provides the interface to send the command to the server
 *  It is reliable, which means that it tracks the command object state
 *  and waits the answer from the server.
 */
declare class Session {
    readonly services: SessionServices;
    private endpointPlatform;
    private config;
    private pendingCommands;
    private sessionStreamPromise;
    private readonly sessionInfo;
    private currentContext;
    constructor(services: SessionServices, config: Configuration);
    get identity(): string;
    get reachabilityEnabled(): boolean;
    private handleContextUpdate;
    initialize(): Promise<Session>;
    /**
     * Sends the command to the server
     * @returns Promise the promise, which is being fulfilled only when service will reply
     */
    addCommand(action: string, params: any): Promise<any>;
    /**
     * @private
     */
    private processCommand;
    /**
     * @private
     */
    private processCommandResponse;
    private getSessionContext;
    getSessionLinks(): Promise<SessionLinks>;
    getConversationsId(): Promise<string>;
    getMyConversationsId(): Promise<string>;
    getMaxUserInfosToSubscribe(): Promise<number>;
    getUsersData(): Promise<{
        user: string;
        identity: string;
    }>;
    getConsumptionReportInterval(): Promise<number>;
    getHttpCacheInterval(): Promise<number>;
}
interface UserServices {
    session: Session;
    syncClient: SyncClient;
}
declare namespace User {
    type SubscriptionState = "initializing" | "subscribed" | "unsubscribed";
    type UpdateReason = "friendlyName" | "attributes" | "reachabilityOnline" | "reachabilityNotifiable";
    interface UpdatedEventArgs {
        user: User;
        updateReasons: User.UpdateReason[];
    }
}
/**
 * @classdesc Extended user information.
 * Note that <code>isOnline</code> and <code>isNotifiable</code> properties are eligible
 * to use only if reachability function is enabled.
 * You may check if it is enabled by reading value of {@link Client}'s <code>reachabilityEnabled</code> property.
 *
 * @property {String} identity - User identity
 * @property {String} friendlyName - User friendly name, null if not set
 * @property {any} attributes - Object with custom attributes for user
 * @property {Boolean} isOnline - User real-time conversation connection status
 * @property {Boolean} isNotifiable - User push notification registration status
 * @property {Boolean} isSubscribed - Check if this user receives real-time status updates
 *
 * @fires User#updated
 * @fires User#userSubscribed
 * @fires User#userUnsubscribed
 *
 * @constructor
 * @param {String} identity - Identity of user
 * @param {String} entityId - id of user's object
 * @param {Object} datasync - datasync service
 * @param {Object} session - session service
 */
declare class User extends EventEmitter {
    private entity;
    private services;
    private state;
    private promiseToFetch;
    private subscribed;
    /**
     * The update reason for <code>updated</code> event emitted on User
     * @typedef {('friendlyName' | 'attributes' | 'reachabilityOnline' | 'reachabilityNotifiable')} User#UpdateReason
     */
    constructor(identity: string, entityName: string, services: UserServices);
    get identity(): string;
    set identity(identity: string);
    set entityName(name: string);
    get attributes(): any;
    get friendlyName(): string;
    get isOnline(): boolean;
    get isNotifiable(): boolean;
    get isSubscribed(): boolean;
    // Handles service updates
    _update(key: string, value: any): void;
    // Fetch reachability info
    _updateReachabilityInfo(map: any, update: any): any;
    // Fetch user
    _fetch(): Promise<User>;
    _ensureFetched(): Promise<User>;
    /**
     * Updates user attributes.
     * @param {any} attributes new attributes for User.
     * @returns {Promise<User>}
     */
    updateAttributes(attributes: any): Promise<User>;
    /**
     * Update Users friendlyName.
     * @param {String|null} friendlyName - Updated friendlyName
     * @returns {Promise<User>}
     */
    updateFriendlyName(friendlyName: string | null): Promise<User>;
    /**
     * Removes User from subscription list.
     * @returns {Promise<void>} Promise of completion
     */
    unsubscribe(): Promise<void>;
}
interface Result {
}
interface Transport extends EventEmitter {
    readonly isConnected: boolean;
    readonly state: string;
    get(url: string, headers: any, grant?: string): Promise<Result>;
    post(url: string, headers: any, body: any, grant?: string): Promise<Result>;
    put(url: string, headers: any, body: any, grant?: string): Promise<Result>;
    delete(url: string, headers: any, grant?: string): Promise<Result>;
}
declare class Network {
    private readonly config;
    private readonly services;
    private cacheLifetime;
    private readonly cache;
    private timer;
    constructor(config: any, services: any);
    private backoffConfig;
    private retryWhenThrottled;
    private isExpired;
    private cleanupCache;
    pokeTimer(): void;
    private executeWithRetry;
    get(url: string): Promise<any>;
}
interface UsersServices {
    session: Session;
    network: Network;
    syncClient: SyncClient;
}
/**
 * @classdesc Container for known users
 * @fires Users#userUpdated
 */
declare class Users extends EventEmitter {
    private services;
    private subscribedUsers;
    private fifoStack;
    private fifoStackMaxLength;
    private userUrlPromise;
    private userUrl;
    readonly myself: User;
    constructor(services: UsersServices);
    private handleUnsubscribeUser;
    private handleSubscribeUser;
    /**
     * Gets user, if it's in subscribed list - then return the user object from it,
     * if not - then subscribes and adds user to the FIFO stack
     * @returns {Promise<User>} Fully initialized user
     */
    getUser(identity: string, entityName?: string): Promise<User>;
    /**
     * @returns {Promise<Array<User>>} returns list of subscribed User objects {@see User}
     */
    getSubscribedUsers(): Promise<Array<User>>;
    /**
     * @returns {Promise<string>} User's sync unique name
     */
    private getSyncUniqueName;
}
interface ParticipantDescriptor {
    attributes?: Object;
    dateCreated: any;
    dateUpdated: any;
    identity: string;
    roleSid?: string;
    lastConsumedMessageIndex: number;
    lastConsumptionTimestamp: number;
    type: Participant.Type;
    userInfo: string;
}
interface ParticipantServices {
    users: Users;
    session: Session;
}
declare namespace Participant {
    type UpdateReason = "attributes" | "dateCreated" | "dateUpdated" | "roleSid" | "lastReadMessageIndex" | "lastReadTimestamp";
    type Type = "chat" | "sms" | "whatsapp";
    interface UpdatedEventArgs {
        participant: Participant;
        updateReasons: Participant.UpdateReason[];
    }
}
/**
 * @classdesc A Participant represents a remote Client in a Conversation.
 * @property {any} attributes - Object with custom attributes for Participant
 * @property {Conversation} conversation - The Conversation the remote Client is a Participant of
 * @property {Date} dateCreated - The Date this Participant was created
 * @property {Date} dateUpdated - The Date this Participant was last updated
 * @property {String} identity - The identity of the remote Client
 * @property {Boolean} isTyping - Whether or not this Participant is currently typing
 * @property {Number|null} lastReadMessageIndex - Latest read Message index by this Participant.
 * Note that just retrieving messages on a client endpoint does not mean that messages are read,
 * please consider reading about [Read Horizon feature]{@link https://www.twilio.com/docs/api/chat/guides/consumption-horizon}
 * to find out how to mark messages as read.
 * @property {Date} lastReadTimestamp - Date when Participant has updated his read horizon
 * @property {String} sid - The server-assigned unique identifier for the Participant
 * @property {Participant#Type} type - The type of Participant
 * @fires Participant#typingEnded
 * @fires Participant#typingStarted
 * @fires Participant#updated
 */
declare class Participant extends EventEmitter {
    private state;
    private services;
    readonly conversation: Conversation;
    get sid(): string;
    get attributes(): Object;
    get dateCreated(): Date;
    get dateUpdated(): Date;
    get identity(): string;
    get isTyping(): boolean;
    get lastReadMessageIndex(): number | null;
    get lastReadTimestamp(): Date;
    get roleSid(): string;
    get type(): Participant.Type;
    /**
     * The update reason for <code>updated</code> event emitted on Participant
     * @typedef {('attributes' | 'dateCreated' | 'dateUpdated' | 'roleSid' |
     'lastReadMessageIndex' | 'lastReadTimestamp')} Participant#UpdateReason
     */
    /**
     * The type of Participant
     * @typedef {('chat' | 'sms' | 'whatsapp')} Participant#Type
     */
    constructor(services: ParticipantServices, conversation: Conversation, data: ParticipantDescriptor, sid: string);
    /**
     * Private method used to start or reset the typing indicator timeout (with event emitting)
     * @private
     */
    _startTyping(timeout: any): this;
    /**
     * Private method function used to stop typing indicator (with event emitting)
     * @private
     */
    _endTyping(): void;
    /**
     * Private method function used update local object's property roleSid with new value
     * @private
     */
    _update(data: any): this;
    /**
     * Gets User for this participant and subscribes to it. Supported only for <code>chat</code> type of Participants
     * @returns {Promise<User>}
     */
    getUser(): Promise<User>;
    /**
     * Remove Participant from the Conversation.
     * @returns {Promise<void>}
     */
    remove(): Promise<void>;
    /**
     * Edit participant attributes.
     * @param {any} attributes new attributes for Participant.
     * @returns {Promise<Participant>}
     */
    updateAttributes(attributes: any): Promise<Participant>;
}
interface MediaState {
    sid: string;
    filename?: string;
    contentType: string;
    size: number;
}
interface MediaServices {
    mcsClient: McsClient;
}
/**
 * @classdesc A Media represents a media information for Message in a Conversation.
 * @property {String} contentType - content type of media
 * @property {String} sid - The server-assigned unique identifier for Media
 * @property {Number} size - Size of media, bytes
 * @property {String} [filename] - file name if present, null otherwise
 */
declare class Media {
    private state;
    private services;
    private mcsMedia;
    constructor(data: MediaState, services: MediaServices);
    get sid(): string;
    get filename(): string;
    get contentType(): string;
    get size(): number;
    /**
     * Returns direct content URL for the media.
     *
     * This URL is impermanent, it will expire in several minutes and cannot be cached.
     * If the URL becomes expired, you need to request a new one.
     * Each call to this function produces a new temporary URL.
     *
     * @returns {Promise<String>}
     */
    getContentTemporaryUrl(): Promise<string>;
}
declare namespace AggregatedDeliveryReceipt {
    type DeliveryAmount = "none" | "some" | "all";
    interface AggregatedDeliveryDescriptor {
        total: number;
        delivered: DeliveryAmount;
        failed: DeliveryAmount;
        read: DeliveryAmount;
        sent: DeliveryAmount;
        undelivered: DeliveryAmount;
    }
}
/**
 * @classdesc Contains aggregated information about a {@link Message}'s delivery statuses across all {@link Participant}s
 * of a {@link Conversation}.
 *
 * At any moment during delivering message to a {@link Participant} the message can have zero or more of following
 * delivery statuses:
 *
 * <ul><li>
 * Message considered as <b>sent</b> to a participant, if the nearest upstream carrier accepted the message.
 * </li><li>
 * Message considered as <b>delivered</b> to a participant, if Twilio has received confirmation of message
 * delivery from the upstream carrier, and, where available, the destination handset.
 * </li><li>
 * Message considered as <b>undelivered</b> to a participant, if Twilio has received a delivery receipt
 * indicating that the message was not delivered. This can happen for many reasons including carrier content
 * filtering and the availability of the destination handset.
 * </li><li>
 * Message considered as <b>read</b> by a participant, if the message has been delivered and opened by the
 * recipient in the conversation. The recipient must have enabled read receipts.
 * </li><li>
 * Message considered as <b>failed</b> to be delivered to a participant if the message could not be sent.
 * This can happen for various reasons including queue overflows, account suspensions and media
 * errors (in the case of MMS for instance).
 *</li></ul>
 *
 * {@link AggregatedDeliveryReceipt} class contains aggregated value {@link AggregatedDeliveryReceipt#DeliveryAmount} for each delivery status.
 *
 * @property {number} total - Maximum number of delivery events expected for the message
 * @property {AggregatedDeliveryReceipt#DeliveryAmount} sent - Amount of participants that have <b>sent</b> delivery status for the message.
 * @property {AggregatedDeliveryReceipt#DeliveryAmount} delivered - Amount of participants that have <b>delivered</b> delivery status
 *   for the message.
 * @property {AggregatedDeliveryReceipt#DeliveryAmount} read - Amount of participants that have <b>read</b> delivery status for the message.
 * @property {AggregatedDeliveryReceipt#DeliveryAmount} undelivered - Amount of participants that have <b>undelivered</b> delivery status
 *   for the message.
 * @property {AggregatedDeliveryReceipt#DeliveryAmount} failed - Amount of participants that have <b>failed</b> delivery status for the message.
 */
declare class AggregatedDeliveryReceipt {
    private state;
    /**
     * Signifies amount of participants which have the status for the message.
     * @typedef {('none'|'some'|'all')} AggregatedDeliveryReceipt#DeliveryAmount
     */
    constructor(data: AggregatedDeliveryReceipt.AggregatedDeliveryDescriptor);
    /**
     * @return Maximum number of delivery events expected for the message.
     */
    get total(): number;
    /**
     * Message considered as <b>sent</b> to a participant, if the nearest upstream carrier accepted the message.
     *
     * @return {@link DeliveryAmount} of participants that have <b>sent</b> delivery status for the message.
     */
    get sent(): AggregatedDeliveryReceipt.DeliveryAmount;
    /**
     * Message considered as <b>delivered</b> to a participant, if Twilio has received confirmation of message
     * delivery from the upstream carrier, and, where available, the destination handset.
     *
     * @return {@link DeliveryAmount} of participants that have <b>delivered</b> delivery status for the message.
     */
    get delivered(): AggregatedDeliveryReceipt.DeliveryAmount;
    /**
     * Message considered as <b>read</b> by a participant, if the message has been delivered and opened by the
     * recipient in the conversation. The recipient must have enabled read receipts.
     *
     * @return {@link DeliveryAmount} of participants that have <b>read</b> delivery status for the message.
     */
    get read(): AggregatedDeliveryReceipt.DeliveryAmount;
    /**
     * Message considered as <b>undelivered</b> to a participant, if Twilio has received a delivery receipt
     * indicating that the message was not delivered. This can happen for many reasons including carrier content
     * filtering and the availability of the destination handset.
     *
     * @return {@link DeliveryAmount} of participants that have <b>undelivered</b> delivery status for the message.
     */
    get undelivered(): AggregatedDeliveryReceipt.DeliveryAmount;
    /**
     * Message considered as <b>failed</b> to be delivered to a participant if the message could not be sent.
     * This can happen for various reasons including queue overflows, account suspensions and media
     * errors (in the case of MMS for instance). Twilio does not charge you for failed messages.
     *
     * @return {@link DeliveryAmount} of participants that have <b>failed</b> delivery status for the message.
     */
    get failed(): AggregatedDeliveryReceipt.DeliveryAmount;
    _update(data: AggregatedDeliveryReceipt.AggregatedDeliveryDescriptor): void;
    _isEquals(data: AggregatedDeliveryReceipt.AggregatedDeliveryDescriptor): boolean;
}
declare namespace DetailedDeliveryReceipt {
    type Status = "sent" | "delivered" | "failed" | "read" | "undelivered" | "queued";
    interface Descriptor {
        sid: string;
        message_sid: string;
        conversation_sid: string;
        channel_message_sid: string;
        participant_sid: string;
        status: Status;
        error_code: number | null;
        date_created: string;
        date_updated: string;
    }
}
/**
 * @classdesc Represents a delivery receipt of a {@link Message}.
 *
 * @property {String} sid - The unique identifier for Delivery Receipt
 * @property {String} messageSid - The unique identifier for Conversation Message
 * @property {String} conversationSid - The unique identifier for Conversation
 * @property {String} channelMessageSid - The unique identifier for the ‘channel’ message e.g WAxx for Whatsapp, SMxx for SMS
 * @property {String} participantSid - Participant's unique identifier
 * @property {DetailedDeliveryReceipt#Status} status - Message delivery status
 * @property {number | null} errorCode - Numeric error code mapped from Status callback code. Information about the error codes can be found
 * <a href="https://www.twilio.com/docs/sms/api/message-resource#delivery-related-errors">here</a>.
 * @property {String} dateCreated - When Delivery Receipt was created
 * @property {String} dateUpdated - When Delivery Receipt was updated
 */
declare class DetailedDeliveryReceipt {
    sid: string;
    messageSid: string;
    conversationSid: string;
    channelMessageSid: string;
    participantSid: string;
    status: DetailedDeliveryReceipt.Status;
    errorCode: number | null;
    dateCreated: string;
    dateUpdated: string;
    /**
     * Signifies the message delivery status.
     * @typedef {('sent'|'delivered'|'failed'|'read'|'undelivered'|'queued')} DetailedDeliveryReceipt#Status
     */
    constructor(descriptor: DetailedDeliveryReceipt.Descriptor);
}
declare namespace Message {
    type Type = "text" | "media";
}
interface MessageServices {
    session: Session;
    mcsClient: McsClient;
    network: Network;
}
declare namespace Message {
    type UpdateReason = "body" | "lastUpdatedBy" | "dateCreated" | "dateUpdated" | "attributes" | "author" | "deliveryReceipt" | "subject";
    interface UpdatedEventArgs {
        message: Message;
        updateReasons: Message.UpdateReason[];
    }
}
/**
 * @classdesc A Message represents a Message in a Conversation.
 * @property {String} author - The name of the user that sent Message
 * @property {String|null} subject - Message subject. Used only in email conversations
 * @property {String} body - The body of the Message. Is null if Message is Media Message
 * @property {any} attributes - Message custom attributes
 * @property {Conversation} conversation - Conversation Message belongs to
 * @property {Date} dateCreated - When Message was created
 * @property {Date} dateUpdated - When Message was updated
 * @property {Number} index - Index of Message in the Conversation's messages list
 *  By design of the conversations system the message indices may have arbitrary gaps between them,
 *  that does not necessarily mean they were deleted or otherwise modified - just that
 *  messages may have non-contiguous indices even if they are sent immediately one after another.
 *
 *  Trying to use indices for some calculations is going to be unreliable.
 *
 *  To calculate the number of unread messages it is better to use the read horizon API.
 *  See {@link Conversation#getUnreadMessagesCount} for details.
 *
 * @property {String} lastUpdatedBy - Identity of the last user that updated Message
 * @property {Media} media - Contains Media information (if present)
 * @property {String} participantSid - Authoring Participant's server-assigned unique identifier
 * @property {String} sid - The server-assigned unique identifier for Message
 * @property {'text' | 'media'} type - Type of message: 'text' or 'media'
 * @property {AggregatedDeliveryReceipt | null} aggregatedDeliveryReceipt - Aggregated information about
 *   Message delivery statuses across all {@link Participant}s of a {@link Conversation}.
 * @fires Message#updated
 */
declare class Message extends EventEmitter {
    readonly conversation: Conversation;
    private services;
    private state;
    /**
     * The update reason for <code>updated</code> event emitted on Message
     * @typedef {('body' | 'lastUpdatedBy' | 'dateCreated' | 'dateUpdated' | 'attributes' | 'author' |
     *   'deliveryReceipt' | 'subject')} Message#UpdateReason
     */
    constructor(conversation: Conversation, services: MessageServices, index: number, data: any);
    get sid(): string;
    get author(): string;
    get subject(): string | null;
    get body(): string;
    get dateUpdated(): Date;
    get index(): number;
    get lastUpdatedBy(): string;
    get dateCreated(): Date;
    get attributes(): Object;
    get type(): Message.Type;
    get media(): Media;
    get participantSid(): string;
    get aggregatedDeliveryReceipt(): AggregatedDeliveryReceipt | null;
    _update(data: any): void;
    /**
     * Get Participant who is author of the Message
     * @returns {Promise<Participant>}
     */
    getParticipant(): Promise<Participant>;
    /**
     * Get delivery receipts of the message
     * @returns {Promise<DetailedDeliveryReceipt[]>}
     */
    getDetailedDeliveryReceipts(): Promise<DetailedDeliveryReceipt[]>;
    /**
     * Remove the Message.
     * @returns {Promise<Message>}
     */
    remove(): Promise<Message>;
    /**
     * Edit message body.
     * @param {String} body - new body of Message.
     * @returns {Promise<Message>}
     */
    updateBody(body: string): Promise<Message>;
    /**
     * Edit message attributes.
     * @param {any} attributes new attributes for Message.
     * @returns {Promise<Message>}
     */
    updateAttributes(attributes: any): Promise<Message>;
    private _getDetailedDeliveryReceiptsPaginator;
}
/**
 * Pagination helper class.
 *
 * @interface
 * @property {Array} items Elements on current page
 * @property {boolean} hasNextPage Indicates the existence of next page
 * @property {boolean} hasPrevPage Indicates the existence of previous page
 * @function {Promise<Paginator>} nextPage() Request next page. Does not modify existing object
 * @function {Promise<Paginator>} prevPage() Request previous page. Does not modify existing object
 */
interface Paginator<T> {
    hasNextPage: boolean;
    hasPrevPage: boolean;
    items: Array<T>;
    /**
     * Request next page.
     * Does not modify existing object.
     * @return {Promise<Paginator<T>>}
     */
    nextPage(): Promise<Paginator<T>>;
    /**
     * Request previous page.
     * Does not modify existing object.
     * @return {Promise<Paginator<T>>}
     */
    prevPage(): Promise<Paginator<T>>;
}
interface ReadHorizonServices {
    session: Session;
}
/**
 * @classdesc Provides read horizon management functionality
 */
declare class ReadHorizon {
    private readonly services;
    private readonly readHorizonRequests;
    private readHorizonUpdateTimer;
    constructor(services: ReadHorizonServices);
    private getReportInterval;
    private delayedSendReadHorizon;
    private sendConsumptionReport;
    private processConsumptionReportResponse;
    private processConsumptionReportError;
    /**
     * Updates read horizon value without any checks
     */
    updateLastReadMessageIndexForConversation(conversationSid: string, messageIdx: number): Promise<number>;
    /**
     * Move read horizon forward
     */
    advanceLastReadMessageIndexForConversation(conversationSid: string, messageIdx: number, currentConversationLastReadIndex: number): Promise<number>;
    private addPendingConsumptionHorizonRequest;
}
interface TypingIndicatorServices {
    transport: Transport;
    notificationClient: Notifications;
}
/**
 * An important note in regards to typing timeout timers. There are two places that the SDK can get the "typing_timeout" attribute from. The first
 * place that the attribute appears in is the response received from POST -> /v1/typing REST call. In the body of that response, the value of the
 * "typing_timeout" attribute will be exactly the same as defined in the console. The second place that the attribute appears in is from a
 * notification of type "twilio.ipmsg.typing_indicator". In this case, the "typing_timeout" value will be +1 of that in the console. This
 * intentional. The timeout returned from the POST -> /v1/typing call should be used to disable further calls for that period of time. On contrary,
 * the timeout returned from the notification should be used as the timeout for the "typingEnded" event, +1 is to account for latency.
 *
 * @private
 */
/**
 * @class TypingIndicator
 *
 * @constructor
 * @private
 */
declare class TypingIndicator {
    private readonly services;
    private readonly config;
    private sentUpdates;
    private getConversation;
    private serviceTypingTimeout;
    constructor(config: Configuration, services: TypingIndicatorServices, getConversation: any);
    get typingTimeout(): number;
    /**
     * Initialize TypingIndicator controller
     * Registers for needed message types and sets listeners
     * @private
     */
    initialize(): void;
    /**
     * Remote participants typing events handler
     * @private
     */
    handleRemoteTyping(message: any): void;
    /**
     * Send typing event for the given conversation sid
     * @param {String} conversationSid
     */
    send(conversationSid: string): any;
    private _send;
}
interface ConversationServices {
    session: Session;
    users: Users;
    typingIndicator: TypingIndicator;
    readHorizon: ReadHorizon;
    network: Network;
    mcsClient: McsClient;
    syncClient: SyncClient;
}
interface ConversationDescriptor {
    channel: string;
    entityName: string;
    uniqueName: string;
    attributes: any;
    createdBy?: string;
    friendlyName?: string;
    lastConsumedMessageIndex: number;
    dateCreated: any;
    dateUpdated: any;
    notificationLevel?: Conversation.NotificationLevel;
}
declare namespace Conversation {
    type UpdateReason = "attributes" | "createdBy" | "dateCreated" | "dateUpdated" | "friendlyName" | "lastReadMessageIndex" | "state" | "status" | "uniqueName" | "lastMessage" | "notificationLevel";
    type Status = "notParticipating" | "joined";
    type NotificationLevel = "default" | "muted";
    type State = {
        current: "active" | "inactive" | "closed";
        dateUpdated: Date;
    } | undefined;
    interface UpdatedEventArgs {
        conversation: Conversation;
        updateReasons: Conversation.UpdateReason[];
    }
    interface SendMediaOptions {
        contentType: string;
        media: string | Buffer;
    }
    interface SendEmailOptions {
        subject?: string;
    }
    interface LastMessage {
        index?: number;
        dateCreated?: Date;
    }
}
/**
 * @classdesc A Conversation represents communication between multiple Conversations Clients
 * @property {any} attributes - The Conversation's custom attributes
 * @property {String} createdBy - The identity of the User that created this Conversation
 * @property {Date} dateCreated - The Date this Conversation was created
 * @property {Date} dateUpdated - The Date this Conversation was last updated
 * @property {String} [friendlyName] - The Conversation's name
 * @property {Number|null} lastReadMessageIndex - Index of the last Message the User has read in this Conversation
 * @property {Conversation#LastMessage} lastMessage - Last Message sent to this Conversation
 * @property {Conversation#NotificationLevel} notificationLevel - User Notification level for this Conversation
 * @property {String} sid - The Conversation's unique system identifier
 * @property {Conversation#Status} status - The Conversation's status
 * @property {Conversation#State} state - The Conversation's state
 * @property {String} uniqueName - The Conversation's unique name
 * @fires Conversation#participantJoined
 * @fires Conversation#participantLeft
 * @fires Conversation#participantUpdated
 * @fires Conversation#messageAdded
 * @fires Conversation#messageRemoved
 * @fires Conversation#messageUpdated
 * @fires Conversation#typingEnded
 * @fires Conversation#typingStarted
 * @fires Conversation#updated
 * @fires Conversation#removed
 */
declare class Conversation extends EventEmitter {
    readonly sid: string;
    private services;
    private channelState;
    private statusSource;
    private entityPromise;
    private entityName;
    private entity;
    private messagesEntity;
    private participantsEntity;
    private participants;
    /**
     * These options can be passed to {@link Conversation#sendMessage}.
     * @typedef {Object} Conversation#SendMediaOptions
     * @property {String} contentType - content type of media
     * @property {String | Buffer} media - content to post
     */
    /**
     * These options can be passed to {@link Conversation#sendMessage}.
     * @typedef {Object} Conversation#SendEmailOptions
     * @property {String} subject - subject for the message. Ignored for media messages.
     */
    /**
     * The update reason for <code>updated</code> event emitted on Conversation
     * @typedef {('attributes' | 'createdBy' | 'dateCreated' | 'dateUpdated' |
     'friendlyName' | 'lastReadMessageIndex' | 'state' | 'status' | 'uniqueName' | 'lastMessage' |
     'notificationLevel' )} Conversation#UpdateReason
     */
    /**
     * The status of the Conversation, relative to the Client: whether the Conversation has been <code>joined</code> or the Client is
     * <code>notParticipating</code> in the Conversation.
     * @typedef {('notParticipating' | 'joined')} Conversation#Status
     */
    /**
     * The User's Notification level for Conversation, determines whether the currently logged-in User will receive
     * pushes for events in this Conversation. Can be either <code>muted</code> or <code>default</code>,
     * where <code>default</code> defers to global Service push configuration.
     * @typedef {('default' | 'muted')} Conversation#NotificationLevel
     */
    /**
     * The Conversation's state.
     * @typedef {Object} Conversation#State
     * @property {('active' | 'inactive' | 'closed')} current - the current state
     * @property {Date} dateUpdated - date at which the latest conversation state update happened
     */
    constructor(services: ConversationServices, descriptor: ConversationDescriptor, sid: string);
    get uniqueName(): string;
    get status(): Conversation.Status;
    get friendlyName(): string;
    get dateUpdated(): any;
    get dateCreated(): any;
    get createdBy(): string;
    get attributes(): Object;
    get lastReadMessageIndex(): number | null;
    get lastMessage(): Conversation.LastMessage;
    get notificationLevel(): Conversation.NotificationLevel;
    get state(): Conversation.State;
    /**
     * The Conversation's last message's information.
     * @typedef {Object} Conversation#LastMessage
     * @property {Number} index - Message's index
     * @property {Date} dateCreated - Message's creation date
     */
    /**
     * Load and Subscribe to this Conversation and do not subscribe to its Participants and Messages.
     * This or _subscribeStreams will need to be called before any events on Conversation will fire.
     * @returns {Promise}
     * @private
     */
    _subscribe(): Promise<any>;
    /**
     * Load the attributes of this Conversation and instantiate its Participants and Messages.
     * This or _subscribe will need to be called before any events on Conversation will fire.
     * This will need to be called before any events on Participants or Messages will fire
     * @returns {Promise}
     * @private
     */
    _subscribeStreams(): Promise<void>;
    /**
     * Stop listening for and firing events on this Conversation.
     * @returns {Promise}
     * @private
     */
    _unsubscribe(): Promise<[
        void,
        any
    ]>;
    /**
     * Set conversation status
     * @private
     */
    _setStatus(status: Conversation.Status, source: Conversations.DataSource): void;
    /**
     * If conversation's status update source
     * @private
     * @return {Conversations.DataSource}
     */
    _statusSource(): Conversations.DataSource;
    private static preprocessUpdate;
    /**
     * Updates local conversation object with new values
     * @private
     */
    _update(update: any): void;
    /**
     * @private
     */
    private _onMessageAdded;
    /**
     * Add a participant to the Conversation by its Identity.
     * @param {String} identity - Identity of the Client to add
     * @param {any} [attributes] Attributes to be attached to the participant
     * @returns {Promise<void>}
     */
    add(identity: string, attributes?: any): Promise<void>;
    /**
     * Add a non-chat participant to the Conversation.
     *
     * @param {String} proxyAddress Proxy (Twilio) address of the participant
     * @param {String} address User address of the participant
     * @param {any} [attributes] Attributes to be attached to the participant
     * @returns {Promise<void>}
     */
    addNonChatParticipant(proxyAddress: string, address: string, attributes?: Record<string, any>): Promise<any>;
    /**
     * Advance Conversation's last read Message index to current read horizon.
     * Rejects if User is not Participant of Conversation.
     * Last read Message index is updated only if new index value is higher than previous.
     * @param {Number} index - Message index to advance to as last read
     * @returns {Promise<number>} resulting unread messages count in the conversation
     */
    advanceLastReadMessageIndex(index: number): Promise<number>;
    /**
     * Delete the Conversation and unsubscribe from its events.
     * @returns {Promise<Conversation>}
     */
    delete(): Promise<Conversation>;
    /**
     * Get the custom attributes of this Conversation.
     * @returns {Promise<any>} attributes of this Conversation
     */
    getAttributes(): Promise<any>;
    /**
     * Returns messages from conversation using paginator interface.
     * @param {Number} [pageSize=30] Number of messages to return in single chunk
     * @param {Number} [anchor] - Index of newest Message to fetch. From the end by default
     * @param {('backwards'|'forward')} [direction=backwards] - Query direction. By default it query backwards
     *                                                          from newer to older. 'forward' will query in opposite direction
     * @returns {Promise<Paginator<Message>>} page of messages
     */
    getMessages(pageSize?: number, anchor?: number, direction?: "backwards" | "forward"): Promise<Paginator<Message>>;
    /**
     * Get a list of all Participants joined to this Conversation.
     * @returns {Promise<Participant[]>}
     */
    getParticipants(): Promise<Participant[]>;
    /**
     * Get conversation participants count.
     * <br/>
     * This method is semi-realtime. This means that this data will be eventually correct,
     * but will also possibly be incorrect for a few seconds. The Conversation system does not
     * provide real time events for counter values changes.
     * <br/>
     * So this is quite useful for any UI badges, but is not recommended
     * to build any core application logic based on these counters being accurate in real time.
     * @returns {Promise<number>}
     */
    getParticipantsCount(): Promise<number>;
    /**
     * Get a Participant by its SID.
     * @param {String} participantSid - Participant sid
     * @returns {Promise<Participant>}
     */
    getParticipantBySid(participantSid: string): Promise<Participant>;
    /**
     * Get a Participant by its identity.
     * @param {String} identity - Participant identity
     * @returns {Promise<Participant>}
     */
    getParticipantByIdentity(identity: string): Promise<Participant>;
    /**
     * Get total message count in a conversation.
     * <br/>
     * This method is semi-realtime. This means that this data will be eventually correct,
     * but will also possibly be incorrect for a few seconds. The Conversations system does not
     * provide real time events for counter values changes.
     * <br/>
     * So this is quite useful for any UI badges, but is not recommended
     * to build any core application logic based on these counters being accurate in real time.
     * @returns {Promise<number>}
     */
    getMessagesCount(): Promise<number>;
    /**
     * Get unread messages count for the User if they are a Participant of this Conversation.
     * Rejects if the User is not a Participant of the Conversation.
     * <br/>
     * Use this method to obtain the number of unread messages together with
     * updateLastReadMessageIndex() instead of relying on the
     * Message indices which may have gaps. See Message.index for details.
     * <br/>
     * This method is semi-realtime. This means that this data will be eventually correct,
     * but will also possibly be incorrect for a few seconds. The Chat system does not
     * provide real time events for counter values changes.
     * <br/>
     * This is quite useful for any “unread messages count” badges, but is not recommended
     * to build any core application logic based on these counters being accurate in real time.
     * @returns {Promise<number|null>}
     */
    getUnreadMessagesCount(): Promise<number | null>;
    /**
     * Join the Conversation and subscribe to its events.
     * @returns {Promise<Conversation>}
     */
    join(): Promise<Conversation>;
    /**
     * Leave the Conversation.
     * @returns {Promise<Conversation>}
     */
    leave(): Promise<Conversation>;
    /**
     * Remove a Participant from the Conversation. When a string is passed as the argument, it will assume that the string is an identity.
     * @param {String|Participant} participant - identity or participant object to remove
     * @returns {Promise<void>}
     */
    removeParticipant(participant: string | Participant): Promise<void>;
    /**
     * Send a Message in the Conversation.
     * @param {String|FormData|Conversation#SendMediaOptions|null} message - The message body for text message,
     * FormData or MediaOptions for media content. Sending FormData supported only with browser engine
     * @param {any} [messageAttributes] - attributes for the message
     * @param {Conversation#SendEmailOptions} [emailOptions] - email options for the message
     * @returns {Promise<number>} new Message's index in the Conversation's messages list
     */
    sendMessage(message: string | FormData | Conversation.SendMediaOptions | null, messageAttributes?: any, emailOptions?: Conversation.SendEmailOptions): Promise<number>;
    /**
     * Set last read Conversation's Message index to last known Message's index in this Conversation.
     * @returns {Promise<number>} resulting unread messages count in the conversation
     */
    setAllMessagesRead(): Promise<number>;
    /**
     * Set all messages in the conversation unread.
     * @returns {Promise<number>} resulting unread messages count in the conversation
     */
    setAllMessagesUnread(): Promise<number>;
    /**
     * Set User Notification level for this conversation.
     * @param {Conversation#NotificationLevel} notificationLevel - The new user notification level
     * @returns {Promise<void>}
     */
    setUserNotificationLevel(notificationLevel: Conversation.NotificationLevel): Promise<void>;
    /**
     * Send a notification to the server indicating that this Client is currently typing in this Conversation.
     * Typing ended notification is sent after a while automatically, but by calling again this method you ensure typing ended is not received.
     * @returns {Promise<void>}
     */
    typing(): Promise<void>;
    /**
     * Update the Conversation's attributes.
     * @param {any} attributes - The new attributes object
     * @returns {Promise<Conversation>}
     */
    updateAttributes(attributes: any): Promise<Conversation>;
    /**
     * Update the Conversation's friendlyName.
     * @param {String|null} name - The new Conversation friendlyName
     * @returns {Promise<Conversation>}
     */
    updateFriendlyName(name: string | null): Promise<Conversation>;
    /**
     * Set Conversation's last read Message index to current read horizon.
     * @param {Number|null} index - Message index to set as last read.
     * If null provided, then the behavior is identical to {@link Conversation#setAllMessagesUnread}
     * @returns {Promise<number>} resulting unread messages count in the conversation
     */
    updateLastReadMessageIndex(index: number | null): Promise<number>;
    /**
     * Update the Conversation's unique name.
     * @param {String|null} uniqueName - New unique name for the Conversation. Setting unique name to null removes it.
     * @returns {Promise<Conversation>}
     */
    updateUniqueName(uniqueName: string | null): Promise<Conversation>;
}
/**
 * @class Paginator
 * @classdesc Pagination helper class
 *
 * @property {Array} items Array of elements on current page
 * @property {boolean} hasNextPage Indicates the existence of next page
 * @property {boolean} hasPrevPage Indicates the existence of previous page
 */
declare class RestPaginator<T> implements Paginator<T> {
    private state;
    get hasNextPage(): boolean;
    get hasPrevPage(): boolean;
    get items(): Array<T>;
    /*
    * @constructor
    * @param {Array} items Array of element for current page
    * @param {Object} params
    * @private
    */
    constructor(items: any, source: any, prevToken: any, nextToken: any);
    nextPage(): Promise<RestPaginator<T>>;
    prevPage(): Promise<RestPaginator<T>>;
}
declare class SyncListDescriptor {
    readonly channel_sid: string;
    readonly status: string;
    readonly channel: string;
    readonly messages: string;
    readonly roster: string;
    readonly lastConsumedMessageIndex: number | null;
    readonly notificationLevel: Conversation.NotificationLevel;
    readonly descriptor: any;
    /**
     * @param {Object} descriptor - sync list descriptor data object
     * @private
     */
    constructor(descriptor: any);
}
interface SyncListServices {
    session: Session;
    network: Network;
}
/**
 * Provides async pagination interface for sync list
 *
 * @property {Network} network Network transport
 * @property {string} syncListUrl Url to the sync list endpoint
 */
declare class SyncList {
    private readonly services;
    /**
     * @param {SyncListServices} services - services needed for SyncList service
     * @private
     */
    constructor(services: SyncListServices);
    getPage(args?: any): Promise<RestPaginator<SyncListDescriptor>>;
}
declare class Deferred<T> {
    private _promise;
    private _resolve;
    private _reject;
    current: T;
    constructor();
    get promise(): Promise<T>;
    update(value: T): void;
    set(value: T): void;
    fail(e: any): void;
}
interface ConversationsServices {
    session: Session;
    syncClient: SyncClient;
    syncList: SyncList;
    users: Users;
    typingIndicator: TypingIndicator;
    readHorizon: ReadHorizon;
    network: Network;
    mcsClient: McsClient;
}
/**
 * Represents conversations collection
 * {@see Conversation}
 */
declare class Conversations extends EventEmitter {
    private services;
    readonly conversations: Map<string, Conversation>;
    private readonly thumbstones; // sids
    private syncListFetched;
    readonly syncListRead: Deferred<boolean>;
    constructor(services: ConversationsServices);
    private getMap;
    /**
     * Add conversation to server
     * @private
     * @returns {Promise<Conversation>} Conversation
     */
    addConversation(options: any): Promise<Conversation>;
    /**
     * Fetch conversations list and instantiate all necessary objects
     */
    fetchConversations(): void;
    private _wrapPaginator;
    getConversations(args: any): Promise<any>;
    getConversation(sid: string): Promise<Conversation>;
    getConversationByUniqueName(uniqueName: string): Promise<Conversation>;
    getWhisperConversation(sid: string): Promise<Conversation>;
    private upsertConversation;
    private onConversationRemoved;
    private registerForEvents;
}
declare namespace Conversations {
    type DataSource = "sync" | "chat" | "synclist";
}
declare namespace PushNotification {
    type Type = "twilio.conversations.new_message" | "twilio.conversations.added_to_conversation" | "twilio.conversations.removed_from_conversation";
    interface Descriptor {
        title: string;
        body: string;
        sound: string;
        badge: number;
        action: string;
        type: PushNotification.Type;
        data: Object;
    }
}
/**
 * @classdesc Push notification representation within Conversations Client
 * @property {String} [action] - Notification action (`click_action` in FCM/GCM terms and `category` in APN terms)
 * @property {Number} [badge] - Number for the badge
 * @property {String} body - Notification text
 * @property {PushNotification#ConversationData} data - Additional Conversation data
 * @property {String} [sound] - Notification sound
 * @property {String} [title] - Notification title
 * @property {PushNotification#NotificationType} type - Notification type
 */
declare class PushNotification {
    readonly title: string;
    readonly body: string;
    readonly sound: string;
    readonly badge: number;
    readonly action: string;
    readonly type: PushNotification.Type;
    readonly data: Object;
    /**
     * Conversation push notification type
     * @typedef {('twilio.conversations.new_message' | 'twilio.conversations.added_to_conversation'
     | 'twilio.conversations.removed_from_conversation')} PushNotification#NotificationType
     */
    /**
     * Additional Conversations data for given Push Notification
     * @typedef {Object} PushNotification#ConversationData
     * @property {String} [conversationSid] - SID of Conversation
     * @property {Number} [messageIndex] - Index of Message in Conversation
     * @property {String} [messageSid] - SID of Message
     */
    /**
     * @param {PushNotification.Descriptor} data - initial data for PushNotification
     */
    constructor(data: PushNotification.Descriptor);
}
declare namespace Client {
    type ConnectionState = NotificationConnectionState;
    type NotificationsChannelType = ChannelType;
    type LogLevel = "trace" | "debug" | "info" | "warn" | "error" | "silent" | null;
    interface Options {
        region?: string;
        logLevel?: Client.LogLevel;
        productId?: string;
        twilsockClient?: TwilsockClient;
        transport?: Transport;
        notificationsClient?: NotificationClient;
        syncClient?: SyncClient;
        typingIndicatorTimeoutOverride?: number;
        consumptionReportIntervalOverride?: string;
        httpCacheIntervalOverride?: string;
        userInfosToSubscribeOverride?: number;
        retryWhenThrottledOverride?: boolean;
        backoffConfigOverride?: any;
        Chat?: any;
        Sync?: any;
        Notification?: any;
        Twilsock?: any;
        clientMetadata?: any;
    }
    interface CreateConversationOptions {
        attributes?: any;
        friendlyName?: string;
        uniqueName?: string;
    }
}
/**
 * A Client is a starting point to access Twilio Conversations functionality.
 *
 * @property {Client#ConnectionState} connectionState - Client connection state
 * @property {Boolean} reachabilityEnabled - Client reachability state
 * @property {User} user - Information for logged in user
 * @property {String} version - Current version of Conversations client
 *
 * @fires Client#connectionError
 * @fires Client#connectionStateChanged
 * @fires Client#conversationAdded
 * @fires Client#conversationJoined
 * @fires Client#conversationLeft
 * @fires Client#conversationRemoved
 * @fires Client#conversationUpdated
 * @fires Client#participantJoined
 * @fires Client#participantLeft
 * @fires Client#participantUpdated
 * @fires Client#messageAdded
 * @fires Client#messageRemoved
 * @fires Client#messageUpdated
 * @fires Client#pushNotification
 * @fires Client#tokenAboutToExpire
 * @fires Client#tokenExpired
 * @fires Client#typingEnded
 * @fires Client#typingStarted
 * @fires Client#userSubscribed
 * @fires Client#userUnsubscribed
 * @fires Client#userUpdated
 */
declare class Client extends EventEmitter {
    connectionState: Client.ConnectionState;
    private sessionPromise;
    private conversationsPromise;
    private fpaToken;
    private config;
    private conversations;
    private options;
    private services;
    static readonly version: string;
    readonly version: string;
    private static readonly supportedPushChannels;
    private static readonly supportedPushDataFields;
    /**
     * These options can be passed to Client constructor.
     * @typedef {Object} Client#ClientOptions
     * @property {String} [logLevel='error'] - The level of logging to enable. Valid options
     *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']
     */
    /**
     * These options can be passed to {@link Client#createConversation}.
     * @typedef {Object} Client#CreateConversationOptions
     * @property {any} [attributes] - Any custom attributes to attach to the Conversation
     * @property {String} [friendlyName] - The non-unique display name of the Conversation
     * @property {String} [uniqueName] - The unique identifier of the Conversation
     */
    /**
     * Connection state of Client.
     * @typedef {('connecting'|'connected'|'disconnecting'|'disconnected'|'denied')} Client#ConnectionState
     */
    /**
     * Notifications channel type.
     * @typedef {('fcm'|'apn')} Client#NotificationsChannelType
     */
    private constructor();
    /**
     * Factory method to create Conversations client instance.
     *
     * @param {String} token - Access token
     * @param {Client#ClientOptions} [options] - Options to customize the Client
     * @returns {Promise<Client>}
     */
    static create(token: string, options?: Client.Options): Promise<Client>;
    get user(): User;
    get reachabilityEnabled(): boolean;
    get token(): string;
    private subscribeToPushNotifications;
    private unsubscribeFromPushNotifications;
    private initialize;
    /**
     * Gracefully shutting down library instance.
     * @public
     * @returns {Promise<void>}
     */
    shutdown(): Promise<void>;
    /**
     * Update the token used by the Client and re-register with Conversations services.
     * @param {String} token - Access token
     * @public
     * @returns {Promise<Client>}
     */
    updateToken(token: string): Promise<Client>;
    /**
     * Get a known Conversation by its SID.
     * @param {String} conversationSid - Conversation sid
     * @returns {Promise<Conversation>}
     */
    getConversationBySid(conversationSid: string): Promise<Conversation>;
    /**
     * Get a known Conversation by its unique identifier name.
     * @param {String} uniqueName - The unique identifier name of the Conversation to get
     * @returns {Promise<Conversation>}
     */
    getConversationByUniqueName(uniqueName: string): Promise<Conversation>;
    /**
     * Get the current list of all subscribed Conversations.
     * @returns {Promise<Paginator<Conversation>>}
     */
    getSubscribedConversations(args?: any): Promise<Paginator<Conversation>>;
    /**
     * Create a Conversation on the server and subscribe to its events.
     * The default is a Conversation with an empty friendlyName.
     * @param {Client#CreateConversationOptions} [options] - Options for the Conversation
     * @returns {Promise<Conversation>}
     */
    createConversation(options?: Client.CreateConversationOptions): Promise<Conversation>;
    /**
     * Registers for push notifications.
     * @param {Client#NotificationsChannelType} channelType - 'apn' and 'fcm' are supported
     * @param {string} registrationId - Push notification id provided by the platform
     * @returns {Promise<void>}
     */
    setPushRegistrationId(channelType: Client.NotificationsChannelType, registrationId: string): Promise<void>;
    /**
     * Unregisters from push notifications.
     * @param {Client#NotificationsChannelType} channelType - 'apn' and 'fcm' are supported
     * @returns {Promise<void>}
     */
    unsetPushRegistrationId(channelType: Client.NotificationsChannelType): Promise<void>;
    private static parsePushNotificationChatData;
    /**
     * Static method for push notification payload parsing. Returns parsed push as {@link PushNotification} object
     * @param {Object} notificationPayload - Push notification payload
     * @returns {PushNotification|Error}
     */
    static parsePushNotification(notificationPayload: any): PushNotification;
    parsePushNotification: typeof Client.parsePushNotification;
    /**
     * Handle push notification payload parsing and emits event {@link Client#event:pushNotification} on this {@link Client} instance.
     * @param {Object} notificationPayload - Push notification payload
     * @returns {Promise<void>}
     */
    handlePushNotification(notificationPayload: any): Promise<void>;
    /**
     * Gets user for given identity, if it's in subscribed list - then return the user object from it,
     * if not - then subscribes and adds user to the subscribed list.
     * @param {String} identity - Identity of User
     * @returns {Promise<User>} Fully initialized user
     */
    getUser(identity: string): Promise<User>;
    /**
     * @returns {Promise<Array<User>>} List of subscribed User objects
     */
    getSubscribedUsers(): Promise<Array<User>>;
}
export { Client as default, Client, User, PushNotification };
